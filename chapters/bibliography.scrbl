#lang scribble/book
@(require "style.rkt")

@title[#:style part-title-style-unnumbered #:tag "bib"]{参考书目}

@bib{
@bib-author{Abadi, Martín}, & @bib-author{Cardelli, Luca}. 1996. @bib-title{A Theory of Objects}. Berlin, Heidelberg,
and New York: Springer-Verlag.
}

@bib{
@bib-author{Abelson, Harold}, & @bib-author{Sussman, Gerald Jay}. 1985. @bib-title{The Structure and Interpretation
of Computer Programs}. Cambridge, MA: MIT Press.
}

@bib{
@bib-author{Abelson, Harold}, & @bib-author{Sussman, Gerald Jay}. 1996. @bib-title{Structure and Interpretation of
Computer Programs}. Second edition. Cambridge, MA: McGraw Hill.
}

@bib{
@bib-author{Aho, Alfred V.}, @bib-author{Lam, Monica S.}, @bib-author{Sethi, Ravi}, & @bib-author{Ullman, Jeffrey
D.} 2006. @bib-title{Compilers: Principles, Techniques, and Tools}. Second edition. Boston:
Addison-Wesley Longman.
}

@bib{
@bib-author{Appel, Andrew W.}, & @bib-author{Jim, Trevor}. 1989. @bib-title{Continuation-Passing, Closure-Passing
Style}. Pages 293–302 of: Proceedings ACM Symposium on Principles of Programming
Languages.
}

@bib{
@bib-author{Arnold, Ken}, & @bib-author{Gosling, James}. 1998. @bib-title{The Java Programming Language}. Second
edition. The Java Series. Reading, MA: Addison-Wesley.
}

@bib{
@bib-author{Armstrong, Joe}. 2007. @bib-title{Programming Erlang: Software for a Concurrent World}. The
Pragmatic Programmers Publishers.
}

@bib{
@bib-author{Backus, John W.}, @emph{et al}. 1957. @bib-title{The Fortran Automatic Coding System}. Pages 188–198
of: Western Joint Computer Conference.
}

@bib{
@bib-author{Barendregt, Henk P.} 1981. @bib-title{The Lambda Calculus: Its Syntax and
Semantics}. Amsterdam: North-Holland.
}

@bib{
@bib-author{Barendregt, Henk P.} 1991. @bib-title{The Lambda Calculus}. Revised edition. Studies in Logic
and the Foundations of Mathematics, no. 103. Amsterdam: North-Holland.
}

@bib{
@bib-author{Bergin, Thomas J.}, & @bib-author{Gibson, Richard G.} (eds.). 1996. @bib-title{History of Programming
Languages}. New York: Addison-Wesley.
}

@bib{
@bib-author{Birtwistle, Graham M.}, @bib-author{Dahl, Ole-Johan}, & @bib-author{Myhrhaug, Bjorn}. 1973. @bib-title{Simula Begin}.
Philadelphia: Auerbach.
}

@bib{
@bib-author{Burstall, Rod M.} 1969. @bib-title{Proving Properties of Programs by Structural
Induction}. Computer Journal, @bold{12}(1), 41–48.
}

@bib{
@bib-author{Church, Alonzo}. 1941. @bib-title{The Calculi of Lambda Conversion}. Princeton, NJ: Princeton
University Press. Reprinted 1963 by University Microfilms, Ann Arbor, MI.
}

@bib{
@bib-author{Clinger, William D.}, @emph{et al}. 1985a. The Revised Revised Report on Scheme or The
Uncommon Lisp. Technical Memo AIM-848. Massachusetts Institute of Technology,
Artificial Intelligence Laboratory.
}

@bib{
@bib-author{Clinger, William D.}, @bib-author{Friedman, Daniel P.}, & @bib-author{Wand, Mitchell}. 1985b. A Scheme for
a Higher-Level Semantic Algebra. Pages 237–250 of: Reynolds, John, & Nivat,
Maurice (eds.), @bib-title{Algebraic Methods in Semantics: Proceedings of the US-French
Seminar on the Application of Algebra to Language Definition and Compilation
(Fontainebleau, France, June, 1982)}. Cambridge: Cambridge University Press.
}

@bib{
@bib-author{Clinger, William D.}, @bib-author{Rees, Jonathan}, @emph{et al}. 1991. The Revised@superscript{4} Report on the
Algorithmic Language Scheme. @bib-title{ACM Lisp Pointers}, @bold{4}(3), 1–55.
}

@bib{
@bib-author{Danvy, Olivier}, & @bib-author{Filinski, Andrzej}. 1992. Representing Control: A Study of the
CPS Transformation. @bib-title{Mathematical Structures in Computer Science}, @bold{2}(4), 361–391.
}

@bib{
@bib-author{Danvy, Olivier}, & @bib-author{Nielsen, Lasse R.} 2003. A First-order One-pass CPS
Transformation. @bib-title{Theoretical Computer Science}, @bold{308}(1-3), 239–257.
}

@bib{
@bib-author{de Bruijn, N. G.} 1972. Lambda Calculus Notation with Nameless Dummies: A Tool
for Automatic FormulaManipulation, with Application to the Church-Rosser
Theorem. @bib-title{Indagationes Mathematicae}, @bold{34}, 381–392.
}

@bib{
@bib-author{Dominus, Mark Jason}. 2005. @bib-title{Higher-Order Perl: Transforming Programs with
Programs}. San Francisco: Morgan Kaufmann Publishers.
}

@bib{
@bib-author{Dybvig, R. Kent}. 2003. @bib-title{The Scheme Programming Language}. Third
edition. Cambridge, MA: MIT Press.
}

@bib{
@bib-author{Felleisen, Matthias}, & @bib-author{Friedman, Daniel P.} 1996. @bib-title{The Little MLer}. Cambridge, MA:
MIT Press.
}

@bib{
@bib-author{Felleisen, Matthias}, @bib-author{Findler, Robert Bruce}, @bib-author{Flatt, Matthew}, & @bib-author{Krishnamurthi,
Shriram}. 2001. @bib-title{How to Design Programs}. Cambridge, MA: MIT Press.
}

@bib{
@bib-author{Fischer, Michael J.} 1972. Lambda-Calculus Schemata. Pages 104–109 of:
@bib-title{Proceedings ACM Conference on Proving Assertions about Programs}. Republished in
Lisp and Symbolic Computation, @bold{6}(3/4), 259–288.
}

@bib{
@bib-author{Flanagan, Cormac}, @bib-author{Sabry, Amr}, @bib-author{Duba, Bruce F.}, & @bib-author{Felleisen, Matthias}. 1993. The
Essence of Compiling with Continuations. Pages 237–247 of: @bib-title{Proceedings ACM
SIGPLAN 1993 Conf. on Programming Language Design and Implementation, PLDI’93,
Albuquerque, NM, USA, 23–25 June 1993}, vol. @bold{28}(6). New York: ACM Press.
}

@bib{
@bib-author{Flatt, Matthew}, @bib-author{Krishnamurthi, Shriram}, & @bib-author{Felleisen, Matthias}. 1998. Classes and
Mixins. Pages 171–183 of: @bib-title{Proceedings ACMSymposium on Principles of Programming
Languages}.
}

@bib{
@bib-author{Friedman, Daniel P.} 1974. @bib-title{The Little LISPer}. Palo Alto, CA: Science Research
Associates.
}

@bib{
@bib-author{Friedman, Daniel P.}, & @bib-author{Felleisen, Matthias}. 1996. @bib-title{The Little Schemer}. Fourth
edition. Cambridge, MA: MIT Press.
}

@bib{
@bib-author{Friedman, Daniel P.}, & @bib-author{Wise, David S.} 1976. Cons should not Evaluate its
Arguments. Pages 257–284 of: Michaelson, S., &
@bib-author[#:key "Milner, Robin" #:index "Milner, Robin"]{Milner, R.} (eds.), @bib-title{Automata,
Languages and Programming}. Edinburgh: Edinburgh University Press.
}

@bib{
@bib-author{Gamma, Erich}, @bib-author{Helm, Richard}, @bib-author{Johnson, Ralph}, & @bib-author{Vlissides, John}. 1995. @bib-title{Design
Patterns: Bookents of Reusable Object-Oriented Software}. Reading, MA: Addison
Wesley.
}

@bib{
@bib-author{Giarratana, V.}, @bib-author{Gimona, F.}, &
@bib-author[#:key "Montanari, Ugo" #:index "Montanari, Ugo"]{Montanari, U.} 1976. Observability Concepts in
Abstract Data Type Specifications. Pages 576–587 of: Mazurkiewicz, A. (ed.),
@bib-title{Mathematical Foundations of Computer Science 1976}. Lecture Notes in Computer
Science, vol. 45. Berlin, Heidelberg, New York: Springer-Verlag.
}

@bib{
@bib-author{Goguen, Joseph A.}, @bib-author{Thatcher, James W.},
@bib-author{Wagner, Eric G.}, & @bib-author{Wright, Jesse B.} 1977.  Initial
Algebra Semantics and Continuous Algebras. @bib-title{Journal of the ACM},
@bold{24}, 68–95.
}

@bib{
@bib-author{Goldberg, Adele}, & @bib-author{Robson, David}. 1983. @bib-title{Smalltalk-80: The Language and Its
Implementation}. Reading, MA: Addison-Wesley.
}

@bib{
@bib-author{Gordon, Andrew D.} 1995. A Tutorial on Co-induction and Functional Programming.
Pages 78–95 of: @bib-title{Functional Programming, Glasgow 1994}. Berlin, Heidelberg, and
New York: SpringerWorkshops in Computing.
}

@bib{
@bib-author{Gosling, James}, @bib-author{Joy, Bill}, & @bib-author{Steele, Guy L.} 1996. @bib-title{The Java Language
Specification}. The Java Series. Reading, MA: Addison-Wesley.
}

@bib{
@bib-author{Hailpern, Brent} (ed.). 2007. @bib-title{HOPL III: Proceedings of the Third ACM SIGPLAN
Conference on History of Programming Languages}. New York: ACM Press.
}

@bib{
@bib-author{Hankin, Chris}. 1994. @bib-title{Lambda Calculi: A Guide for Computer Scientists}. Graduate
Texts in Computer Science, vol. 3. Oxford: Clarendon Press.
}

@bib{
@bib-author{Haynes, Christopher T.}, @bib-author{Friedman, Daniel P.}, &
@bib-author{Wand, Mitchell}. 1986. Obtaining Coroutines with
Continuations. @bib-title{J. of Computer Languages}, @bold{11}(3/4), 143–153.
}

@bib{
@bib-author{Hewitt, Carl}. 1977. Viewing Control Structures as Patterns of Passing
Messages. @bib-title{Artificial Intelligence}, @bold{8}, 323–364.
}

@bib{
@bib-author{Hindley, Roger}. 1969. The Principal Type-Scheme of an Object in Combinatory
Logic. @bib-title{Transactions of the American Mathematical Society}, @bold{146}, 29–60.
}

@bib{
@bib-author{Hudak, Paul}, @emph{et al}. 1990. Report on the Programming Language HASKELL. Technical
Report YALEU/DCS/RR-777. Yale University, CS Dept.
}

@bib{
IEEE. 1991. @bib-title{IEEE Standard for the Scheme Programming Language, IEEE Standard
1178-1990}. IEEE Computer Society, New York.
}

@bib{
@bib-author{Igarashi, Atshushi}, @bib-author{Pierce, Benjamin C.}, &
@bib-author{Wadler, Philip}. 1999. Featherweight Java: AMinimal Core Calculus
for Java and GJ. Pages 132–146 of: Meissner, Loren (ed.), @bib-title{Proceedings
of the 1999 ACM SIGPLAN Conference on Object-Oriented Programming, Systems,
Languages & Applications (OOPSLA ‘99)}.
}

@bib{
@bib-author{Ingerman, Peter Z.} 1961. Thunks, A Way of Compiling Procedure Statements with
Some Comments on Procedure Declarations. @bib-title{Communications of the ACM}, @bold{4}(1), 55–58.
}

@bib{
@bib-author{Jacobs, Bart}, & @bib-author{Rutten, Jan}. 1997. A Tutorial on (Co)Algebras and (Co)Induction.
@bib-title{Bulletin of the European Association for Theoretical Computer Science}, @bold{62},
222–259.
}

@bib{
@bib-author{Johnston, John B.} 1971. The Contour Model of Block Structured Processes. @bib-title{SIGPLAN}
Notices, @bold{6}(2), 55–82.
}

@bib{
@bib-author{Kamin, Samuel}. 1980. Final Data Type Specifications: A New Data Type
Specification Method. Pages 131–138 of: @bib-title{Proceedings ACM Symposium on Principles
of Programming Languages}.
}

@bib{
@bib-author{Kelsey, Richard},
@bib-author{Clinger, William D.}, &
@bib-author{Rees, Jonathan}. 1998. Revised@superscript{5} Report on
the Algorithmic Language Scheme. @bib-title{Higher-Order and Symbolic Computation}, @bold{11}(1),
7–104.
}

@bib{
@bib-author[#:key "Kiczales, Gregor" #:index "Kiczales, Gregor"]{Kiczales, G.},
@bib-author[#:key "Rivieres, Jim" #:index "des Rivières, Jim"]{des Rivières, J.}, &
@bib-author[#:key "Bobrow, Daniel" #:index "Bobrow, Daniel"]{Bobrow, D. G.}
1991. @bib-title{The Art of the Meta-Object Protocol}. Cambridge, MA: MIT Press.
}

@bib{
@bib-author{Knuth, Donald E.} 1968. Semantics of Context-Free Languages. @bib-title{Mathematical Systems
Theory}, @bold{2}, 127–145. Correction, 5:95–96, 1971.
}

@bib{
@bib-author{Knuth, Donald E.}, &
@bib-author[#:key "Pardo, L." #:index "Pardo, L."]{Pardo, L. T.}
1977. The Early Development of Programming Languages. Pages 419–493 of: Belzer,
J., Holzman, A. G., & Kent, D. (eds.), @bib-title{Encyclopedia of Computer
Science and Technology}, vol. 6. New York: Marcel Dekker.
}

@bib{
@bib-author{Kranz, David A.},
@bib-author{Kelsey, Richard}, @bib-author{Rees, Jonathan A.},
@bib-author{Hudak, Paul}, @bib-author{Philbin, James}, &
@bib-author{Adams, Norman I.}
1986. Orbit: An Optimizing Compiler for Scheme. Pages
219–223 of: @bib-title{Proceedings SIGPLAN ’86 Symposium on Compiler Construction}.
}

@bib{
@bib-author{Landin, Peter J.} 1965a. Correspondence between ALGOL 60 and Church’s
Lambda-notation: Part I. @bib-title{Commun}. ACM, @bold{8}(2), 89–101.
}

@bib{
@bib-author{Landin, Peter J.} 1965b. A Generalization of Jumps and Labels. Technical Report.
UNIVAC Systems Programming Research. Reprinted with a foreword in @bib-title{Higher-Order
and Symbolic Computation}, @bold{11}(2):125–143, 1998.
}

@bib{
@bib-author{Leroy, Xavier}. 1994. Manifest Types, Modules, and Separate Compilation. Pages
190–122 of: @bib-title{Proceedings ACM Symposium on Principles of Programming Languages}.
}

@bib{
@bib-author{Lewis, Bil}, & @bib-author{Berg, Daniel J.} 1998. @bib-title{Multithreaded Programming with
PThreads}. Englewood Cliffs, NJ: Prentice-Hall.
}

@bib{
@bib-author{Liskov, Barbara}, @bib-author{Snyder, Alan}, @bib-author{Atkinson, R.}, &
@bib-author{Schaffert, Craig}. 1977. Abstraction Mechanisms in
CLU. @bib-title{Communications of the ACM}, @bold{20}, 564–576.
}

@bib{
@bib-author{McCarthy, John}. 1960. Recursive Functions of Symbolic Expressions and their
Computation by Machine, Part I. @bib-title{Communications of the ACM}, @bold{3}, 184–195.
}

@bib{
@bib-author{McCarthy, John}. 1962. Towards aMathematical Science of Computation. Pages 21–28
of: Popplewell (ed.), @bib-title{Information Processing 62}. Amsterdam: North-Holland.
}

@bib{
@bib-author{Michie, Donald}. 1968. “Memo” Functions and Machine Learning. @bib-title{Nature}, @bold{218}(1–3),
218–219.
}

@bib{
@bib-author{Milne, Robert}, & @bib-author{Strachey, Christopher}. 1976. @bib-title{A Theory of Programming Language
Semantics}. London: Chapman and Hall.
}

@bib{
@bib-author{Milner, Robin}. 1978. A Theory of Type Polymorphism in Programming. @bib-title{Journal of
Computer and Systems Science}, @bold{17}, 348–375.
}

@bib{
@bib-author{Milner, Robin}, @bib-author{Tofte, Mads}, & @bib-author{Harper, Robert}. 1989. @bib-title{The Definition of Standard
ML}. Cambridge, MA: MIT Press.
}

@bib{
@bib-author{Milner, Robin}, @bib-author{Tofte, Mads},
@bib-author{Harper, Robert}, & @bib-author{MacQueen, David B.}
1997. @bib-title{The Standard ML Programming Language (Revised)}. Cambridge,
MA: MIT Press.
}

@bib{
@bib-author{Moggi, Eugenio}. 1991. Notions of Computation and Monads. @bib-title{Information and
Computation}, @bold{93}(1), 55–92.
}

@bib{
@bib-author{Morris, Jr., James H.} 1968. Lambda Calculus Models of Programming Languages.
Ph.D. thesis, MIT, Cambridge, MA.
}

@bib{
@bib-author{Morris, Jr., James H.}, & @bib-author{Wegbreit, Ben}. 1977. Subgoal Induction. @bib-title{Communications
of the ACM}, @bold{20}, 209–222.
}

@bib{
@bib-author{Naur, Peter}, @emph{et al}. 1963. Revised Report on the Algorithmic Language ALGOL 60.
@bib-title{Communications of the ACM}, @bold{5}(1), 1–17.
}

@bib{
@bib-author{Parnas, David L.} 1972. A Technique for Module Specification with
Examples. @bib-title{Communications of the ACM}, @bold{15}(5), 330–336.
}

@bib{
@bib-author{Paulson, Laurence C.} 1996. @bib-title{ML for the Working Programmer}. Second edition. New
York: Cambridge University Press.
}

@bib{
@bib-author{Peyton Jones, Simon L.} 1987. @bib-title{The Implementation of Functional Programming
Languages}. Englewood Cliffs, NJ: Prentice-Hall International.
}

@bib{
@bib-author{Peyton Jones, Simon L.} 2001.Tackling the Awkward Squad: Monadic Input/Output,
Concurrency, Exceptions, and Foreign-Language Calls in Haskell. In: Hoare,
C.A.R., Broy, Manfred, & Steinbruggen, Ralf (eds.),  @bib-title{Engineering Theories of
Software Construction, Marktoberdorf Summer School}. Amsterdam, The Netherlands:
IOS Press.
}

@bib{
@bib-author{Pierce, Benjamin C.} 2002. @bib-title{Types and Programming Languges}. Cambridge, MA:MIT
Press.
}

@bib{
@bib-author{Pierce, Benjamin C.} 2004. @bib-title{Advanced Topics in Types and Programming
Languges}. Cambridge, MA: MIT Press.
}

@bib{
@bib-author{Plotkin, Gordon D.} 1975. Call-by-Name, Call-by-Value and the
λ-Calculus. @bib-title{Theoretical Computer Science}, @bold{1}, 125–159.
}

@bib{
@bib-author{Plotkin, Gordon D.} 1977. LCF Considered as a Programming Language. @bib-title{Theoretical
Computer Science}, @bold{5}, 223–255.
}

@bib{
@bib-author{Plotkin, Gordon D.} 1981. A Structural Approach to Operational
Semantics. Technical Report FN 19, DAIMI, Department of Computer
Science. University of Aarhus, Aarhus, Denmark.
}

@bib{
@bib-author{Pratt, Terrence W.}, & @bib-author{Zelkowitz, Marvin V.} 2001. @bib-title{Programming Languages: Design
and Implementation}. 4th edition. Englewood Cliffs, NJ: Prentice-Hall.
}

@bib{
@bib-author{Rees, Jonathan A.}, @bib-author{Clinger, William D.}, @emph{et al}. 1986. Revised@superscript{3} Report on the
Algorithmic Language Scheme. @bib-title{SIGPLAN Notices}, @bold{21}(12), 37–79.
}

@bib{
@bib-author{Reynolds, John C.} 1972. Definitional Interpreters for Higher-Order Programming
Languages. Pages 717–740 of: @bib-title{Proceedings ACM National Conference}. Reprinted,
with a foreword, in @bib-title{Higher-Order and Symbolic Computation} @bold{11}(4) 363-397 (1998).
}

@bib{
@bib-author{Reynolds, John C.} 1975. User-Defined Types and Procedural Data Structures as
Complementary Approaches to Data Abstraction. In: @bib-title{Conference on New Directions
on Algorithmic Languages}. IFIPWP 2.1, Munich.
}

@bib{
@bib-author{Reynolds, John C.} 1993. The Discoveries of Continuations. @bib-title{Lisp and Symbolic
Computation}, @bold{6}(3/4), 233–248.
}

@bib{
@bib-author{Sabry, Amr}, & @bib-author{Felleisen, Matthias}. 1992. Reasoning about Programs in
Continuation-Passing Style. Pages 288–298 of: @bib-title{Proceedings 1992 ACM Conf. on
Lisp and Functional Programming}. New York: ACM Press.
}

@bib{
@bib-author{Sabry, Amr}, & @bib-author{Felleisen, Matthias}. 1993. Reasoning about Programs in
Continuation-Passing Style. @bib-title{Lisp and Symbolic Computation}, @bold{6}(3/4), 289–360.
}

@bib{
@bib-author{Sabry, Amr}, & @bib-author{Wadler, Philip}. 1997. A Reflection on Call-by-Value. @bib-title{ACM
Transactions on Programming Languages and Systems}, @bold{19}(6), 916–941.
}

@bib{
@bib-author{Scott, Michael L.} 2005. @bib-title{Programming Language Pragmatics}. Second edition. San
Francisco: Morgan Kaufmann.
}

@bib{
@bib-author{Sebesta, Robert W.} 2007. @bib-title{Concepts of Programming Languages}. 8th edition. Boston:
Addison-Wesley Longman Publishing Co., Inc.
}

@bib{
@bib-author{Smith, Joshua B.} 2006. @bib-title{Practical OCaml}. Berkeley, CA: Apress.
}

@bib{
@bib-author{Sperber, Michael}, @bib-author{Dybvig, R. Kent}, @bib-author{Flatt, Matthew}, & @bib-author{van Straaten, Anton}. 2007.
@bib-title{Revised@superscript{6} Report on the Algorithmic Language Scheme}. @url{www.r6rs.org}.
}

@bib{
@bib-author{Springer, George}, & @bib-author{Friedman, Daniel P.} 1989. @bib-title{Scheme and the Art of Programming}.
New York: McGraw-Hill.
}

@bib{
@bib-author{Steele, Guy L.} 1978. Rabbit: A Compiler for Scheme. Artificial Intelligence
Laboratory Technical Report 474. Massachusetts Institute of Technology,
Cambridge, MA.
}

@bib{
@bib-author{Steele, Guy L.} 1990. @bib-title{Common Lisp: the Language}. Second edition. Burlington, MA:
Digital Press.
}

@bib{
@bib-author{Steele, Guy L.}, & @bib-author{Sussman, Gerald Jay}. 1978. The Revised Report on
SCHEME. Artificial Intelligence Memo 452. Massachusetts Institute of Technology,
Cambridge, MA.
}

@bib{
@bib-author{Stoy, Joseph E.} 1977. @bib-title{Denotational Semantics: The Scott-Strachey Approach to
Programming Language Theory}. Cambridge, MA: MIT Press.
}

@bib{
@bib-author{Strachey, Christopher}. 1967. @bib-title{Fundamental Concepts in Programming
Languages}. Unpublished notes from International Summer School on Programming
Languages, Copenhagen. Reprinted, with a foreword, in Higher-Order and Symbolic
Computation @bold{13}(1–2) 11–49 (2000).
}

@bib{
@bib-author{Strachey, Christopher}, & @bib-author{Wadsworth, Christopher P.} 1974. Continuations: A
Mathematical Semantics for Handling Full Jumps. Technical Monograph
PRG-11. Oxford University Computing Laboratory. Reprinted, with a foreword, in
Higher-Order and Symbolic Computation @bold{13}(1–2) 135–152 (2000).
}

@bib{
@bib-author{Sussman, Gerald Jay}, & @bib-author{Steele, Guy L.} 1975. SCHEME: An Interpreter for Extended
Lambda Calculus. Artificial Intelligence Memo 349. Massachusetts Institute of
Technology, Cambridge, MA. Reprinted, with a foreword, in Higher-Order and
Symbolic Computation @bold{11}(4) 405-439 (1998).
}

@bib{
@bib-author{Thomas, Dave}, @bib-author{Fowler, Chad}, & @bib-author{Hunt, Andy}. 2005. @bib-title{Programming Ruby: The Pragmatic
Programmers’ Guide}. Second edition. Raleigh, NC: The Pragmatic Bookshelf.
}

@bib{
@bib-author[#:key "Turing, Alan" #:index "Turing, Alan"]{Turing, A. M.} 1936. On
Computable Numbers, with an Application to the
Entscheidungsproblem. @bib-title{Proc. London Math. Soc.}, @bold{42}(1),
230–265.
}

@bib{
@bib-author{Ullman, Jeffrey D.} 1998. @bib-title{Elements of ML Programming}. ML97 edition. Englewood
Cliffs, NJ: Prentice-Hall.
}

@bib{
@bib-author{van Rossum, Guido}, & @bib-author[#:key "Drake, Fred" #:index
"Drake, Fred"]{Drake, Fred L. Jr.} 2006. @bib-title{The Python Language
Reference Manual (Version 2.5)}. Bristol, UK: Network Theory Ltd.
}

@bib{
@bib-author{von Neumann, John}. 1945. First Draft of a Report on the EDVAC. Technical Report.
Moore School of Electrical Engineering, University of Pennsylvania.
}

@bib{
@bib-author{Wadler, Philip}. 1992. The Essence of Functional Programming. Pages 1–14 of:
@bib-title{Proceedings ACM Symposium on Principles of Programming Languages}.
}

@bib{
@bib-author{Wall, Larry}, @bib-author{Christiansen, Tom}, & @bib-author{Orwant, Jon}. 2000. @bib-title{Programming Perl}. 3rd
edition. Cambridge, MA: O’Reilly.
}

@bib{
@bib-author{Wand, Mitchell}. 1979. Final Algebra Semantics and Data Type Extensions. @bib-title{Journal
of Computer and Systems Science}, @bold{19}, 27–44.
}

@bib{
@bib-author{Wand, Mitchell}. 1980a. Continuation-Based Multiprocessing. Pages 19–28 of:
Allen, J. (ed.), @bib-title{Conference Record of the 1980 LISP Conference}. Palo Alto, CA:
The Lisp Company. Republished by ACM. Reprinted, with a foreword, in
Higher-Order and Symbolic Computation @bold{12}(3) 285–299 (1999).
}

@bib{
@bib-author{Wand, Mitchell}. 1980b. Continuation-Based Program Transformation
Strategies. @bib-title{Journal of the ACM}, @bold{27}, 164–180.
}

@bib{
@bib-author{Wand, Mitchell}. 1987. A Simple Algorithm and Proof for Type
Inference. @bib-title{Fundamenta Informaticae}, @bold{10}, 115–122.
}

@bib{
@bib-author[#:key "Wexelblatt, R." #:index "Wexelblatt, R."]{Wexelblatt, R. L.}
(ed.). 1978. @bib-title{Special Issue: History of Programming Languages
Conference}. Vol. 13. New York: ACM Press.
}

@bib{
@bib-author{Winskel, Glynn}. 1993. @bib-title{The Formal Semantics of Programming Languages}. Cambridge,
MA: MIT Press.
}

@bib{
@bib-author{Wulf, William}. 1971. BLISS: A Language for Systems Programming. @bib-title{Communications
of the ACM}, @bold{14}(12), 780–790.
}
