#lang scribble/book
@(require "style.rkt")

@title[#:style part-title-style-unnumbered #:tag "bib"]{参考书目}

@bib{
@bib-author{Abadi, Martín}, & @bib-author{Cardelli, Luca}. 1996. @bib-title{A Theory of Objects}. Berlin, Heidelberg,
and New York: Springer-Verlag.
}

@bib{
@bib-author{Abelson, Harold}, & @bib-author{Sussman, Gerald Jay}. 1985. @bib-title{The Structure and Interpretation
of Computer Programs}. Cambridge, MA: MIT Press.
}

@bib{
@bib-author{Abelson, Harold}, & @bib-author{Sussman, Gerald Jay}. 1996. @bib-title{Structure and Interpretation of
Computer Programs}. Second edition. Cambridge, MA: McGraw Hill.
}

@bib{
@bib-author[#:index "Aho, Alfred"]{Aho, Alfred V.}, @bib-author[#:index "Lam, Monica"]{Lam, Monica S.}, @bib-author{Sethi, Ravi}, & @bib-author[#:index "Ullman, Jeffrey"]{Ullman, Jeffrey
D.} 2006. @bib-title{Compilers: Principles, Techniques, and Tools}. Second edition. Boston:
Addison-Wesley Longman.
}

@bib{
@bib-author[#:index "Appel, Andrew"]{Appel, Andrew W.}, & @bib-author{Jim, Trevor}. 1989. @bib-title{Continuation-Passing, Closure-Passing
Style}. Pages 293–302 of: Proceedings ACM Symposium on Principles of Programming
Languages.
}

@bib{
@bib-author{Arnold, Ken}, & @bib-author{Gosling, James}. 1998. @bib-title{The Java Programming Language}. Second
edition. The Java Series. Reading, MA: Addison-Wesley.
}

@bib{
@bib-author{Armstrong, Joe}. 2007. @bib-title{Programming Erlang: Software for a Concurrent World}. The
Pragmatic Programmers Publishers.
}

@bib{
@bib-author[#:index "Backus, John"]{Backus, John W.}, @emph{et al}. 1957. @bib-title{The Fortran Automatic Coding System}. Pages 188–198
of: Western Joint Computer Conference.
}

@bib{
@bib-author[#:index "Barendregt, Henk"]{Barendregt, Henk P.} 1981. @bib-title{The Lambda Calculus: Its Syntax and
Semantics}. Amsterdam: North-Holland.
}

@bib{
@bib-author[#:index "Barendregt, Henk"]{Barendregt, Henk P.} 1991. @bib-title{The Lambda Calculus}. Revised edition. Studies in Logic
and the Foundations of Mathematics, no. 103. Amsterdam: North-Holland.
}

@bib{
@bib-author[#:index "Bergin, Thomas"]{Bergin, Thomas J.}, & @bib-author[#:index "Gibson, Richard"]{Gibson, Richard G.} (eds.). 1996. @bib-title{History of Programming
Languages}. New York: Addison-Wesley.
}

@bib{
@bib-author[#:index "Birtwistle, Graham"]{Birtwistle, Graham M.}, @bib-author{Dahl, Ole-Johan}, & @bib-author{Myhrhaug, Bjorn}. 1973. @bib-title{Simula Begin}.
Philadelphia: Auerbach.
}

@bib{
@bib-author[#:index "Burstall, Rod"]{Burstall, Rod M.} 1969. @bib-title{Proving Properties of Programs by Structural
Induction}. Computer Journal, @bold{12}(1), 41–48.
}

@bib{
@bib-author{Church, Alonzo}. 1941. @bib-title{The Calculi of Lambda Conversion}. Princeton, NJ: Princeton
University Press. Reprinted 1963 by University Microfilms, Ann Arbor, MI.
}

@bib{
@bib-author[#:index "Clinger, William"]{Clinger, William D.}, @emph{et al}. 1985a. The Revised Revised Report on Scheme or The
Uncommon Lisp. Technical Memo AIM-848. Massachusetts Institute of Technology,
Artificial Intelligence Laboratory.
}

@bib{
@bib-author[#:index "Clinger, William"]{Clinger, William D.}, @bib-author[#:index "Friedman, Daniel"]{Friedman, Daniel P.}, & @bib-author{Wand, Mitchell}. 1985b. A Scheme for
a Higher-Level Semantic Algebra. Pages 237–250 of: Reynolds, John, & Nivat,
Maurice (eds.), @bib-title{Algebraic Methods in Semantics: Proceedings of the US-French
Seminar on the Application of Algebra to Language Definition and Compilation
(Fontainebleau, France, June, 1982)}. Cambridge: Cambridge University Press.
}

@bib{
@bib-author[#:index "Clinger, William"]{Clinger, William D.}, @bib-author{Rees, Jonathan}, @emph{et al}. 1991. The Revised@superscript{4} Report on the
Algorithmic Language Scheme. @bib-title{ACM Lisp Pointers}, @bold{4}(3), 1–55.
}

@bib{
@bib-author{Danvy, Olivier}, & @bib-author{Filinski, Andrzej}. 1992. Representing Control: A Study of the
CPS Transformation. @bib-title{Mathematical Structures in Computer Science}, @bold{2}(4), 361–391.
}

@bib{
@bib-author{Danvy, Olivier}, & @bib-author[#:index "Nielsen, Lasse"]{Nielsen, Lasse R.} 2003. A First-order One-pass CPS
Transformation. @bib-title{Theoretical Computer Science}, @bold{308}(1-3), 239–257.
}

@bib{
@bib-author[#:key "Bruijn, N. G." #:index "de Bruijn, N. G."]{de Bruijn, N. G.} 1972. Lambda Calculus Notation with Nameless Dummies: A Tool
for Automatic FormulaManipulation, with Application to the Church-Rosser
Theorem. @bib-title{Indagationes Mathematicae}, @bold{34}, 381–392.
}

@bib{
@bib-author{Dominus, Mark Jason}. 2005. @bib-title{Higher-Order Perl: Transforming Programs with
Programs}. San Francisco: Morgan Kaufmann Publishers.
}

@bib{
@bib-author{Dybvig, R. Kent}. 2003. @bib-title{The Scheme Programming Language}. Third
edition. Cambridge, MA: MIT Press.
}

@bib{
@bib-author{Felleisen, Matthias}, & @bib-author[#:index "Friedman, Daniel"]{Friedman, Daniel P.} 1996. @bib-title{The Little MLer}. Cambridge, MA:
MIT Press.
}

@bib{
@bib-author{Felleisen, Matthias}, @bib-author[#:index "Findler, Robert"]{Findler, Robert Bruce}, @bib-author{Flatt, Matthew}, & @bib-author{Krishnamurthi,
Shriram}. 2001. @bib-title{How to Design Programs}. Cambridge, MA: MIT Press.
}

@bib{
@bib-author[#:index "Fischer, Michael"]{Fischer, Michael J.} 1972. Lambda-Calculus Schemata. Pages 104–109 of:
@bib-title{Proceedings ACM Conference on Proving Assertions about Programs}. Republished in
Lisp and Symbolic Computation, @bold{6}(3/4), 259–288.
}

@bib{
@bib-author{Flanagan, Cormac}, @bib-author{Sabry, Amr}, @bib-author[#:index "Duba, Bruce"]{Duba, Bruce F.}, & @bib-author{Felleisen, Matthias}. 1993. The
Essence of Compiling with Continuations. Pages 237–247 of: @bib-title{Proceedings ACM
SIGPLAN 1993 Conf. on Programming Language Design and Implementation, PLDI’93,
Albuquerque, NM, USA, 23–25 June 1993}, vol. @bold{28}(6). New York: ACM Press.
}

@bib{
@bib-author{Flatt, Matthew}, @bib-author{Krishnamurthi, Shriram}, & @bib-author{Felleisen, Matthias}. 1998. Classes and
Mixins. Pages 171–183 of: @bib-title{Proceedings ACMSymposium on Principles of Programming
Languages}.
}

@bib{
@bib-author[#:index "Friedman, Daniel"]{Friedman, Daniel P.} 1974. @bib-title{The Little LISPer}. Palo Alto, CA: Science Research
Associates.
}

@bib{
@bib-author[#:index "Friedman, Daniel"]{Friedman, Daniel P.}, & @bib-author{Felleisen, Matthias}. 1996. @bib-title{The Little Schemer}. Fourth
edition. Cambridge, MA: MIT Press.
}

@bib{
@bib-author[#:index "Friedman, Daniel"]{Friedman, Daniel P.}, & @bib-author[#:index "Wise, David"]{Wise, David S.} 1976. Cons should not Evaluate its
Arguments. Pages 257–284 of: Michaelson, S., & Milner, R. (eds.), @bib-title{Automata,
Languages and Programming}. Edinburgh: Edinburgh University Press.
}

@bib{
@bib-author{Gamma, Erich}, @bib-author{Helm, Richard}, @bib-author{Johnson, Ralph}, & @bib-author{Vlissides, John}. 1995. @bib-title{Design
Patterns: Bookents of Reusable Object-Oriented Software}. Reading, MA: Addison
Wesley.
}

@bib{
@bib-author{Giarratana, V.}, @bib-author{Gimona, F.}, & @bib-author[#:index "Montanari, Ugo"]{Montanari, U.} 1976. Observability Concepts in
Abstract Data Type Specifications. Pages 576–587 of: Mazurkiewicz, A. (ed.),
@bib-title{Mathematical Foundations of Computer Science 1976}. Lecture Notes in Computer
Science, vol. 45. Berlin, Heidelberg, New York: Springer-Verlag.
}

@bib{
@bib-author[#:index "Goguen, Joseph"]{Goguen, Joseph A.}, @bib-author[#:index "Thatcher, James"]{Thatcher, James W.},
@bib-author[#:index "Wagner, Eric"]{Wagner, Eric G.}, & @bib-author[#:index
"Wright, Jesse"]{Wright, Jesse B.} 1977.  Initial Algebra Semantics and
Continuous Algebras. @bib-title{Journal of the ACM}, @bold{24}, 68–95.  }

@bib{
Goldberg, Adele, & Robson, David. 1983. @bib-title{Smalltalk-80: The Language and Its
Implementation}. Reading, MA: Addison-Wesley.
}

@bib{
Gordon, Andrew D. 1995. A Tutorial on Co-induction and Functional Programming.
Pages 78–95 of: @bib-title{Functional Programming, Glasgow 1994}. Berlin, Heidelberg, and
New York: SpringerWorkshops in Computing.
}

@bib{
Gosling, James, Joy, Bill, & Steele, Guy L. 1996. @bib-title{The Java Language
Specification}. The Java Series. Reading, MA: Addison-Wesley.
}

@bib{
Hailpern, Brent (ed.). 2007. @bib-title{HOPL III: Proceedings of the Third ACM SIGPLAN
Conference on History of Programming Languages}. New York: ACM Press.
}

@bib{
Hankin, Chris. 1994. @bib-title{Lambda Calculi: A Guide for Computer Scientists}. Graduate
Texts in Computer Science, vol. 3. Oxford: Clarendon Press.
}

@bib{
Haynes, Christopher T., Friedman, Daniel P., & Wand, Mitchell. 1986. Obtaining
Coroutines with Continuations. @bib-title{J. of Computer Languages}, @bold{11}(3/4), 143–153.
}

@bib{
Hewitt, Carl. 1977. Viewing Control Structures as Patterns of Passing
Messages. @bib-title{Artificial Intelligence}, @bold{8}, 323–364.
}

@bib{
Hindley, Roger. 1969. The Principal Type-Scheme of an Object in Combinatory
Logic. @bib-title{Transactions of the American Mathematical Society}, @bold{146}, 29–60.
}

@bib{
Hudak, Paul, @emph{et al}. 1990. Report on the Programming Language HASKELL. Technical
Report YALEU/DCS/RR-777. Yale University, CS Dept.
}

@bib{
IEEE. 1991. @bib-title{IEEE Standard for the Scheme Programming Language, IEEE Standard
1178-1990}. IEEE Computer Society, New York.
}

@bib{
Igarashi, Atshushi, Pierce, Benjamin C., & Wadler, Philip. 1999. Featherweight
Java: AMinimal Core Calculus for Java and GJ. Pages 132–146 of: Meissner, Loren
(ed.), @bib-title{Proceedings of the 1999 ACM SIGPLAN Conference on Object-Oriented
Programming, Systems, Languages & Applications (OOPSLA ‘99)}.
}

@bib{
Ingerman, Peter Z. 1961. Thunks, A Way of Compiling Procedure Statements with
Some Comments on Procedure Declarations. @bib-title{Communications of the ACM}, @bold{4}(1), 55–58.
}

@bib{
Jacobs, Bart, & Rutten, Jan. 1997. A Tutorial on (Co)Algebras and (Co)Induction.
@bib-title{Bulletin of the European Association for Theoretical Computer Science}, @bold{62},
222–259.
}

@bib{
Johnston, John B. 1971. The Contour Model of Block Structured Processes. @bib-title{SIGPLAN}
Notices, @bold{6}(2), 55–82.
}

@bib{
Kamin, Samuel. 1980. Final Data Type Specifications: A New Data Type
Specification Method. Pages 131–138 of: @bib-title{Proceedings ACM Symposium on Principles
of Programming Languages}.
}

@bib{
Kelsey, Richard, Clinger, William D., & Rees, Jonathan. 1998. Revised@superscript{5} Report on
the Algorithmic Language Scheme. @bib-title{Higher-Order and Symbolic Computation}, @bold{11}(1),
7–104.
}

@bib{
Kiczales, G., des Rivières, J., & Bobrow, D. G. 1991. @bib-title{The Art of the
Meta-Object Protocol}. Cambridge, MA: MIT Press.
}

@bib{
Knuth, Donald E. 1968. Semantics of Context-Free Languages. @bib-title{Mathematical Systems
Theory}, @bold{2}, 127–145. Correction, 5:95–96, 1971.
}

@bib{
Knuth, Donald E., & Pardo, L. T. 1977. The Early Development of Programming
Languages. Pages 419–493 of: Belzer, J., Holzman, A. G., & Kent, D. (eds.),
@bib-title{Encyclopedia of Computer Science and Technology}, vol. 6. New York: Marcel
Dekker.
}

@bib{
Kranz, David A., Kelsey, Richard, Rees, Jonathan A., Hudak, Paul, Philbin,
James, & Adams, Norman I. 1986. Orbit: An Optimizing Compiler for Scheme. Pages
219–223 of: @bib-title{Proceedings SIGPLAN ’86 Symposium on Compiler Construction}.
}

@bib{
Landin, Peter J. 1965a. Correspondence between ALGOL 60 and Church’s
Lambda-notation: Part I. @bib-title{Commun}. ACM, @bold{8}(2), 89–101.
}

@bib{
Landin, Peter J. 1965b. A Generalization of Jumps and Labels. Technical Report.
UNIVAC Systems Programming Research. Reprinted with a foreword in @bib-title{Higher-Order
and Symbolic Computation}, @bold{11}(2):125–143, 1998.
}

@bib{
Leroy, Xavier. 1994. Manifest Types, Modules, and Separate Compilation. Pages
190–122 of: @bib-title{Proceedings ACM Symposium on Principles of Programming Languages}.
}

@bib{
Lewis, Bil, & Berg, Daniel J. 1998. @bib-title{Multithreaded Programming with
PThreads}. Englewood Cliffs, NJ: Prentice-Hall.
}

@bib{
Liskov, Barbara, Snyder, Alan, Atkinson, R., & Schaffert,
Craig. 1977. Abstraction Mechanisms in CLU. @bib-title{Communications of the ACM}, @bold{20},
564–576.
}

@bib{
McCarthy, John. 1960. Recursive Functions of Symbolic Expressions and their
Computation by Machine, Part I. @bib-title{Communications of the ACM}, @bold{3}, 184–195.
}

@bib{
McCarthy, John. 1962. Towards aMathematical Science of Computation. Pages 21–28
of: Popplewell (ed.), @bib-title{Information Processing 62}. Amsterdam: North-Holland.
}

@bib{
Michie, Donald. 1968. “Memo” Functions and Machine Learning. @bib-title{Nature}, @bold{218}(1–3),
218–219.
}

@bib{
Milne, Robert, & Strachey, Christopher. 1976. @bib-title{A Theory of Programming Language
Semantics}. London: Chapman and Hall.
}

@bib{
Milner, Robin. 1978. A Theory of Type Polymorphism in Programming. @bib-title{Journal of
Computer and Systems Science}, @bold{17}, 348–375.
}

@bib{
Milner, Robin, Tofte, Mads, & Harper, Robert. 1989. @bib-title{The Definition of Standard
ML}. Cambridge, MA: MIT Press.
}

@bib{
Milner, Robin, Tofte, Mads, Harper, Robert, &MacQueen, David B. 1997. @bib-title{The
Standard ML Programming Language (Revised)}. Cambridge, MA: MIT Press.
}

@bib{
Moggi, Eugenio. 1991. Notions of Computation and Monads. @bib-title{Information and
Computation}, @bold{93}(1), 55–92.
}

@bib{
Morris Jr., James H. 1968. Lambda Calculus Models of Programming Languages.
Ph.D. thesis, MIT, Cambridge, MA.
}

@bib{
Morris Jr., James H., & Wegbreit, Ben. 1977. Subgoal Induction. @bib-title{Communications
of the ACM}, @bold{20}, 209–222.
}

@bib{
Naur, Peter, @emph{et al}. 1963. Revised Report on the Algorithmic Language ALGOL 60.
@bib-title{Communications of the ACM}, @bold{5}(1), 1–17.
}

@bib{
Parnas, David L. 1972. A Technique for Module Specification with
Examples. @bib-title{Communications of the ACM}, @bold{15}(5), 330–336.
}

@bib{
Paulson, Laurence C. 1996. @bib-title{ML for the Working Programmer}. Second edition. New
York: Cambridge University Press.
}

@bib{
Peyton Jones, Simon L. 1987. @bib-title{The Implementation of Functional Programming
Languages}. Englewood Cliffs, NJ: Prentice-Hall International.
}

@bib{
Peyton Jones, Simon L. 2001.Tackling the Awkward Squad: Monadic Input/Output,
Concurrency, Exceptions, and Foreign-Language Calls in Haskell. In: Hoare,
C.A.R., Broy, Manfred, & Steinbruggen, Ralf (eds.),  @bib-title{Engineering Theories of
Software Construction, Marktoberdorf Summer School}. Amsterdam, The Netherlands:
IOS Press.
}

@bib{
Pierce, Benjamin C. 2002. @bib-title{Types and Programming Languges}. Cambridge, MA:MIT
Press.
}

@bib{
Pierce, Benjamin C. 2004. @bib-title{Advanced Topics in Types and Programming
Languges}. Cambridge, MA: MIT Press.
}

@bib{
Plotkin, Gordon D. 1975. Call-by-Name, Call-by-Value and the
λ-Calculus. @bib-title{Theoretical Computer Science}, @bold{1}, 125–159.
}

@bib{
Plotkin, Gordon D. 1977. LCF Considered as a Programming Language. @bib-title{Theoretical
Computer Science}, @bold{5}, 223–255.
}

@bib{
Plotkin, Gordon D. 1981. A Structural Approach to Operational
Semantics. Technical Report FN 19, DAIMI, Department of Computer
Science. University of Aarhus, Aarhus, Denmark.
}

@bib{
Pratt, Terrence W., & Zelkowitz, Marvin V. 2001. @bib-title{Programming Languages: Design
and Implementation}. 4th edition. Englewood Cliffs, NJ: Prentice-Hall.
}

@bib{
Rees, Jonathan A., Clinger, WilliamD., @emph{et al}. 1986. Revised@superscript{3} Report on the
Algorithmic Language Scheme. @bib-title{SIGPLAN Notices}, @bold{21}(12), 37–79.
}

@bib{
Reynolds, John C. 1972. Definitional Interpreters for Higher-Order Programming
Languages. Pages 717–740 of: @bib-title{Proceedings ACM National Conference}. Reprinted,
with a foreword, in @bib-title{Higher-Order and Symbolic Computation} @bold{11}(4) 363-397 (1998).
}

@bib{
Reynolds, John C. 1975. User-Defined Types and Procedural Data Structures as
Complementary Approaches to Data Abstraction. In: @bib-title{Conference on New Directions
on Algorithmic Languages}. IFIPWP 2.1, Munich.
}

@bib{
Reynolds, John C. 1993. The Discoveries of Continuations. @bib-title{Lisp and Symbolic
Computation}, @bold{6}(3/4), 233–248.
}

@bib{
Sabry, Amr, & Felleisen, Matthias. 1992. Reasoning about Programs in
Continuation-Passing Style. Pages 288–298 of: @bib-title{Proceedings 1992 ACM Conf. on
Lisp and Functional Programming}. New York: ACM Press.
}

@bib{
Sabry, Amr, & Felleisen, Matthias. 1993. Reasoning about Programs in
Continuation-Passing Style. @bib-title{Lisp and Symbolic Computation}, @bold{6}(3/4), 289–360.
}

@bib{
Sabry, Amr, & Wadler, Philip. 1997. A Reflection on Call-by-Value. @bib-title{ACM
Transactions on Programming Languages and Systems}, @bold{19}(6), 916–941.
}

@bib{
Scott, Michael L. 2005. @bib-title{Programming Language Pragmatics}. Second edition. San
Francisco: Morgan Kaufmann.
}

@bib{
Sebesta, Robert W. 2007. @bib-title{Concepts of Programming Languages}. 8th edition. Boston:
Addison-Wesley Longman Publishing Co., Inc.
}

@bib{
Smith, Joshua B. 2006. @bib-title{Practical OCaml}. Berkeley, CA: Apress.
}

@bib{
Sperber, Michael, Dybvig, R. Kent, Flatt, Matthew, & van Straaten, Anton. 2007.
@bib-title{Revised@superscript{6} Report on the Algorithmic Language Scheme}. @url{www.r6rs.org}.
}

@bib{
Springer, George, & Friedman, Daniel P. 1989. @bib-title{Scheme and the Art of Programming}.
New York: McGraw-Hill.
}

@bib{
Steele, Guy L. 1978. Rabbit: A Compiler for Scheme. Artificial Intelligence
Laboratory Technical Report 474. Massachusetts Institute of Technology,
Cambridge, MA.
}

@bib{
Steele, Guy L. 1990. @bib-title{Common Lisp: the Language}. Second edition. Burlington, MA:
Digital Press.
}

@bib{
Steele, Guy L., & Sussman, Gerald Jay. 1978. The Revised Report on
SCHEME. Artificial Intelligence Memo 452. Massachusetts Institute of Technology,
Cambridge, MA.
}

@bib{
Stoy, Joseph E. 1977. @bib-title{Denotational Semantics: The Scott-Strachey Approach to
Programming Language Theory}. Cambridge, MA: MIT Press.
}

@bib{
Strachey, Christopher. 1967. @bib-title{Fundamental Concepts in Programming
Languages}. Unpublished notes from International Summer School on Programming
Languages, Copenhagen. Reprinted, with a foreword, in Higher-Order and Symbolic
Computation @bold{13}(1–2) 11–49 (2000).
}

@bib{
Strachey, Christopher, & Wadsworth, Christopher P. 1974. Continuations: A
Mathematical Semantics for Handling Full Jumps. Technical Monograph
PRG-11. Oxford University Computing Laboratory. Reprinted, with a foreword, in
Higher-Order and Symbolic Computation @bold{13}(1–2) 135–152 (2000).
}

@bib{
Sussman, Gerald J., & Steele, Guy L. 1975. SCHEME: An Interpreter for Extended
Lambda Calculus. Artificial Intelligence Memo 349. Massachusetts Institute of
Technology, Cambridge, MA. Reprinted, with a foreword, in Higher-Order and
Symbolic Computation @bold{11}(4) 405-439 (1998).
}

@bib{
Thomas, Dave, Fowler, Chad, & Hunt, Andy. 2005. @bib-title{Programming Ruby: The Pragmatic
Programmers’ Guide}. Second edition. Raleigh, NC: The Pragmatic Bookshelf.
}

@bib{
Turing, A. M. 1936. On Computable Numbers, with an Application to the
Entscheidungsproblem. @bib-title{Proc. London Math. Soc.}, @bold{42}(1), 230–265.
}

@bib{
Ullman, Jeffrey D. 1998. @bib-title{Elements of ML Programming}. ML97 edition. Englewood
Cliffs, NJ: Prentice-Hall.
}

@bib{
van Rossum, Guido, & Drake, Fred L. Jr. 2006. @bib-title{The Python Language Reference
Manual (Version 2.5)}. Bristol, UK: Network Theory Ltd.
}

@bib{
von Neumann, John. 1945. First Draft of a Report on the EDVAC. Technical Report.
Moore School of Electrical Engineering, University of Pennsylvania.
}

@bib{
Wadler, Philip. 1992. The Essence of Functional Programming. Pages 1–14 of:
@bib-title{Proceedings ACM Symposium on Principles of Programming Languages}.
}

@bib{
Wall, Larry, Christiansen, Tom, & Orwant, Jon. 2000. @bib-title{Programming Perl}. 3rd
edition. Cambridge, MA: O’Reilly.
}

@bib{
Wand, Mitchell. 1979. Final Algebra Semantics and Data Type Extensions. @bib-title{Journal
of Computer and Systems Science}, @bold{19}, 27–44.
}

@bib{
Wand, Mitchell. 1980a. Continuation-Based Multiprocessing. Pages 19–28 of:
Allen, J. (ed.), @bib-title{Conference Record of the 1980 LISP Conference}. Palo Alto, CA:
The Lisp Company. Republished by ACM. Reprinted, with a foreword, in
Higher-Order and Symbolic Computation @bold{12}(3) 285–299 (1999).
}

@bib{
Wand, Mitchell. 1980b. Continuation-Based Program Transformation
Strategies. @bib-title{Journal of the ACM}, @bold{27}, 164–180.
}

@bib{
Wand, Mitchell. 1987. A Simple Algorithm and Proof for Type
Inference. @bib-title{Fundamenta Informaticae}, @bold{10}, 115–122.
}

@bib{
Wexelblatt, R. L. (ed.). 1978. @bib-title{Special Issue: History of Programming Languages
Conference}. Vol. 13. New York: ACM Press.
}

@bib{
Winskel, Glynn. 1993. @bib-title{The Formal Semantics of Programming Languages}. Cambridge,
MA: MIT Press.
}

@bib{
Wulf, William. 1971. BLISS: A Language for Systems Programming. @bib-title{Communications
of the ACM}, @bold{14}(12), 780–790.
}
