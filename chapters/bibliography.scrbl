#lang scribble/book
@(require "style.rkt")

@title[#:style part-title-style-unnumbered #:tag "bib"]{参考书目}

@bib{
Abadi, Martín, & Cardelli, Luca. 1996. @a-title{A Theory of Objects}. Berlin, Heidelberg,
and New York: Springer-Verlag.
}

@bib{
Abelson, Harold, & Sussman, Gerald Jay. 1985. @a-title{The Structure and Interpretation
of Computer Programs}. Cambridge, MA: MIT Press.
}

@bib{
Abelson, Harold, & Sussman, Gerald Jay. 1996. @a-title{Structure and Interpretation of
Computer Programs}. Second edition. Cambridge, MA: McGraw Hill.
}

@bib{
Aho, Alfred V., Lam, Monica S., Sethi, Ravi, & Ullman, Jeffrey
D. 2006. @a-title{Compilers: Principles, Techniques, and Tools}. Second edition. Boston:
Addison-Wesley Longman.
}

@bib{
Appel, Andrew W., & Jim, Trevor. 1989. @a-title{Continuation-Passing, Closure-Passing
Style}. Pages 293–302 of: Proceedings ACM Symposium on Principles of Programming
Languages.
}

@bib{
Arnold, Ken, & Gosling, James. 1998. @a-title{The Java Programming Language}. Second
edition. The Java Series. Reading, MA: Addison-Wesley.
}

@bib{
Armstrong, Joe. 2007. @a-title{Programming Erlang: Software for a Concurrent World}. The
Pragmatic Programmers Publishers.
}

@bib{
Backus, John W., @emph{et al}. 1957. @a-title{The Fortran Automatic Coding System}. Pages 188–198
of: Western Joint Computer Conference.
}

@bib{
Barendregt, Henk P. 1981. @a-title{The Lambda Calculus: Its Syntax and
Semantics}. Amsterdam: North-Holland.
}

@bib{
Barendregt, Henk P. 1991. @a-title{The Lambda Calculus}. Revised edition. Studies in Logic
and the Foundations of Mathematics, no. 103. Amsterdam: North-Holland.
}

@bib{
Bergin, Thomas J., & Gibson, Richard G. (eds.). 1996. @a-title{History of Programming
Languages}. New York: Addison-Wesley.
}

@bib{
Birtwistle, Graham M., Dahl, Ole-Johan, & Myhrhaug, Bjorn. 1973. @a-title{Simula Begin}.
Philadelphia: Auerbach.
}

@bib{
Burstall, Rod M. 1969. @a-title{Proving Properties of Programs by Structural
Induction}. Computer Journal, @bold{12}(1), 41–48.
}

@bib{
Church, Alonzo. 1941. @a-title{The Calculi of Lambda Conversion}. Princeton, NJ: Princeton
University Press. Reprinted 1963 by University Microfilms, Ann Arbor, MI.
}

@bib{
Clinger, William D., @emph{et al}. 1985a. The Revised Revised Report on Scheme or The
Uncommon Lisp. Technical Memo AIM-848. Massachusetts Institute of Technology,
Artificial Intelligence Laboratory.
}

@bib{
Clinger, William D., Friedman, Daniel P., & Wand, Mitchell. 1985b. A Scheme for
a Higher-Level Semantic Algebra. Pages 237–250 of: Reynolds, John, & Nivat,
Maurice (eds.), @a-title{Algebraic Methods in Semantics: Proceedings of the US-French
Seminar on the Application of Algebra to Language Definition and Compilation
(Fontainebleau, France, June, 1982)}. Cambridge: Cambridge University Press.
}

@bib{
Clinger, William D., Rees, Jonathan, @emph{et al}. 1991. The Revised@superscript{4} Report on the
Algorithmic Language Scheme. @a-title{ACM Lisp Pointers}, @bold{4}(3), 1–55.
}

@bib{
Danvy, Olivier, & Filinski, Andrzej. 1992. Representing Control: A Study of the
CPS Transformation. @a-title{Mathematical Structures in Computer Science}, @bold{2}(4), 361–391.
}

@bib{
Danvy, Olivier, & Nielsen, Lasse R. 2003. A First-order One-pass CPS
Transformation. @a-title{Theoretical Computer Science}, 308(1-3), 239–257.
}

@bib{
de Bruijn, N. G. 1972. Lambda Calculus Notation with Nameless Dummies: A Tool
for Automatic FormulaManipulation, with Application to the Church-Rosser
Theorem. @a-title{Indagationes Mathematicae}, @bold{34}, 381–392.
}

@bib{
Dominus, Mark Jason. 2005. @a-title{Higher-Order Perl: Transforming Programs with
Programs}. San Francisco: Morgan Kaufmann Publishers.
}

@bib{
Dybvig, R. Kent. 2003. @a-title{The Scheme Programming Language}. Third
edition. Cambridge, MA: MIT Press.
}

@bib{
Felleisen, Matthias, & Friedman, Daniel P. 1996. @a-title{The Little MLer}. Cambridge, MA:
MIT Press.
}

@bib{
Felleisen, Matthias, Findler, Robert Bruce, Flatt, Matthew, & Krishnamurthi,
Shriram. 2001. @a-title{How to Design Programs}. Cambridge, MA: MIT Press.
}

@bib{
Fischer, Michael J. 1972. Lambda-Calculus Schemata. Pages 104–109 of:
@a-title{Proceedings ACM Conference on Proving Assertions about Programs}. Republished in
Lisp and Symbolic Computation, @bold{6}(3/4), 259–288.
}

@bib{
Flanagan, Cormac, Sabry, Amr, Duba, Bruce F., & Felleisen, Matthias. 1993. The
Essence of Compiling with Continuations. Pages 237–247 of: @a-title{Proceedings ACM
SIGPLAN 1993 Conf. on Programming Language Design and Implementation, PLDI’93,
Albuquerque, NM, USA, 23–25 June 1993}, vol. @bold{28}(6). New York: ACM Press.
}

@bib{
Flatt, Matthew, Krishnamurthi, Shriram, & Felleisen, Matthias. 1998. Classes and
Mixins. Pages 171–183 of: @a-title{Proceedings ACMSymposium on Principles of Programming
Languages}.
}

@bib{
Friedman, Daniel P. 1974. @a-title{The Little LISPer}. Palo Alto, CA: Science Research
Associates.
}

@bib{
Friedman, Daniel P., & Felleisen, Matthias. 1996. @a-title{The Little Schemer}. Fourth
edition. Cambridge, MA: MIT Press.
}

@bib{
Friedman, Daniel P., &Wise, David S. 1976. Cons should not Evaluate its
Arguments. Pages 257–284 of: Michaelson, S., & Milner, R. (eds.), @a-title{Automata,
Languages and Programming}. Edinburgh: Edinburgh University Press.
}

@bib{
Gamma, Erich, Helm, Richard, Johnson, Ralph, & Vlissides, John. 1995. @a-title{Design
Patterns: Bookents of Reusable Object-Oriented Software}. Reading, MA: Addison
Wesley.
}

@bib{
Giarratana, V., Gimona, F., & Montanari, U. 1976. Observability Concepts in
Abstract Data Type Specifications. Pages 576–587 of: Mazurkiewicz, A. (ed.),
@a-title{Mathematical Foundations of Computer Science 1976}. Lecture Notes in Computer
Science, vol. 45. Berlin, Heidelberg, New York: Springer-Verlag.
}

@bib{
Goguen, Joseph A., Thatcher, James W., Wagner, Eric G., & Wright, Jesse B. 1977.
Initial Algebra Semantics and Continuous Algebras. @a-title{Journal of the ACM}, @bold{24},
68–95.
}

@bib{
Goldberg, Adele, & Robson, David. 1983. @a-title{Smalltalk-80: The Language and Its
Implementation}. Reading, MA: Addison-Wesley.
}

@bib{
Gordon, Andrew D. 1995. A Tutorial on Co-induction and Functional Programming.
Pages 78–95 of: @a-title{Functional Programming, Glasgow 1994}. Berlin, Heidelberg, and
New York: SpringerWorkshops in Computing.
}

@bib{
Gosling, James, Joy, Bill, & Steele, Guy L. 1996. @a-title{The Java Language
Specification}. The Java Series. Reading, MA: Addison-Wesley.
}

@bib{
Hailpern, Brent (ed.). 2007. @a-title{HOPL III: Proceedings of the Third ACM SIGPLAN
Conference on History of Programming Languages}. New York: ACM Press.
}

@bib{
Hankin, Chris. 1994. @a-title{Lambda Calculi: A Guide for Computer Scientists}. Graduate
Texts in Computer Science, vol. 3. Oxford: Clarendon Press.
}

@bib{
Haynes, Christopher T., Friedman, Daniel P., & Wand, Mitchell. 1986. Obtaining
Coroutines with Continuations. @a-title{J. of Computer Languages}, @bold{11}(3/4), 143–153.
}

@bib{
Hewitt, Carl. 1977. Viewing Control Structures as Patterns of Passing
Messages. @a-title{Artificial Intelligence}, @bold{8}, 323–364.
}

@bib{
Hindley, Roger. 1969. The Principal Type-Scheme of an Object in Combinatory
Logic. @a-title{Transactions of the American Mathematical Society}, @bold{146}, 29–60.
}

@bib{
Hudak, Paul, @emph{et al}. 1990. Report on the Programming Language HASKELL. Technical
Report YALEU/DCS/RR-777. Yale University, CS Dept.
}

@bib{
IEEE. 1991. @a-title{IEEE Standard for the Scheme Programming Language, IEEE Standard
1178-1990}. IEEE Computer Society, New York.
}

@bib{
Igarashi, Atshushi, Pierce, Benjamin C., & Wadler, Philip. 1999. Featherweight
Java: AMinimal Core Calculus for Java and GJ. Pages 132–146 of: Meissner, Loren
(ed.), @a-title{Proceedings of the 1999 ACM SIGPLAN Conference on Object-Oriented
Programming, Systems, Languages & Applications (OOPSLA ‘99)}.
}

@bib{
Ingerman, Peter Z. 1961. Thunks, A Way of Compiling Procedure Statements with
Some Comments on Procedure Declarations. @a-title{Communications of the ACM}, @bold{4}(1), 55–58.
}

@bib{
Jacobs, Bart, & Rutten, Jan. 1997. A Tutorial on (Co)Algebras and (Co)Induction.
@a-title{Bulletin of the European Association for Theoretical Computer Science}, @bold{62},
222–259.
}

@bib{
Johnston, John B. 1971. The Contour Model of Block Structured Processes. @a-title{SIGPLAN}
Notices, @bold{6}(2), 55–82.
}

@bib{
Kamin, Samuel. 1980. Final Data Type Specifications: A New Data Type
Specification Method. Pages 131–138 of: @a-title{Proceedings ACM Symposium on Principles
of Programming Languages}.
}

@bib{
Kelsey, Richard, Clinger, William D., & Rees, Jonathan. 1998. Revised@superscript{5} Report on
the Algorithmic Language Scheme. @a-title{Higher-Order and Symbolic Computation}, @bold{11}(1),
7–104.
}

@bib{
Kiczales, G., des Rivières, J., & Bobrow, D. G. 1991. @a-title{The Art of the
Meta-Object Protocol}. Cambridge, MA: MIT Press.
}

@bib{
Knuth, Donald E. 1968. Semantics of Context-Free Languages. @a-title{Mathematical Systems
Theory}, @bold{2}, 127–145. Correction, 5:95–96, 1971.
}

@bib{
Knuth, Donald E., & Pardo, L. T. 1977. The Early Development of Programming
Languages. Pages 419–493 of: Belzer, J., Holzman, A. G., & Kent, D. (eds.),
@a-title{Encyclopedia of Computer Science and Technology}, vol. 6. New York: Marcel
Dekker.
}

@bib{
Kranz, David A., Kelsey, Richard, Rees, Jonathan A., Hudak, Paul, Philbin,
James, & Adams, Norman I. 1986. Orbit: An Optimizing Compiler for Scheme. Pages
219–223 of: @a-title{Proceedings SIGPLAN ’86 Symposium on Compiler Construction}.
}

@bib{
Landin, Peter J. 1965a. Correspondence between ALGOL 60 and Church’s
Lambda-notation: Part I. @a-title{Commun}. ACM, @bold{8}(2), 89–101.
}

@bib{
Landin, Peter J. 1965b. A Generalization of Jumps and Labels. Technical Report.
UNIVAC Systems Programming Research. Reprinted with a foreword in @a-title{Higher-Order
and Symbolic Computation}, @bold{11}(2):125–143, 1998.
}

@bib{
Leroy, Xavier. 1994. Manifest Types, Modules, and Separate Compilation. Pages
190–122 of: @a-title{Proceedings ACM Symposium on Principles of Programming Languages}.
}

@bib{
Lewis, Bil, & Berg, Daniel J. 1998. @a-title{Multithreaded Programming with
PThreads}. Englewood Cliffs, NJ: Prentice-Hall.
}

@bib{
Liskov, Barbara, Snyder, Alan, Atkinson, R., & Schaffert,
Craig. 1977. Abstraction Mechanisms in CLU. @a-title{Communications of the ACM}, @bold{20},
564–576.
}

@bib{
McCarthy, John. 1960. Recursive Functions of Symbolic Expressions and their
Computation by Machine, Part I. @a-title{Communications of the ACM}, @bold{3}, 184–195.
}

@bib{
McCarthy, John. 1962. Towards aMathematical Science of Computation. Pages 21–28
of: Popplewell (ed.), @a-title{Information Processing 62}. Amsterdam: North-Holland.
}

@bib{
Michie, Donald. 1968. “Memo” Functions and Machine Learning. @a-title{Nature}, 218(1–3),
218–219.
}

@bib{
Milne, Robert, & Strachey, Christopher. 1976. @a-title{A Theory of Programming Language
Semantics}. London: Chapman and Hall.
}

@bib{
Milner, Robin. 1978. A Theory of Type Polymorphism in Programming. @a-title{Journal of
Computer and Systems Science}, @bold{17}, 348–375.
}

@bib{
Milner, Robin, Tofte, Mads, & Harper, Robert. 1989. @a-title{The Definition of Standard
ML}. Cambridge, MA: MIT Press.
}

@bib{
Milner, Robin, Tofte, Mads, Harper, Robert, &MacQueen, David B. 1997. @a-title{The
Standard ML Programming Language (Revised)}. Cambridge, MA: MIT Press.
}

@bib{
Moggi, Eugenio. 1991. Notions of Computation and Monads. @a-title{Information and
Computation}, @bold{93}(1), 55–92.
}

@bib{
Morris Jr., James H. 1968. Lambda Calculus Models of Programming Languages.
Ph.D. thesis, MIT, Cambridge, MA.
}

@bib{
Morris Jr., James H., & Wegbreit, Ben. 1977. Subgoal Induction. @a-title{Communications
of the ACM}, @bold{20}, 209–222.
}

@bib{
Naur, Peter, @emph{et al}. 1963. Revised Report on the Algorithmic Language ALGOL 60.
@a-title{Communications of the ACM}, @bold{5}(1), 1–17.
}

@bib{
Parnas, David L. 1972. A Technique for Module Specification with
Examples. @a-title{Communications of the ACM}, @bold{15}(5), 330–336.
}

@bib{
Paulson, Laurence C. 1996. @a-title{ML for the Working Programmer}. Second edition. New
York: Cambridge University Press.
}

@bib{
Peyton Jones, Simon L. 1987. @a-title{The Implementation of Functional Programming
Languages}. Englewood Cliffs, NJ: Prentice-Hall International.
}

@bib{
Peyton Jones, Simon L. 2001.Tackling the Awkward Squad: Monadic Input/Output,
Concurrency, Exceptions, and Foreign-Language Calls in Haskell. In: Hoare,
C.A.R., Broy, Manfred, & Steinbruggen, Ralf (eds.),  @a-title{Engineering Theories of
Software Construction, Marktoberdorf Summer School}. Amsterdam, The Netherlands:
IOS Press.
}

@bib{
Pierce, Benjamin C. 2002. @a-title{Types and Programming Languges}. Cambridge, MA:MIT
Press.
}

@bib{
Pierce, Benjamin C. 2004. @a-title{Advanced Topics in Types and Programming
Languges}. Cambridge, MA: MIT Press.
}

@bib{
Plotkin, Gordon D. 1975. Call-by-Name, Call-by-Value and the
λ-Calculus. @a-title{Theoretical Computer Science}, @bold{1}, 125–159.
}

@bib{
Plotkin, Gordon D. 1977. LCF Considered as a Programming Language. @a-title{Theoretical
Computer Science}, @bold{5}, 223–255.
}

@bib{
Plotkin, Gordon D. 1981. A Structural Approach to Operational
Semantics. Technical Report FN 19, DAIMI, Department of Computer
Science. University of Aarhus, Aarhus, Denmark.
}

@bib{
Pratt, Terrence W., & Zelkowitz, Marvin V. 2001. @a-title{Programming Languages: Design
and Implementation}. 4th edition. Englewood Cliffs, NJ: Prentice-Hall.
}

@bib{
Rees, Jonathan A., Clinger, WilliamD., @emph{et al}. 1986. Revised@superscript{3} Report on the
Algorithmic Language Scheme. @a-title{SIGPLAN Notices}, @bold{21}(12), 37–79.
}

@bib{
Reynolds, John C. 1972. Definitional Interpreters for Higher-Order Programming
Languages. Pages 717–740 of: @a-title{Proceedings ACM National Conference}. Reprinted,
with a foreword, in @a-title{Higher-Order and Symbolic Computation} @bold{11}(4) 363-397 (1998).
}

@bib{
Reynolds, John C. 1975. User-Defined Types and Procedural Data Structures as
Complementary Approaches to Data Abstraction. In: @a-title{Conference on New Directions
on Algorithmic Languages}. IFIPWP 2.1, Munich.
}

@bib{
Reynolds, John C. 1993. The Discoveries of Continuations. @a-title{Lisp and Symbolic
Computation}, @bold{6}(3/4), 233–248.
}

@bib{
Sabry, Amr, & Felleisen, Matthias. 1992. Reasoning about Programs in
Continuation-Passing Style. Pages 288–298 of: @a-title{Proceedings 1992 ACM Conf. on
Lisp and Functional Programming}. New York: ACM Press.
}

@bib{
Sabry, Amr, & Felleisen, Matthias. 1993. Reasoning about Programs in
Continuation-Passing Style. @a-title{Lisp and Symbolic Computation}, @bold{6}(3/4), 289–360.
}

@bib{
Sabry, Amr, & Wadler, Philip. 1997. A Reflection on Call-by-Value. @a-title{ACM
Transactions on Programming Languages and Systems}, @bold{19}(6), 916–941.
}

@bib{
Scott, Michael L. 2005. @a-title{Programming Language Pragmatics}. Second edition. San
Francisco: Morgan Kaufmann.
}

@bib{
Sebesta, Robert W. 2007. @a-title{Concepts of Programming Languages}. 8th edition. Boston:
Addison-Wesley Longman Publishing Co., Inc.
}

@bib{
Smith, Joshua B. 2006. @a-title{Practical OCaml}. Berkeley, CA: Apress.
}

@bib{
Sperber, Michael, Dybvig, R. Kent, Flatt, Matthew, & van Straaten, Anton. 2007.
@a-title{Revised@superscript{6} Report on the Algorithmic Language Scheme}. @url{www.r6rs.org}.
}

@bib{
Springer, George, & Friedman, Daniel P. 1989. @a-title{Scheme and the Art of Programming}.
New York: McGraw-Hill.
}

@bib{
Steele, Guy L. 1978. Rabbit: A Compiler for Scheme. Artificial Intelligence
Laboratory Technical Report 474. Massachusetts Institute of Technology,
Cambridge, MA.
}

@bib{
Steele, Guy L. 1990. @a-title{Common Lisp: the Language}. Second edition. Burlington, MA:
Digital Press.
}

@bib{
Steele, Guy L., & Sussman, Gerald Jay. 1978. The Revised Report on
SCHEME. Artificial Intelligence Memo 452. Massachusetts Institute of Technology,
Cambridge, MA.
}

@bib{
Stoy, Joseph E. 1977. @a-title{Denotational Semantics: The Scott-Strachey Approach to
Programming Language Theory}. Cambridge, MA: MIT Press.
}

@bib{
Strachey, Christopher. 1967. @a-title{Fundamental Concepts in Programming
Languages}. Unpublished notes from International Summer School on Programming
Languages, Copenhagen. Reprinted, with a foreword, in Higher-Order and Symbolic
Computation @bold{13}(1–2) 11–49 (2000).
}

@bib{
Strachey, Christopher, & Wadsworth, Christopher P. 1974. Continuations: A
Mathematical Semantics for Handling Full Jumps. Technical Monograph
PRG-11. Oxford University Computing Laboratory. Reprinted, with a foreword, in
Higher-Order and Symbolic Computation @bold{13}(1–2) 135–152 (2000).
}

@bib{
Sussman, Gerald J., & Steele, Guy L. 1975. SCHEME: An Interpreter for Extended
Lambda Calculus. Artificial Intelligence Memo 349. Massachusetts Institute of
Technology, Cambridge, MA. Reprinted, with a foreword, in Higher-Order and
Symbolic Computation @bold{11}(4) 405-439 (1998).
}

@bib{
Thomas, Dave, Fowler, Chad, & Hunt, Andy. 2005. @a-title{Programming Ruby: The Pragmatic
Programmers’ Guide}. Second edition. Raleigh, NC: The Pragmatic Bookshelf.
}

@bib{
Turing, A. M. 1936. On Computable Numbers, with an Application to the
Entscheidungsproblem. @a-title{Proc. London Math. Soc.}, @bold{42}(1), 230–265.
}

@bib{
Ullman, Jeffrey D. 1998. @a-title{Elements of ML Programming}. ML97 edition. Englewood
Cliffs, NJ: Prentice-Hall.
}

@bib{
van Rossum, Guido, & Drake, Fred L. Jr. 2006. @a-title{The Python Language Reference
Manual (Version 2.5)}. Bristol, UK: Network Theory Ltd.
}

@bib{
von Neumann, John. 1945. First Draft of a Report on the EDVAC. Technical Report.
Moore School of Electrical Engineering, University of Pennsylvania.
}

@bib{
Wadler, Philip. 1992. The Essence of Functional Programming. Pages 1–14 of:
@a-title{Proceedings ACM Symposium on Principles of Programming Languages}.
}

@bib{
Wall, Larry, Christiansen, Tom, & Orwant, Jon. 2000. @a-title{Programming Perl}. 3rd
edition. Cambridge, MA: O’Reilly.
}

@bib{
Wand, Mitchell. 1979. Final Algebra Semantics and Data Type Extensions. @a-title{Journal
of Computer and Systems Science}, @bold{19}, 27–44.
}

@bib{
Wand, Mitchell. 1980a. Continuation-Based Multiprocessing. Pages 19–28 of:
Allen, J. (ed.), @a-title{Conference Record of the 1980 LISP Conference}. Palo Alto, CA:
The Lisp Company. Republished by ACM. Reprinted, with a foreword, in
Higher-Order and Symbolic Computation @bold{12}(3) 285–299 (1999).
}

@bib{
Wand, Mitchell. 1980b. Continuation-Based Program Transformation
Strategies. @a-title{Journal of the ACM}, @bold{27}, 164–180.
}

@bib{
Wand, Mitchell. 1987. A Simple Algorithm and Proof for Type
Inference. @a-title{Fundamenta Informaticae}, @bold{10}, 115–122.
}

@bib{
Wexelblatt, R. L. (ed.). 1978. @a-title{Special Issue: History of Programming Languages
Conference}. Vol. 13. New York: ACM Press.
}

@bib{
Winskel, Glynn. 1993. @a-title{The Formal Semantics of Programming Languages}. Cambridge,
MA: MIT Press.
}

@bib{
Wulf, William. 1971. BLISS: A Language for Systems Programming. @a-title{Communications
of the ACM}, @bold{14}(12), 780–790.
}
