<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>译名表</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="style" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{…}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
</script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,"tocview_0");">▼</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">编程语言要素</a></td></tr></table></div><div class="tocviewsublistonly" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="fw-trans.html" class="tocviewlink" data-pltdoc="x">译者的话</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">译名表</a></td></tr><tr><td align="right"></td><td><a href="fw.html" class="tocviewlink" data-pltdoc="x">序</a></td></tr><tr><td align="right"></td><td><a href="pf.html" class="tocviewlink" data-pltdoc="x">前言</a></td></tr><tr><td align="right"></td><td><a href="awk.html" class="tocviewlink" data-pltdoc="x">致谢</a></td></tr><tr><td align="right">1 </td><td><a href="isd.html" class="tocviewlink" data-pltdoc="x">归纳式数据集</a></td></tr><tr><td align="right">2 </td><td><a href="da.html" class="tocviewlink" data-pltdoc="x">数据抽象</a></td></tr><tr><td align="right">3 </td><td><a href="expr.html" class="tocviewlink" data-pltdoc="x">表达式</a></td></tr><tr><td align="right">4 </td><td><a href="state.html" class="tocviewlink" data-pltdoc="x">状态</a></td></tr><tr><td align="right">5 </td><td><a href="cpi.html" class="tocviewlink" data-pltdoc="x">传递续文的解释器</a></td></tr><tr><td align="right">6 </td><td><a href="cps.html" class="tocviewlink" data-pltdoc="x">续文传递风格</a></td></tr><tr><td align="right">7 </td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">类型</a></td></tr><tr><td align="right">8 </td><td><a href="modules.html" class="tocviewlink" data-pltdoc="x">模块</a></td></tr><tr><td align="right">9 </td><td><a href="oac.html" class="tocviewlink" data-pltdoc="x">对象和类</a></td></tr><tr><td align="right">10 </td><td><a href="further-reading.html" class="tocviewlink" data-pltdoc="x">扩展阅读</a></td></tr><tr><td align="right">11 </td><td><a href="sllgen-parsing-system.html" class="tocviewlink" data-pltdoc="x">SLLGEN解析系统</a></td></tr><tr><td align="right"></td><td><a href="bib.html" class="tocviewlink" data-pltdoc="x">参考书目</a></td></tr><tr><td align="right"></td><td><a href="indices.html" class="tocviewlink" data-pltdoc="x">索引</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">  <a href="fw-trans.html" title="backward to "译者的话"" data-pltdoc="x">← prev</a>  <a href="index.html" title="up to "编程语言要素"" data-pltdoc="x">up</a>  <a href="fw.html" title="forward to "序"" data-pltdoc="x">next →</a></span> </div><h3><a name="(part._glo)"></a>译名表</h3><p>下表列出本书专有名词及其翻译，并对有疑义者略加说明。</p><p><table cellspacing="0" cellpadding="0" class="Small"><tr><td valign="baseline"><p><div class="SIntrapara"></div></p></td><td valign="baseline"><p><div class="SIntrapara"></div></p></td></tr><tr><td valign="baseline"><p>Abstract data type (ADT)</p></td><td valign="baseline"><p>抽象数据类型</p></td></tr><tr><td valign="baseline"><p>Abstract syntax tree</p></td><td valign="baseline"><p>抽象语法树</p></td></tr><tr><td valign="baseline"><p>Abstract syntax</p></td><td valign="baseline"><p>抽象语法</p></td></tr><tr><td valign="baseline"><p>Abstract type</p></td><td valign="baseline"><p>抽象类型</p></td></tr><tr><td valign="baseline"><p>Abstraction boundary</p></td><td valign="baseline"><p>抽象边界</p></td></tr><tr><td valign="baseline"><p>Activation record</p></td><td valign="baseline"><p>活跃记录表</p></td></tr><tr><td valign="baseline"><p>Actual parameter</p></td><td valign="baseline"><p><div class="SIntrapara">实际参数，简称实参
（<span class="emph">同 argument</span>）</div></p></td></tr><tr><td valign="baseline"><p>Advertise</p></td><td valign="baseline"><p>公布</p></td></tr><tr><td valign="baseline"><p>Alternation</p></td><td valign="baseline"><p>并联</p></td></tr><tr><td valign="baseline"><p>Analyzer</p></td><td valign="baseline"><p>分析器</p></td></tr><tr><td valign="baseline"><p>Ancestor</p></td><td valign="baseline"><p>祖先</p></td></tr><tr><td valign="baseline"><p>Antecedent</p></td><td valign="baseline"><p>前件</p></td></tr><tr><td valign="baseline"><p>Application expression</p></td><td valign="baseline"><p>调用表达式</p></td></tr><tr><td valign="baseline"><p>Apply</p></td><td valign="baseline"><p>应用</p></td></tr><tr><td valign="baseline"><p>Argument</p></td><td valign="baseline"><p><div class="SIntrapara">实参（<span class="emph">文中有时也用这一术语泛
指参数</span>）</div></p></td></tr><tr><td valign="baseline"><p>Association-list</p></td><td valign="baseline"><p>关联列表</p></td></tr><tr><td valign="baseline"><p>Axiom</p></td><td valign="baseline"><p>公理</p></td></tr><tr><td valign="baseline"><p>Backus-Naur Form</p></td><td valign="baseline"><p>巴科斯-诺尔范式</p></td></tr><tr><td valign="baseline"><p><span class="texMathInline">\beta</span>-reduction</p></td><td valign="baseline"><p><span class="texMathInline">\beta</span>-推导</p></td></tr><tr><td valign="baseline"><p>Bigits</p></td><td valign="baseline"><p>大位</p></td></tr><tr><td valign="baseline"><p>Bignum representation</p></td><td valign="baseline"><p>大数表示法</p></td></tr><tr><td valign="baseline"><p>Binary method problem</p></td><td valign="baseline"><p>二元方法问题</p></td></tr><tr><td valign="baseline"><p>Binary semaphore</p></td><td valign="baseline"><p>二元信号量</p></td></tr><tr><td valign="baseline"><p>Binding</p></td><td valign="baseline"><p>绑定</p></td></tr><tr><td valign="baseline"><p>Blocked</p></td><td valign="baseline"><p>受阻塞</p></td></tr><tr><td valign="baseline"><p>Body</p></td><td valign="baseline"><p><div class="SIntrapara">主体（<span class="emph">一般指某种语法结构
（<span class="stt">let</span>定义、过程定义、类方法定义，甚至整个程序）之中，变量声明包裹起来的、执
行期望动作的部分</span>）</div></p></td></tr><tr><td valign="baseline"><p>Bottom-up</p></td><td valign="baseline"><p>自底向上</p></td></tr><tr><td valign="baseline"><p>Bounce</p></td><td valign="baseline"><p><div class="SIntrapara">弹球（<span class="emph">参见 trampoline</span>）</div></p></td></tr><tr><td valign="baseline"><p>Bound variable</p></td><td valign="baseline"><p>绑定变量</p></td></tr><tr><td valign="baseline"><p>Bound</p></td><td valign="baseline"><p>绑定</p></td></tr><tr><td valign="baseline"><p>Byte code</p></td><td valign="baseline"><p>字节码</p></td></tr><tr><td valign="baseline"><p>Call by name</p></td><td valign="baseline"><p>按名调用</p></td></tr><tr><td valign="baseline"><p>Call by need</p></td><td valign="baseline"><p>按需调用</p></td></tr><tr><td valign="baseline"><p>Call by reference</p></td><td valign="baseline"><p>按指调用</p></td></tr><tr><td valign="baseline"><p>Call by value result</p></td><td valign="baseline"><p>按值和结果调用</p></td></tr><tr><td valign="baseline"><p>Call by value</p></td><td valign="baseline"><p>按值调用</p></td></tr><tr><td valign="baseline"><p>car</p></td><td valign="baseline"><p>首项，或不译</p></td></tr><tr><td valign="baseline"><p>Casting</p></td><td valign="baseline"><p>强制转换</p></td></tr><tr><td valign="baseline"><p>cdr</p></td><td valign="baseline"><p>余项，或不译</p></td></tr><tr><td valign="baseline"><p>Child</p></td><td valign="baseline"><p>子类</p></td></tr><tr><td valign="baseline"><p>Class environment</p></td><td valign="baseline"><p>类环境</p></td></tr><tr><td valign="baseline"><p>Class</p></td><td valign="baseline"><p><div class="SIntrapara">类，或类别（<span class="emph">在<a href="oac.html" data-pltdoc="x">对象和类</a>，class 特指
面向对象语言中的类；在<a href="sllgen-parsing-system.html#%28elem._sllgen%29" data-pltdoc="x">附录 B</a>，class 指词牌的种类。</span>）</div></p></td></tr><tr><td valign="baseline"><p>Client</p></td><td valign="baseline"><p>客户</p></td></tr><tr><td valign="baseline"><p>Closed over, closed in</p></td><td valign="baseline"><p>闭合于</p></td></tr><tr><td valign="baseline"><p>Closure</p></td><td valign="baseline"><p>闭包</p></td></tr><tr><td valign="baseline"><p>Coinduction</p></td><td valign="baseline"><p>余归纳</p></td></tr><tr><td valign="baseline"><p>Concatenation</p></td><td valign="baseline"><p>串联</p></td></tr><tr><td valign="baseline"><p>Conclusion</p></td><td valign="baseline"><p>结论</p></td></tr><tr><td valign="baseline"><p>Concrete syntax</p></td><td valign="baseline"><p>具体语法</p></td></tr><tr><td valign="baseline"><p>Concrete type</p></td><td valign="baseline"><p>具体类型</p></td></tr><tr><td valign="baseline"><p>Consequent</p></td><td valign="baseline"><p>后件</p></td></tr><tr><td valign="baseline"><p>Constructor</p></td><td valign="baseline"><p>构造器</p></td></tr><tr><td valign="baseline"><p>Context</p></td><td valign="baseline"><p>上下文</p></td></tr><tr><td valign="baseline"><p>Continuation-passing style</p></td><td valign="baseline"><p>续文传递风格</p></td></tr><tr><td valign="baseline"><p>Continuation</p></td><td valign="baseline"><p><div class="SIntrapara">续文（<span class="emph">这一术语或译作
“继续”，或译作“续延”，或译作“（计算）
续体”；这里译作“续文”，是将程序类比为文章，那么作为程序中任意位
置后续内容的抽象，continuation即为“续文”</span>）</div></p></td></tr><tr><td valign="baseline"><p>Contour diagram</p></td><td valign="baseline"><p>等深线</p></td></tr><tr><td valign="baseline"><p>Contract</p></td><td valign="baseline"><p>合约</p></td></tr><tr><td valign="baseline"><p>Contravariant</p></td><td valign="baseline"><p>逆变的</p></td></tr><tr><td valign="baseline"><p>Control context</p></td><td valign="baseline"><p>控制上下文</p></td></tr><tr><td valign="baseline"><p>Coroutine</p></td><td valign="baseline"><p>协程</p></td></tr><tr><td valign="baseline"><p>Covariant</p></td><td valign="baseline"><p>协变的</p></td></tr><tr><td valign="baseline"><p>Critical region</p></td><td valign="baseline"><p>关键区域</p></td></tr><tr><td valign="baseline"><p>Curried</p></td><td valign="baseline"><p>咖喱式</p></td></tr><tr><td valign="baseline"><p>Currying</p></td><td valign="baseline"><p>咖哩化</p></td></tr><tr><td valign="baseline"><p>Data abstraction</p></td><td valign="baseline"><p>数据抽象</p></td></tr><tr><td valign="baseline"><p>De Bruijn index</p></td><td valign="baseline"><p>德布鲁金索引</p></td></tr><tr><td valign="baseline"><p>Declaration</p></td><td valign="baseline"><p>声明</p></td></tr><tr><td valign="baseline"><p>Deduction tree</p></td><td valign="baseline"><p>推理树</p></td></tr><tr><td valign="baseline"><p>Deference</p></td><td valign="baseline"><p>解引用</p></td></tr><tr><td valign="baseline"><p>Defined language</p></td><td valign="baseline"><p>被定语言</p></td></tr><tr><td valign="baseline"><p>Defining language</p></td><td valign="baseline"><p>定义语言</p></td></tr><tr><td valign="baseline"><p>Defunctionalization</p></td><td valign="baseline"><p>消函</p></td></tr><tr><td valign="baseline"><p>Delegate</p></td><td valign="baseline"><p>委托</p></td></tr><tr><td valign="baseline"><p>Denoted value</p></td><td valign="baseline"><p>指代值</p></td></tr><tr><td valign="baseline"><p>Derivation</p></td><td valign="baseline"><p>推导</p></td></tr><tr><td valign="baseline"><p>Descendant</p></td><td valign="baseline"><p>后代</p></td></tr><tr><td valign="baseline"><p>Domain equation</p></td><td valign="baseline"><p>定义域方程</p></td></tr><tr><td valign="baseline"><p>Domain-specific language</p></td><td valign="baseline"><p>特定领域语言</p></td></tr><tr><td valign="baseline"><p>Double dispatch</p></td><td valign="baseline"><p>双派发</p></td></tr><tr><td valign="baseline"><p>Dynamic assignment</p></td><td valign="baseline"><p>动态赋值</p></td></tr><tr><td valign="baseline"><p>Dynamic binding</p></td><td valign="baseline"><p>动态绑定</p></td></tr><tr><td valign="baseline"><p>Dynamic dispatch</p></td><td valign="baseline"><p>动态分发</p></td></tr><tr><td valign="baseline"><p>Dynamic extent</p></td><td valign="baseline"><p>动态期限</p></td></tr><tr><td valign="baseline"><p>Dynamic scoping</p></td><td valign="baseline"><p>动态定界</p></td></tr><tr><td valign="baseline"><p>Dynamic</p></td><td valign="baseline"><p>动态</p></td></tr><tr><td valign="baseline"><p>Eager</p></td><td valign="baseline"><p>即时</p></td></tr><tr><td valign="baseline"><p>Effect</p></td><td valign="baseline"><p><div class="SIntrapara">效果（<span class="emph">effect 常常与 side 连用，
通译为“副作用”；在本书中，effect 从不与 side 连用，或许是暗示：
作为程序效果的 effect，不仅仅是一种“副产品”</span>）</div></p></td></tr><tr><td valign="baseline"><p>Environment</p></td><td valign="baseline"><p>环境</p></td></tr><tr><td valign="baseline"><p>Exception handling</p></td><td valign="baseline"><p>异常处理</p></td></tr><tr><td valign="baseline"><p>Expanded type</p></td><td valign="baseline"><p>展开类型</p></td></tr><tr><td valign="baseline"><p>Explicit reference</p></td><td valign="baseline"><p>显式引用</p></td></tr><tr><td valign="baseline"><p>Export</p></td><td valign="baseline"><p>输出</p></td></tr><tr><td valign="baseline"><p>Expressed value</p></td><td valign="baseline"><p>表达值</p></td></tr><tr><td valign="baseline"><p>Expression-oriented</p></td><td valign="baseline"><p>面向表达式</p></td></tr><tr><td valign="baseline"><p>Extend</p></td><td valign="baseline"><p>扩展</p></td></tr><tr><td valign="baseline"><p>Extent</p></td><td valign="baseline"><p>期限</p></td></tr><tr><td valign="baseline"><p>External</p></td><td valign="baseline"><p>外在</p></td></tr><tr><td valign="baseline"><p>Extractor</p></td><td valign="baseline"><p><div class="SIntrapara">提取器（<span class="emph">提取数据结构中某一部
分内容的过程统称</span>）</div></p></td></tr><tr><td valign="baseline"><p>Field</p></td><td valign="baseline"><p>字段</p></td></tr><tr><td valign="baseline"><p>Flowchart program</p></td><td valign="baseline"><p>流程图程序</p></td></tr><tr><td valign="baseline"><p>Fluid binding</p></td><td valign="baseline"><p>流式绑定</p></td></tr><tr><td valign="baseline"><p>For effect</p></td><td valign="baseline"><p>求效果</p></td></tr><tr><td valign="baseline"><p>Form</p></td><td valign="baseline"><p><div class="SIntrapara">形式（<span class="emph">在本书中，这一术语和 construct 含
意相近</span>）</div></p></td></tr><tr><td valign="baseline"><p>Formal parameter</p></td><td valign="baseline"><p>形式参数，简称形参</p></td></tr><tr><td valign="baseline"><p>Frame</p></td><td valign="baseline"><p>帧</p></td></tr><tr><td valign="baseline"><p>Front end</p></td><td valign="baseline"><p>前端</p></td></tr><tr><td valign="baseline"><p>Frozen</p></td><td valign="baseline"><p>冻结</p></td></tr><tr><td valign="baseline"><p>Generalization</p></td><td valign="baseline"><p>泛化</p></td></tr><tr><td valign="baseline"><p>Generalize</p></td><td valign="baseline"><p>放宽</p></td></tr><tr><td valign="baseline"><p>Global</p></td><td valign="baseline"><p>全局性</p></td></tr><tr><td valign="baseline"><p>Grammar</p></td><td valign="baseline"><p>语法</p></td></tr><tr><td valign="baseline"><p>Grammatical</p></td><td valign="baseline"><p>语法</p></td></tr><tr><td valign="baseline"><p>Hard-coded</p></td><td valign="baseline"><p>硬编码</p></td></tr><tr><td valign="baseline"><p>Host class</p></td><td valign="baseline"><p>持有类</p></td></tr><tr><td valign="baseline"><p>Hypothesis</p></td><td valign="baseline"><p>假设</p></td></tr><tr><td valign="baseline"><p>Ill-typed</p></td><td valign="baseline"><p>异常类型</p></td></tr><tr><td valign="baseline"><p>Implementation language</p></td><td valign="baseline"><p>实现语言</p></td></tr><tr><td valign="baseline"><p>Implementation</p></td><td valign="baseline"><p>实现</p></td></tr><tr><td valign="baseline"><p>Implicit reference</p></td><td valign="baseline"><p>隐式引用</p></td></tr><tr><td valign="baseline"><p>Inclusive or</p></td><td valign="baseline"><p>涵盖或</p></td></tr><tr><td valign="baseline"><p>Infer</p></td><td valign="baseline"><p>推断</p></td></tr><tr><td valign="baseline"><p>Inherit from</p></td><td valign="baseline"><p>继承于</p></td></tr><tr><td valign="baseline"><p>Inheritance</p></td><td valign="baseline"><p>继承</p></td></tr><tr><td valign="baseline"><p>Inherited attribute</p></td><td valign="baseline"><p>继承属性</p></td></tr><tr><td valign="baseline"><p>Inlining</p></td><td valign="baseline"><p>内联</p></td></tr><tr><td valign="baseline"><p>Input expression</p></td><td valign="baseline"><p>输入表达式</p></td></tr><tr><td valign="baseline"><p>Instance variable</p></td><td valign="baseline"><p>实例变量</p></td></tr><tr><td valign="baseline"><p>Instance</p></td><td valign="baseline"><p>实例</p></td></tr><tr><td valign="baseline"><p>Interface polymorphism</p></td><td valign="baseline"><p>接口多态</p></td></tr><tr><td valign="baseline"><p>Interface</p></td><td valign="baseline"><p>接口</p></td></tr><tr><td valign="baseline"><p>Internal</p></td><td valign="baseline"><p>内在</p></td></tr><tr><td valign="baseline"><p>Interpreter recipe</p></td><td valign="baseline"><p>解释器秘方</p></td></tr><tr><td valign="baseline"><p>Invariant</p></td><td valign="baseline"><p>不变式</p></td></tr><tr><td valign="baseline"><p>Iterative control behavior</p></td><td valign="baseline"><p>迭代性控制行为</p></td></tr><tr><td valign="baseline"><p>Kleene Plus</p></td><td valign="baseline"><p>克莱尼加号</p></td></tr><tr><td valign="baseline"><p>Kleene Star</p></td><td valign="baseline"><p>克莱尼星号</p></td></tr><tr><td valign="baseline"><p>Kleene closure</p></td><td valign="baseline"><p>克莱尼闭包</p></td></tr><tr><td valign="baseline"><p>L-value</p></td><td valign="baseline"><p>左值</p></td></tr><tr><td valign="baseline"><p>Lambda calculus</p></td><td valign="baseline"><p>Lambda 演算</p></td></tr><tr><td valign="baseline"><p>Lazy evaluation</p></td><td valign="baseline"><p>懒求值</p></td></tr><tr><td valign="baseline"><p>Lexeme</p></td><td valign="baseline"><p>词素</p></td></tr><tr><td valign="baseline"><p>Lexical address</p></td><td valign="baseline"><p>词法地址</p></td></tr><tr><td valign="baseline"><p>Lexical depth</p></td><td valign="baseline"><p>词深</p></td></tr><tr><td valign="baseline"><p>Lexical item</p></td><td valign="baseline"><p>词条</p></td></tr><tr><td valign="baseline"><p>Lexical scoping</p></td><td valign="baseline"><p>词法定界</p></td></tr><tr><td valign="baseline"><p>Lexical specification</p></td><td valign="baseline"><p>词法规范</p></td></tr><tr><td valign="baseline"><p>Lexical variable</p></td><td valign="baseline"><p>词法变量</p></td></tr><tr><td valign="baseline"><p>List</p></td><td valign="baseline"><p>列表</p></td></tr><tr><td valign="baseline"><p>Location</p></td><td valign="baseline"><p><div class="SIntrapara">位置（<span class="emph">特指存储器中的位置</span>）</div></p></td></tr><tr><td valign="baseline"><p>Member</p></td><td valign="baseline"><p>成员</p></td></tr><tr><td valign="baseline"><p>Memoization</p></td><td valign="baseline"><p>助记法</p></td></tr><tr><td valign="baseline"><p>Message-psasing</p></td><td valign="baseline"><p>消息传递</p></td></tr><tr><td valign="baseline"><p>Metacircular interpreter</p></td><td valign="baseline"><p>自循环解释器</p></td></tr><tr><td valign="baseline"><p>Method name</p></td><td valign="baseline"><p>方法名</p></td></tr><tr><td valign="baseline"><p>Method var</p></td><td valign="baseline"><p>方法变量</p></td></tr><tr><td valign="baseline"><p>Method</p></td><td valign="baseline"><p>方法</p></td></tr><tr><td valign="baseline"><p>Module definition</p></td><td valign="baseline"><p>模块定义</p></td></tr><tr><td valign="baseline"><p>Module procedure</p></td><td valign="baseline"><p>模块过程</p></td></tr><tr><td valign="baseline"><p>Module</p></td><td valign="baseline"><p>模块</p></td></tr><tr><td valign="baseline"><p>Multiple inheritance</p></td><td valign="baseline"><p>多继承</p></td></tr><tr><td valign="baseline"><p>Mutable</p></td><td valign="baseline"><p>可变的</p></td></tr><tr><td valign="baseline"><p>Mutex exclusion, mutex</p></td><td valign="baseline"><p>互斥锁</p></td></tr><tr><td valign="baseline"><p>Mutually recursive</p></td><td valign="baseline"><p>互递归</p></td></tr><tr><td valign="baseline"><p>Name mangling</p></td><td valign="baseline"><p>名称混淆</p></td></tr><tr><td valign="baseline"><p><div class="SIntrapara">Natural parameter passing</div></p></td><td valign="baseline"><p><div class="SIntrapara">自然式传参
（<span class="emph">相对于以 “call by” 开头的几种参数传递机制</span>）</div></p></td></tr><tr><td valign="baseline"><p><div class="SIntrapara">Object-oriented programming</div></p></td><td valign="baseline"><p>面向对象编程</p></td></tr><tr><td valign="baseline"><p>Object</p></td><td valign="baseline"><p>对象</p></td></tr><tr><td valign="baseline"><p>Observer</p></td><td valign="baseline"><p>观测器</p></td></tr><tr><td valign="baseline"><p>Occurrence check</p></td><td valign="baseline"><p>验存</p></td></tr><tr><td valign="baseline"><p>Occur free</p></td><td valign="baseline"><p>自由出现</p></td></tr><tr><td valign="baseline"><p>Offer</p></td><td valign="baseline"><p>提出</p></td></tr><tr><td valign="baseline"><p>Opaque type</p></td><td valign="baseline"><p>模糊类型</p></td></tr><tr><td valign="baseline"><p>Operand position</p></td><td valign="baseline"><p>操作数位置</p></td></tr><tr><td valign="baseline"><p>Operand</p></td><td valign="baseline"><p>操作数</p></td></tr><tr><td valign="baseline"><p>Operator</p></td><td valign="baseline"><p>操作符</p></td></tr><tr><td valign="baseline"><p>Overloading</p></td><td valign="baseline"><p>重载</p></td></tr><tr><td valign="baseline"><p>Override</p></td><td valign="baseline"><p>覆盖</p></td></tr><tr><td valign="baseline"><p>pair</p></td><td valign="baseline"><p>序对</p></td></tr><tr><td valign="baseline"><p>Parameterized module</p></td><td valign="baseline"><p>参数化模块</p></td></tr><tr><td valign="baseline"><p>Parent</p></td><td valign="baseline"><p>父类</p></td></tr><tr><td valign="baseline"><p>Parser</p></td><td valign="baseline"><p>解析器</p></td></tr><tr><td valign="baseline"><p>Parsing</p></td><td valign="baseline"><p>解析</p></td></tr><tr><td valign="baseline"><p>Polish prefix notation</p></td><td valign="baseline"><p>波兰前缀表示法</p></td></tr><tr><td valign="baseline"><p>Polymorphic</p></td><td valign="baseline"><p>多态</p></td></tr><tr><td valign="baseline"><p>Pool</p></td><td valign="baseline"><p><div class="SIntrapara">池（<span class="emph">特指线程池</span>）</div></p></td></tr><tr><td valign="baseline"><p>Pre-emptive scheduling</p></td><td valign="baseline"><p>抢占式调度</p></td></tr><tr><td valign="baseline"><p>Predicate</p></td><td valign="baseline"><p>谓词</p></td></tr><tr><td valign="baseline"><p>Prefix list</p></td><td valign="baseline"><p>前缀列表</p></td></tr><tr><td valign="baseline"><p>Private</p></td><td valign="baseline"><p>私有的</p></td></tr><tr><td valign="baseline"><p>Procedural</p></td><td valign="baseline"><p><div class="SIntrapara">过程式</div></p></td></tr><tr><td valign="baseline"><p>Procedure</p></td><td valign="baseline"><p><div class="SIntrapara">过程（<span class="emph">文中使用 procedure 表
示编程语言中的函数；使用 function 时，一般表示数学中的函数，这里将前者译作
“过程”，以示区别</span>）</div></p></td></tr><tr><td valign="baseline"><p>Production</p></td><td valign="baseline"><p>生成式</p></td></tr><tr><td valign="baseline"><p>Promise</p></td><td valign="baseline"><p>承诺</p></td></tr><tr><td valign="baseline"><p>Propagate</p></td><td valign="baseline"><p>传播</p></td></tr><tr><td valign="baseline"><p>Protected</p></td><td valign="baseline"><p>受保护的</p></td></tr><tr><td valign="baseline"><p>Prototype</p></td><td valign="baseline"><p>原型</p></td></tr><tr><td valign="baseline"><p>Pseudo-variable</p></td><td valign="baseline"><p>伪变量</p></td></tr><tr><td valign="baseline"><p>Public</p></td><td valign="baseline"><p>公有的</p></td></tr><tr><td valign="baseline"><p>Qualified</p></td><td valign="baseline"><p>受限变量</p></td></tr><tr><td valign="baseline"><p>Quantum</p></td><td valign="baseline"><p><div class="SIntrapara">量子（<span class="emph">即时间片</span>）</div></p></td></tr><tr><td valign="baseline"><p>R-value</p></td><td valign="baseline"><p>右值</p></td></tr><tr><td valign="baseline"><p>Ready queue</p></td><td valign="baseline"><p>就绪队列</p></td></tr><tr><td valign="baseline"><p>Record</p></td><td valign="baseline"><p>记录表</p></td></tr><tr><td valign="baseline"><p>Recursive control behavior</p></td><td valign="baseline"><p>递归性控制行为</p></td></tr><tr><td valign="baseline"><p>Reference</p></td><td valign="baseline"><p>引用</p></td></tr><tr><td valign="baseline"><p><div class="SIntrapara">Regexp, regular expression</div></p></td><td valign="baseline"><p>正则表达式</p></td></tr><tr><td valign="baseline"><p>Registerization</p></td><td valign="baseline"><p>寄存</p></td></tr><tr><td valign="baseline"><p>Representation-independent</p></td><td valign="baseline"><p>表示无关</p></td></tr><tr><td valign="baseline"><p>Ribcage</p></td><td valign="baseline"><p>肋排</p></td></tr><tr><td valign="baseline"><p>Rib</p></td><td valign="baseline"><p>肋骨</p></td></tr><tr><td valign="baseline"><p>Rule (of inference)</p></td><td valign="baseline"><p>（推理）规则</p></td></tr><tr><td valign="baseline"><p>Runnable</p></td><td valign="baseline"><p>可运行</p></td></tr><tr><td valign="baseline"><p>Running</p></td><td valign="baseline"><p>在运行</p></td></tr><tr><td valign="baseline"><p>Safe</p></td><td valign="baseline"><p>安全</p></td></tr><tr><td valign="baseline"><p>Scanning</p></td><td valign="baseline"><p>扫描</p></td></tr><tr><td valign="baseline"><p>Scheduler</p></td><td valign="baseline"><p>调度器</p></td></tr><tr><td valign="baseline"><p>Scope</p></td><td valign="baseline"><p>作用域</p></td></tr><tr><td valign="baseline"><p>Scoping</p></td><td valign="baseline"><p>定界</p></td></tr><tr><td valign="baseline"><p>Semi-infinite</p></td><td valign="baseline"><p>半无限</p></td></tr><tr><td valign="baseline"><p>Separated list</p></td><td valign="baseline"><p>分隔表</p></td></tr><tr><td valign="baseline"><p>Sequentialization</p></td><td valign="baseline"><p>序列化</p></td></tr><tr><td valign="baseline"><p>Shadow</p></td><td valign="baseline"><p>遮蔽</p></td></tr><tr><td valign="baseline"><p>Share</p></td><td valign="baseline"><p>共享</p></td></tr><tr><td valign="baseline"><p>Signature</p></td><td valign="baseline"><p>签名</p></td></tr><tr><td valign="baseline"><p>Simple interface</p></td><td valign="baseline"><p>简单接口</p></td></tr><tr><td valign="baseline"><p>Simple module</p></td><td valign="baseline"><p>简单模块</p></td></tr><tr><td valign="baseline"><p>Simple variable</p></td><td valign="baseline"><p>简单变量</p></td></tr><tr><td valign="baseline"><p>Single-inheritance</p></td><td valign="baseline"><p>单继承</p></td></tr><tr><td valign="baseline"><p>Sound</p></td><td valign="baseline"><p>健壮的</p></td></tr><tr><td valign="baseline"><p>Source language</p></td><td valign="baseline"><p>源语言</p></td></tr><tr><td valign="baseline"><p>Stack</p></td><td valign="baseline"><p>栈</p></td></tr><tr><td valign="baseline"><p>Statement-oriented</p></td><td valign="baseline"><p>面向语句</p></td></tr><tr><td valign="baseline"><p>State</p></td><td valign="baseline"><p>状态</p></td></tr><tr><td valign="baseline"><p>Static depth</p></td><td valign="baseline"><p>静深</p></td></tr><tr><td valign="baseline"><p>Static environment</p></td><td valign="baseline"><p>静态环境</p></td></tr><tr><td valign="baseline"><p>Static method dispatch</p></td><td valign="baseline"><p>静态方法分发</p></td></tr><tr><td valign="baseline"><p>Static</p></td><td valign="baseline"><p>静态</p></td></tr><tr><td valign="baseline"><p>Storable value</p></td><td valign="baseline"><p>可存储值</p></td></tr><tr><td valign="baseline"><p>Store-passing interpreter</p></td><td valign="baseline"><p>传递存储器的解释器</p></td></tr><tr><td valign="baseline"><p>Store-passing specification</p></td><td valign="baseline"><p>存储器传递规范</p></td></tr><tr><td valign="baseline"><p>Store</p></td><td valign="baseline"><p>存储器</p></td></tr><tr><td valign="baseline"><p>Structural induction</p></td><td valign="baseline"><p>结构化归纳法</p></td></tr><tr><td valign="baseline"><p>Subclass polymorphism</p></td><td valign="baseline"><p>子类多态</p></td></tr><tr><td valign="baseline"><p>Subclass</p></td><td valign="baseline"><p>子类</p></td></tr><tr><td valign="baseline"><p>Subgoal induction</p></td><td valign="baseline"><p>子目标归纳</p></td></tr><tr><td valign="baseline"><p>Subroutine</p></td><td valign="baseline"><p>子程序</p></td></tr><tr><td valign="baseline"><p>Substitution</p></td><td valign="baseline"><p><div class="SIntrapara">代换，代换式（组）（<span class="emph">视上下文，这
一术语有时表示类型推导的动作，有时表示动作的结果；表示结果时，有时为单数，
有时为复数</span>）</div></p></td></tr><tr><td valign="baseline"><p>Subtype polymorphism</p></td><td valign="baseline"><p>子类型多态</p></td></tr><tr><td valign="baseline"><p>Subtyping</p></td><td valign="baseline"><p>子类型判定</p></td></tr><tr><td valign="baseline"><p>Super call</p></td><td valign="baseline"><p>超类调用</p></td></tr><tr><td valign="baseline"><p>Superclass</p></td><td valign="baseline"><p>超类</p></td></tr><tr><td valign="baseline"><p>Superprototype</p></td><td valign="baseline"><p>超型</p></td></tr><tr><td valign="baseline"><p>Supply, provide</p></td><td valign="baseline"><p>提供</p></td></tr><tr><td valign="baseline"><p>Symbol table</p></td><td valign="baseline"><p>符号表</p></td></tr><tr><td valign="baseline"><p>Syntactic category</p></td><td valign="baseline"><p>句法类别</p></td></tr><tr><td valign="baseline"><p>Syntactic derivation</p></td><td valign="baseline"><p>句法推导</p></td></tr><tr><td valign="baseline"><p>Table</p></td><td valign="baseline"><p><div class="SIntrapara">表（<span class="emph">特指哈希表，或与之类似的数据
结构。<a href="da.html" data-pltdoc="x">数据抽象</a>中的 Record 与之类似。</span>）</div></p></td></tr><tr><td valign="baseline"><p>Tail call</p></td><td valign="baseline"><p>尾调用</p></td></tr><tr><td valign="baseline"><p>Tail form</p></td><td valign="baseline"><p>尾式</p></td></tr><tr><td valign="baseline"><p>Tail position</p></td><td valign="baseline"><p>尾端</p></td></tr><tr><td valign="baseline"><p>Target language</p></td><td valign="baseline"><p>目标语言</p></td></tr><tr><td valign="baseline"><p>Thawed</p></td><td valign="baseline"><p>解冻</p></td></tr><tr><td valign="baseline"><p>Thread identifier</p></td><td valign="baseline"><p>线程描述符</p></td></tr><tr><td valign="baseline"><p>Thread</p></td><td valign="baseline"><p>线程</p></td></tr><tr><td valign="baseline"><p>Thunk</p></td><td valign="baseline"><p>值箱</p></td></tr><tr><td valign="baseline"><p>Time slice</p></td><td valign="baseline"><p>时间片</p></td></tr><tr><td valign="baseline"><p>Token</p></td><td valign="baseline"><p>词牌</p></td></tr><tr><td valign="baseline"><p>Top-down</p></td><td valign="baseline"><p>自顶向下</p></td></tr><tr><td valign="baseline"><p>Trampoline</p></td><td valign="baseline"><p><div class="SIntrapara">跳床（<span class="emph">读者或许对 Microsoft
Windows XP 系统自带的“三维弹球”游戏仍有印象，文中的 trampoline 和
bounce 可以视为这一游戏的类比——或者说，这一游戏生动说明了 trampoline 和 bounce
的作用</span>）</div></p></td></tr><tr><td valign="baseline"><p>Trampolining</p></td><td valign="baseline"><p><div class="SIntrapara">跳跃（<span class="emph">视语境，有时也将这
一术语直接翻译为跳床</span>）</div></p></td></tr><tr><td valign="baseline"><p>Translator</p></td><td valign="baseline"><p>翻译器</p></td></tr><tr><td valign="baseline"><p>Transparent</p></td><td valign="baseline"><p>透明</p></td></tr><tr><td valign="baseline"><p>Type Checking</p></td><td valign="baseline"><p>类型检查</p></td></tr><tr><td valign="baseline"><p>Type Inference</p></td><td valign="baseline"><p>类型推导</p></td></tr><tr><td valign="baseline"><p>Type abbreviation</p></td><td valign="baseline"><p>类型缩写</p></td></tr><tr><td valign="baseline"><p>Type environment</p></td><td valign="baseline"><p>类型环境</p></td></tr><tr><td valign="baseline"><p>Type error</p></td><td valign="baseline"><p>类型错误</p></td></tr><tr><td valign="baseline"><p>Type expression</p></td><td valign="baseline"><p>类型表达式</p></td></tr><tr><td valign="baseline"><p>Type structure</p></td><td valign="baseline"><p>类型结构</p></td></tr><tr><td valign="baseline"><p>Unary representation</p></td><td valign="baseline"><p>一元表示法</p></td></tr><tr><td valign="baseline"><p>Unification</p></td><td valign="baseline"><p>合一</p></td></tr><tr><td valign="baseline"><p>Value declaration</p></td><td valign="baseline"><p>值声明</p></td></tr><tr><td valign="baseline"><p>Value restriction</p></td><td valign="baseline"><p>值约束</p></td></tr><tr><td valign="baseline"><p>Variable aliasing</p></td><td valign="baseline"><p>变量别名</p></td></tr><tr><td valign="baseline"><p>Variable expression</p></td><td valign="baseline"><p>变量表达式</p></td></tr><tr><td valign="baseline"><p>Variable</p></td><td valign="baseline"><p>变量</p></td></tr><tr><td valign="baseline"><p>Variant</p></td><td valign="baseline"><p>变体</p></td></tr><tr><td valign="baseline"><p>Virtual machine</p></td><td valign="baseline"><p>虚拟机</p></td></tr><tr><td valign="baseline"><p>Well-typed</p></td><td valign="baseline"><p>正常类型</p></td></tr></table></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">  <a href="fw-trans.html" title="backward to "译者的话"" data-pltdoc="x">← prev</a>  <a href="index.html" title="up to "编程语言要素"" data-pltdoc="x">up</a>  <a href="fw.html" title="forward to "序"" data-pltdoc="x">next →</a></span> </div></div></div><div id="contextindicator"> </div></body></html>