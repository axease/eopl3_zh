<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=0.8" />
  <title>2 数据抽象</title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default" />
  <link rel="stylesheet" type="text/css" href="racket.css" title="default" />
  <link rel="stylesheet" type="text/css" href="tip.css" title="default" />
  <script type="text/javascript" src="scribble-common.js"></script>
  <script src="katex/katex.min.js"></script>
  <script src="onload.js"></script>
</head>

<body id="scribble-racket-lang-org">
  <div class="tocset">
    <div class="tocview">
      <div class="tocviewlist tocviewlisttopspace">
        <div class="tocviewtitle">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle"
                  onclick="TocviewToggle(this," tocview_0");">▼</a></td>
              <td></td>
              <td><a href="index.html" class="tocviewlink" data-pltdoc="x">编程语言要素</a></td>
            </tr>
          </table>
        </div>
        <div class="tocviewsublisttop" style="display: block;" id="tocview_0">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td align="right"></td>
              <td><a href="fw-trans.html" class="tocviewlink" data-pltdoc="x">译者的话</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="glo.html" class="tocviewlink" data-pltdoc="x">译名表</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="fw.html" class="tocviewlink" data-pltdoc="x">序</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="pf.html" class="tocviewlink" data-pltdoc="x">前言</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="awk.html" class="tocviewlink" data-pltdoc="x">致谢</a></td>
            </tr>
            <tr>
              <td align="right">1 </td>
              <td><a href="isd.html" class="tocviewlink" data-pltdoc="x">归纳式数据集</a></td>
            </tr>
            <tr>
              <td align="right">2 </td>
              <td><a href="" class="tocviewselflink" data-pltdoc="x">数据抽象</a></td>
            </tr>
            <tr>
              <td align="right">3 </td>
              <td><a href="expr.html" class="tocviewlink" data-pltdoc="x">表达式</a></td>
            </tr>
            <tr>
              <td align="right">4 </td>
              <td><a href="state.html" class="tocviewlink" data-pltdoc="x">状态</a></td>
            </tr>
            <tr>
              <td align="right">5 </td>
              <td><a href="cpi.html" class="tocviewlink" data-pltdoc="x">传递续文的解释器</a></td>
            </tr>
            <tr>
              <td align="right">6 </td>
              <td><a href="cps.html" class="tocviewlink" data-pltdoc="x">续文传递风格</a></td>
            </tr>
            <tr>
              <td align="right">7 </td>
              <td><a href="types.html" class="tocviewlink" data-pltdoc="x">类型</a></td>
            </tr>
            <tr>
              <td align="right">8 </td>
              <td><a href="modules.html" class="tocviewlink" data-pltdoc="x">模块</a></td>
            </tr>
            <tr>
              <td align="right">9 </td>
              <td><a href="oac.html" class="tocviewlink" data-pltdoc="x">对象和类</a></td>
            </tr>
            <tr>
              <td align="right">10 </td>
              <td><a href="further-reading.html" class="tocviewlink" data-pltdoc="x">扩展阅读</a></td>
            </tr>
            <tr>
              <td align="right">11 </td>
              <td><a href="sllgen-parsing-system.html" class="tocviewlink" data-pltdoc="x">SLLGEN解析系统</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="bib.html" class="tocviewlink" data-pltdoc="x">参考书目</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="indices.html" class="tocviewlink" data-pltdoc="x">索引</a></td>
            </tr>
          </table>
        </div>
      </div>
      <div class="tocviewlist">
        <table cellspacing="0" cellpadding="0">
          <tr>
            <td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle"
                onclick="TocviewToggle(this," tocview_1");">►</a></td>
            <td>2 </td>
            <td><a href="" class="tocviewselflink" data-pltdoc="x">数据抽象</a></td>
          </tr>
        </table>
        <div class="tocviewsublistbottom" style="display: none;" id="tocview_1">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td align="right">2.1 </td>
              <td><a href="#%28part._s2..1%29" class="tocviewlink" data-pltdoc="x">用接口定义数据</a></td>
            </tr>
            <tr>
              <td align="right">2.2 </td>
              <td><a href="#%28part._s2..2%29" class="tocviewlink" data-pltdoc="x">数据类型的表示策略</a></td>
            </tr>
            <tr>
              <td align="right">2.3 </td>
              <td><a href="#%28part._s2..3%29" class="tocviewlink" data-pltdoc="x">递推数据类型的接口</a></td>
            </tr>
            <tr>
              <td align="right">2.4 </td>
              <td><a href="#%28part._s2..4%29" class="tocviewlink" data-pltdoc="x">定义递推数据类型的工具</a></td>
            </tr>
            <tr>
              <td align="right">2.5 </td>
              <td><a href="#%28part._s2..5%29" class="tocviewlink" data-pltdoc="x">抽象语法及其表示</a></td>
            </tr>
          </table>
        </div>
      </div>
    </div>
    <div class="tocsub">
      <div class="tocsubtitle">On this page:</div>
      <table class="tocsublist" cellspacing="0">
        <tr>
          <td><span class="tocsublinknumber">2.1<tt> </tt></span><a href="#%28part._s2..1%29" class="tocsubseclink"
              data-pltdoc="x">用接口定义数据</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">2.2<tt> </tt></span><a href="#%28part._s2..2%29" class="tocsubseclink"
              data-pltdoc="x">数据类型的表示策略</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">2.2.1<tt> </tt></span><a href="#%28part._s2..2..1%29" class="tocsubseclink"
              data-pltdoc="x">环境的接口</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">2.2.2<tt> </tt></span><a href="#%28part._s2..2..2%29" class="tocsubseclink"
              data-pltdoc="x">数据结构表示法</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">2.2.3<tt> </tt></span><a href="#%28part._s2..2..3%29" class="tocsubseclink"
              data-pltdoc="x">过程表示法</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">2.3<tt> </tt></span><a href="#%28part._s2..3%29" class="tocsubseclink"
              data-pltdoc="x">递推数据类型的接口</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">2.4<tt> </tt></span><a href="#%28part._s2..4%29" class="tocsubseclink"
              data-pltdoc="x">定义递推数据类型的工具</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">2.5<tt> </tt></span><a href="#%28part._s2..5%29" class="tocsubseclink"
              data-pltdoc="x">抽象语法及其表示</a></td>
        </tr>
      </table>
    </div>
  </div>
  <div class="maincolumn">
    <div class="main">
      <div class="navsettop"><span class="navleft">
          <div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);"
              title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
        </span><span class="navright">  <a href="isd.html" title="backward to " 1 归纳式数据集"" data-pltdoc="x">←
            prev</a>  <a href="index.html" title="up to " 编程语言要素"" data-pltdoc="x">up</a>  <a href="expr.html"
            title="forward to " 3 表达式"" data-pltdoc="x">next →</a></span> </div>
      <h3>2<tt> </tt><a name="(part._da)"></a>数据抽象</h3>
      <p><a name="(idx._(gentag._175))"></a></p>
      <h4>2.1<tt> </tt><a name="(part._s2..1)"></a>用接口定义数据</h4>
      <p>每当我们想以某种方式表示一些量时，我们就新定义了一种数据类型：它的取值是其表示，
        它的操作是处理其实体的过程。</p>
      <p>这些实体的表示通常很复杂，所以如能避免，我们不愿关心其细节。我们可能想改变数据的
        表示。最高效的表示往往难以实现，所以我们可能希望先简单实现，只在确知系统的整体性
        能与之攸关时，才改用更高效的表示。不管出于什么原因，如果我们决定改变某些数据的表
        示方式，我们得能定位程序中所有依赖表示方式的部分。这就需要
        借助<span class="emph">数据抽象</span> (<span class="emph">data abstraction</span>) 技术。</p>
      <p><a name="(idx._(gentag._176))"></a>
        <a name="(idx._(gentag._177))"></a>
        数据抽象将数据类型分为两部分：<span class="emph">接口</span> (<span class="emph">interface</span>) 和<span class="emph">实现</span>
        (<span class="emph">implementation</span>)。
        <span class="emph">接口</span>告诉我们某类型表示什么数据，能对数据做什么操作，以及可由这些操作得出
        的性质。<span class="emph">实现</span>给出数据的具体表示，以及处理数据表示的代码。
      </p>
      <p><a name="(idx._(gentag._178))"></a>
        这样抽象出的数据类型称为<span class="emph">抽象数据类型</span> (<span class="emph">abstract data type</span>)。程序的其余部
        分——数据类型的<span class="emph">客户</span> (<span class="emph">client</span>)<a name="(idx._(gentag._179))"></a>
        ——只能通过接口中指定的操作处理新数据。这样一
        来，如果我们希望改变数据的表示，只需改变数据处理接口的实现。</p>
      <p>这一想法并不陌生：我们写程序处理文件时，多数时候只关心能否调用过程来打开，关闭，
        读取文件或对文件做其他操作。同样地，大多数时候，我们不关心整数在机器中究竟怎样表
        示，只关心能否可靠地执行算术操作。</p>
      <p><a name="(idx._(gentag._180))"></a>
        <a name="(idx._(gentag._181))"></a>
        当客户只能通过接口提供的过程处理某类型的数据时，我们说客户代码
        与<span class="emph">表示无关</span> (<span class="emph">representation-independent</span>)，因为这些代码不依赖数据类型值的
        表示。
      </p>
      <p>那么所有关于数据表示的信息必然在实现代码之中。实现最重要的部分就是表示数据的规范。
        我们用符号 <span class="texMathInline">\lceil v \rceil</span> 指代“数据 <span class="texMathInline">v</span> 的表示”。</p>
      <p><a name="(idx._(gentag._182))"></a>
        要说得更明白些，来看一个简单例子：自然数类型。待表示的数据是自然数。接口由四个过
        程组成：<span class="stt">zero</span>、<span class="stt">is-zero?</span>、<span class="stt">successor</span> 和 <span
          class="stt">predecessor</span>。当然，不是
        随便几个过程都可以作为这一接口的实现。当且仅当一组过程满足如下四个方程时，可以作
        为 <span class="stt">zero</span>、<span class="stt">is-zero?</span>、<span class="stt">successor</span> 和 <span
          class="stt">predecessor</span> 的实现：</p>
      <blockquote>
        <p><a name="(elem._nat)"></a><span class="stt">(zero)</span> = <span class="texMathInline">\lceil 0
            \rceil</span></p>
        <p><span class="stt">(is-zero? </span><span class="texMathInline">\lceil n \rceil</span><span
            class="stt">)</span> = <span class="Iidentity">$<span class="Iidentity">\begin{cases}<span
                class="stt">#t</span> & n = 0 \\
              <span class="stt">#f</span> & n \neq 0\end{cases}</span>$</span></p>
        <p><span class="stt">(successor </span><span class="texMathInline">\lceil n \rceil</span><span
            class="stt">)</span> = <span class="texMathInline">\lceil n + 1 \rceil \quad (n \geq 0)</span></p>
        <p><span class="stt">(predecessor </span><span class="texMathInline">\lceil n + 1 \rceil</span><span
            class="stt">)</span> = <span class="texMathInline">\lceil n \rceil \quad (n \geq 0)</span></p>
      </blockquote>
      <p>这一定义没有指明自然数应当如何表示，它只要求这些过程都产生指定的行为。即，过程
        <span class="stt">zero</span> 必须返回 <span class="texMathInline">0</span> 的表示；给定数字 <span
          class="texMathInline">n</span> 的表示，过程 <span class="stt">successor</span> 必须
        返回数字 <span class="texMathInline">n + 1</span> 的表示，等等。这个定义没对 <span class="stt">(predecessor (zero))</span> 做出说明，
        所以按这个定义，任何行为都是可以接受的。
      </p>
      <p>现在可以写出处理自然数的客户程序，而且不论用哪种表示方式，都保证能得出正确的结果。
        例如，不论怎样实现自然数，</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><a name="(elem._plus)"></a><span class="RktSym">define</span><span
                    class="hspace"> </span><span class="RktSym">plus</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">x</span><span
                    class="hspace"> </span><span class="RktSym">y</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">is-zero?</span><span
                    class="hspace"> </span><span class="RktSym">x</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktSym">y</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">successor</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">plus</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">predecessor</span><span class="hspace"> </span><span class="RktSym">x</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">y</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>都满足 <span class="stt">(plus </span><span class="texMathInline">\lceil x \rceil</span><span class="stt">
          </span><span class="texMathInline">\lceil y \rceil</span><span class="stt">) </span><span
            class="texMathInline">=</span><span class="stt"> </span><span class="texMathInline">\lceil x +
            y\rceil</span>。</p>
      </blockquote>
      <p><a name="(idx._(gentag._183))"></a>
        <a name="(idx._(gentag._184))"></a>
        大多数接口都包含：若干<span class="emph">构造器</span> (<span class="emph">constructor</span>)，用来产生数据类型的元素；
        若干<span class="emph">观测器</span> (<span class="emph">observer</span>)，用来从数据类型的值中提取信息。这里有三个构造器，
        <span class="stt">zero</span>、<span class="stt">successor</span> 和 <span
          class="stt">predecessor</span>；一个观测器，<span class="stt">is-zero?</span>。
        <a name="(idx._(gentag._185))"></a>
      </p>
      <p>可以用多种方式表示这套接口，我们考虑其中三种。</p>
      <ol>
        <li>
          <p><a name="(idx._(gentag._186))"></a>
            <a name="(idx._(gentag._187))"></a>
            <span class="emph">一元表示法</span> (<span class="emph">Unary representation</span>)：在一元表示法中，自然数<span
              class="texMathInline">n</span> 由
            <span class="texMathInline">n</span> 个 <span class="stt">#t</span> 组成的列表表示。所以，<span
              class="texMathInline">0</span> 表示为 <span class="stt">()</span>，<span class="texMathInline">1</span> 表示为
            <span class="stt">(#t)</span>，<span class="texMathInline">2</span> 表示为 <span class="stt">(#t
              #t)</span>，等等。可以用归纳法定义这种表示方式：
          </p>
          <blockquote>
            <p><span class="texMathInline">\lceil 0 \rceil = <span class="stt">()</span></span></p>
            <p><span class="texMathInline">\lceil n + 1 \rceil = <span class="stt">(#t . </span><span
                  class="texMathInline">\lceil n \rceil</span><span class="stt">)</span></span></p>
          </blockquote>
          <p>要满足该表示的定义，数据处理过程可以写成：</p>
          <p>
          <div class="SIntrapara">
            <blockquote class="EoplCodeInset">
              <blockquote class="SCodeFlow">
                <table cellspacing="0" cellpadding="0" class="RktBlk">
                  <tr>
                    <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                        class="RktSym">zero</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">'</span><span
                        class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span
                        class="RktPn">)</span></td>
                  </tr>
                  <tr>
                    <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                        class="RktSym">is-zero?</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">n</span><span class="RktPn">)</span><span class="hspace"> </span><span
                        class="RktPn">(</span><span class="RktSym">null?</span><span class="hspace"> </span><span
                        class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                        class="RktPn">)</span></td>
                  </tr>
                  <tr>
                    <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                        class="RktSym">successor</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">n</span><span class="RktPn">)</span><span class="hspace"> </span><span
                        class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace"> </span><span
                        class="RktVal">#t</span><span class="hspace"> </span><span class="RktSym">n</span><span
                        class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
                  </tr>
                  <tr>
                    <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                        class="RktSym">predecessor</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">n</span><span class="RktPn">)</span><span class="hspace"> </span><span
                        class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace"> </span><span
                        class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                        class="RktPn">)</span></td>
                  </tr>
                </table>
              </blockquote>
            </blockquote>
          </div>
          <div class="SIntrapara"><a name="(idx._(gentag._188))"></a></div>
          </p>
        </li>
        <li>
          <p><a name="(idx._(gentag._189))"></a>
            <span class="emph">Scheme 数字表示法</span> (<span class="emph">Scheme number representation</span>)：在这种表示中，
            只需用 Scheme 内置的数字表示法（本身可能十分复杂！）。令 <span class="texMathInline">\lceil n \rceil</span> 为
            Scheme 整数 <span class="stt">n</span>，则所需的四个过程可以定义为：
          </p>
          <blockquote class="EoplCodeInset">
            <p>
            <div class="SIntrapara">
              <blockquote class="SCodeFlow">
                <table cellspacing="0" cellpadding="0" class="RktBlk">
                  <tr>
                    <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                        class="RktSym">zero</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">0</span><span
                        class="RktPn">)</span><span class="RktPn">)</span></td>
                  </tr>
                  <tr>
                    <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                        class="RktSym">is-zero?</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">n</span><span class="RktPn">)</span><span class="hspace"> </span><span
                        class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace"> </span><span
                        class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                        class="RktPn">)</span></td>
                  </tr>
                  <tr>
                    <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                        class="RktSym">successor</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">n</span><span class="RktPn">)</span><span class="hspace"> </span><span
                        class="RktPn">(</span><span class="RktSym">+</span><span class="hspace"> </span><span
                        class="RktSym">n</span><span class="hspace"> </span><span class="RktVal">1</span><span
                        class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
                  </tr>
                  <tr>
                    <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                        class="RktSym">predecessor</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">n</span><span class="RktPn">)</span><span class="hspace"> </span><span
                        class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span
                        class="hspace"> </span><span class="RktSym">n</span><span class="hspace"> </span><span
                        class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                        class="RktPn">)</span></td>
                  </tr>
                </table>
              </blockquote>
            </div>
            <div class="SIntrapara"><a name="(idx._(gentag._190))"></a></div>
            </p>
          </blockquote>
        </li>
        <li>
          <p><span class="emph">大数表示法</span> (<span class="emph">Bignum representation</span>)：
            <a name="(idx._(gentag._191))"></a>
            <a name="(idx._(gentag._192))"></a>
            在大数表示法中，数值以 <span class="texMathInline">N</span> 进制表示，<span class="texMathInline">N</span> 是某个大整数。该方法以 <span
              class="texMathInline">0</span> 到
            <span class="texMathInline">N-1</span> 之间的数字（有时不称数位，而称<span class="emph">大位</span> (<span
              class="emph">bigits</span>)）组成的列表表示数值，
            这就很容易表示远超机器字长的整数。这里，为了便于使用，我们把最低位放在列表最前
            端。这种表示法可用归纳法定义为：
          </p>
          <p><span class="Iidentity">$\lceil n \rceil = <span class="Iidentity">\begin{cases}<span class="stt">()</span>
                & n = 0 \\ <span class="stt">(</span><span class="Iidentity">r</span><span class="stt"> . </span><span
                  class="Iidentity">\lceil q
                  \rceil</span><span class="stt">)</span> & n = qN + r, 0 \leqslant r < N\end{cases}</span>$</span></p>
          <p>所以，如果 <span class="texMathInline">N = 16</span>，那么 <span class="texMathInline">\lceil 33 \rceil = <span
                class="stt">(1 2)</span></span>，<span class="texMathInline">\lceil 258
              \rceil = <span class="stt">(2 0 1)</span></span>，因为：</p>
          <p><span class="texMathDisplay">258 = 2 \times 16^0 + 0 \times 16^1 + 1 \times 16^2</span>
            <a name="(idx._(gentag._193))"></a>
          </p>
        </li>
      </ol>
      <p><a name="(idx._(gentag._194))"></a>这些实现都没有强制数据抽象：无法防止客户程序查验表示用
        的是列表还是 Scheme 整数。与之相对，有些语言直接支持数据抽象：它们允许程序员创建
        新的接口，确保只能通过接口提供的过程处理新数据。如果类型的表示隐藏起来，不会因任
        何操作而暴露（包括打印），那就说该类型是<span class="emph">模糊</span> (<span class="emph">opaque</span>) 的，否则称之
        为<span class="emph">透明</span> (<span class="emph">transparent</span>) 的。
        <a name="(idx._(gentag._195))"></a>
        <a name="(idx._(gentag._196))"></a>
        <a name="(idx._(gentag._197))"></a>
        <a name="(idx._(gentag._198))"></a>
      </p>
      <p>Scheme 没有提供标准机制来创建新的模糊类型，所以我们退而求其次：定义接口，靠客户
        程序的作者小心行事，只使用接口中定义的过程。</p>
      <p>在<a href="modules.html" data-pltdoc="x">模块</a>中，我们讨论一些方法，以便强化语言的这种协议。</p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..1)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._199))"></a>
          实现大数表示法的四种操作。然后用你的实现计算10的阶乘。随着参数改变，执行时间如
          何变化？随着进制改变，执行时间如何变化？解释原因。
          <a name="(idx._(gentag._200))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..2)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>详加分析上述表示。从满足数据类型定义的角度来说，它们在何种程度上是成功或失败的？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..3)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._201))"></a>
          用差分树表示所有整数（负数和非负数）。差分树是一列表，可用语法定义如下：</p>
        <blockquote class="SubFlow">
          <p><span class="texMathDisplay">\mathit{Diff\text{-}tree} ::= <span class="stt">(one)</span> \mid <span
                class="stt">(diff</span><span class="stt">
              </span><span class="texMathInline">\mathit{Diff\text{-}tree}</span><span class="stt"> </span><span
                class="texMathInline">\mathit{Diff\text{-}tree}</span><span class="stt">)</span></span>
            <a name="(idx._(gentag._202))"></a>
          </p>
          <p>列表 <span class="stt">(one)</span> 表示 1。如果 <span class="texMathInline">t_1</span> 表示 <span
              class="texMathInline">n_1</span>，<span class="texMathInline">t_2</span> 表示 <span
              class="texMathInline">n_2</span>，那么
            <span class="stt">(diff </span><span class="texMathInline">n_1</span><span class="stt"> </span><span
              class="texMathInline">n_2</span><span class="stt">)</span> 表示 <span class="texMathInline">n_1 -
              n_2</span>。
          </p>
          <p>所以，<span class="stt">(one)</span> 和 <span class="stt">(diff</span> <span class="stt">(one)</span> <span
              class="stt">(diff</span> <span class="stt">(one)</span>
            <span class="stt">(one)))</span> 都表示1；<span class="stt">(diff</span> <span class="stt">(diff</span> <span
              class="stt">(one)</span> <span class="stt">(one))</span>
            <span class="stt">(one))</span> 表示 <span class="texMathInline">-1</span>。
          </p>
          <ol>
            <li>
              <p>证明此系统中，每个数都有无限种表示方式。</p>
            </li>
            <li>
              <p>实现这种整数表示法：写出<span class="stt">nat</span>定义的 <span class="stt">zero</span>、<span
                  class="stt">is-zero?</span>、
                <span class="stt">successor</span> 和 <span class="stt">predecessor</span>，此外还要能表示负数。这种方式下，整数的任
                何合法表示都应该能作为你过程的参数。例如，你的过程 <span class="stt">successor</span> 可以接受无
                限多种 <span class="texMathInline">1</span> 的合法表示，且都应给出一个 <span class="texMathInline">2</span>的合法表示。对 <span
                  class="texMathInline">1</span> 的不同合法
                表示，可以给出不同的 <span class="texMathInline">2</span> 的合法表示。
              </p>
            </li>
            <li>
              <p>写出过程 <span class="stt">diff-tree-plus</span>，用这种表示做加法。你的过程应针对不同的差
                分树进行优化，并在常数时间内得出结果（即与输入大小无关）。注意，不可使用递归。
                <a name="(idx._(gentag._203))"></a>
              </p>
            </li>
          </ol>
        </blockquote>
      </blockquote>
      <h4>2.2<tt> </tt><a name="(part._s2..2)"></a>数据类型的表示策略</h4>
      <p><a name="(idx._(gentag._204))"></a>
        <a name="(idx._(gentag._205))"></a>
        使用数据抽象的程序具有表示无关性：与用来实现抽象数据类型的具体表示方式无关，甚至
        可以通过重新定义接口中的一小部分过程来改变表示。在后面的章节中我们常会用到这条性
        质。
      </p>
      <p><a name="(idx._(gentag._206))"></a>
        <a name="(idx._(gentag._207))"></a>
        本节介绍几种数据类型的表示策略。我们用数据类型<span class="emph">环境</span> (<span class="emph">environment</span>) 解释这
        些选择。对有限个变量组成的集合，环境将值与其中的每个元素关联起来。在编程语言的实
        现之中，环境可用来维系变量与值的关系。编译器也能用环境将变量名与变量信息关联起来。
      </p>
      <p>只要能够检查两个变量是否相等，变量能够用我们喜欢的任何方式表示。我们选用 Scheme
        符号表示变量，但在没有符号数据类型的语言中，变量也可以用字符串，哈希表引用，甚至
        数字表示（见 <a href="expr.html#%28part._s3..6%29" data-pltdoc="x">消除变量名</a>）。</p>
      <h5>2.2.1<tt> </tt><a name="(part._s2..2..1)"></a>环境的接口</h5>
      <p>环境是一函数，定义域为有限个变量的集合，值域为所有 Scheme 值的集合。数学上常说的
        有限函数是指有序数对组成的有限集合，我们采用这一含义，就得表示形如
        <span class="Iidentity">$\{(var_1,\allowbreak val_1),\allowbreak ...,\allowbreak (var_n, val_n)\}$</span>的所
        有集合。其中，<span class="texMathInline">var_i</span> 是某一变量，<span class="texMathInline">val_i</span> 是任意 Scheme
        值。有时称环境
        <span class="texMathInline">env</span> 中变量 <span class="texMathInline">var</span> 的值 <span
          class="texMathInline">val</span> 为其在 <span class="texMathInline">env</span> 中的<span class="emph">绑定</span>
        (<span class="emph">binding</span>)。
        <a name="(idx._(gentag._208))"></a>
        <a name="(idx._(gentag._209))"></a>
      </p>
      <p>这一数据类型的接口有三个过程，定义如下：</p>
      <blockquote class="SubFlow">
        <p><a name="(idx._(gentag._210))"></a>
          <a name="(idx._(gentag._211))"></a>
          <a name="(idx._(gentag._212))"></a>
          <span class="Iidentity">\begin{align*}&<span class="stt">(empty-env)</span> &= &\ \lceil \emptyset \rceil \\
            &<span class="stt">(apply-env </span><span class="Iidentity">\lceil f \rceil</span><span class="stt">
            </span><span class="Iidentity">var</span><span class="stt">)</span> &= &\ f(var) \\
            &<span class="stt">(extend-env </span><span class="Iidentity">var</span><span class="stt"> </span><span
              class="Iidentity">v</span><span class="stt"> </span><span class="Iidentity">\lceil f \rceil</span><span
              class="stt">)</span> &= &\ \lceil g \rceil \\
            &\phantom{x} &其中，&\ g(var_1) = <span class="Iidentity">\begin{cases}v & 若\ var_1 = var \\
              f(var_1) & 否则\end{cases}</span>\end{align*}</span>
          <a name="(idx._(gentag._213))"></a>
        </p>
      </blockquote>
      <p>过程 <span class="stt">empty-env</span> 不带参数，必须返回空环境的表示；<span class="stt">apply-env</span> 用环境对变量
        求值；<span class="stt">(extend-env </span><span class="texMathInline">var</span><span class="stt"> </span><span
          class="texMathInline">val</span><span class="stt"> </span><span class="texMathInline">env</span><span
          class="stt">)</span> 产生一个新环境，将变量 <span class="texMathInline">var</span>
        的值设为 <span class="texMathInline">val</span>，此外与 <span class="texMathInline">env</span> 相同。例如，表达式</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">define</span><span
                    class="hspace"> </span><span class="RktSym">e</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">extend-env</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">d</span><span class="hspace"> </span><span class="RktVal">6</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">extend-env</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">y</span><span class="hspace"> </span><span class="RktVal">8</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">extend-env</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">7</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">extend-env</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">y</span><span class="hspace"> </span><span class="RktVal">14</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="hspace">          </span><span
                    class="RktPn">(</span><span class="RktSym">empty-env</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>定义了一个环境 <span class="texMathInline">e</span>，使 <span class="texMathInline">e(<span class="stt">d</span>) =
            6</span>，<span class="texMathInline">e(<span class="stt">x</span>) = 7</span>，<span
            class="texMathInline">e(<span class="stt">y</span>) =
            8</span>，且对任何其他变量，<span class="texMathInline">e</span>未定义。本例中，<span class="stt">y</span>先绑定到 <span
            class="texMathInline">14</span>，随后绑定到
          <span class="texMathInline">8</span>。这当然只是生成该环境的众多方法之一。
        </p>
      </blockquote>
      <p>如同前一个例子，可以将接口中的过程分为构造器和观测器。本例中，<span class="stt">empty-env</span>和
        <span class="stt">extend-env</span>是构造器，<span class="stt">apply-env</span>是唯一的观测器。
        <a name="(idx._(gentag._214))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..4)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._215))"></a>
          考虑数据类型<span class="emph">栈</span> (<span class="emph">stack</span>)，其接口包含过程 <span
            class="stt">empty-stack</span>、<span class="stt">push</span>、
          <span class="stt">pop</span>、<span class="stt">top</span> 和 <span
            class="stt">empty-stack?</span>。按照示例中的方式写出这些操作的定义。哪
          些操作是构造器？哪些是观测器？
          <a name="(idx._(gentag._216))"></a>
        </p>
      </blockquote>
      <h5>2.2.2<tt> </tt><a name="(part._s2..2..2)"></a>数据结构表示法</h5>
      <p><a name="(idx._(gentag._217))"></a>
        <a name="(idx._(gentag._218))"></a>
        观察可知，每个环境都能从空环境开始，<span class="texMathInline">n</span> 次调用 <span class="stt">extend-env</span> 得到，其中 <span
          class="texMathInline">n
          \geqslant 0</span>。例如，
      </p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">extend-env</span><span class="hspace"> </span><span
                    class="texMathInline">var_n</span><span class="hspace"> </span><span
                    class="texMathInline">val_n</span></td>
              </tr>
              <tr>
                <td><span class="hspace">   </span><span class="RktSym">...</span></td>
              </tr>
              <tr>
                <td><span class="hspace">   </span><span class="RktPn">(</span><span
                    class="RktSym">extend-env</span><span class="hspace"> </span><span
                    class="texMathInline">var_1</span><span class="hspace"> </span><span
                    class="texMathInline">val_1</span></td>
              </tr>
              <tr>
                <td><span class="hspace">     </span><span class="RktPn">(</span><span
                    class="RktSym">empty-env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>由此可得一种环境的表示方法。</p>
      </blockquote>
      <p>每个环境都能用下列语法定义的表达式生成：</p>
      <p><span class="Iidentity">\begin{align*}\mathit{Env\text{-}exp} &::= <span class="stt">(empty-env)</span> \\ &::=
          <span class="stt">(extend-env</span><span class="stt">
          </span><span class="Iidentity">\mathrm{Identifier}</span><span class="stt">
          </span><span class="Iidentity">\mathrm{Scheme\text{-}value}</span><span class="stt">
          </span><span class="Iidentity">\mathrm{Env\text{-}exp}</span><span class="stt">)</span>\end{align*}</span></p>
      <p>可以用描述列表集合的语法表示环境，由此得出<span class="EoplFigureRef"></span> 中的实现。过程 <span class="stt">apply-env</span> 查
        看表示环境的数据结构 <span class="stt">env</span>，判断它表示哪种环境，并做适当操作。如果它表示空环
        境，那就报错；如果它表示 <span class="stt">extend-env</span> 生成的环境，那就判断要查找的变量是否与
        环境中绑定的某一变量相同，如果是，则返回保存的值，否则在保存的环境中查找变量。</p>
      <p>这是一种常见的代码模式。我们叫它<span class="emph">解释器秘方</span> (<span class="emph">interpreter recipe</span>)：</p>
      <blockquote class="Tip">
        <blockquote class="SCentered">
          <p><span style="font-weight: bold">解释器秘方</span>
            <a name="(idx._(gentag._219))"></a>
          </p>
        </blockquote>
        <blockquote class="TipContent">
          <ol>
            <li>
              <p>查看一段数据。</p>
            </li>
            <li>
              <p>判断它表示什么样的数据。</p>
            </li>
            <li>
              <p>提取数据的各个部分，对它们做适当操作。</p>
            </li>
          </ol>
        </blockquote>
      </blockquote>
      <p>
      <div class="SIntrapara">
        <blockquote class="EoplFigure">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="texMathInline">\mathit{Env} = <span class="stt">(empty-env)</span> \mid <span
                      class="stt">(extend-env </span><span class="texMathInline">\mathit{Var}</span><span class="stt">
                    </span><span class="texMathInline">\mathit{SchemeVal}</span><span class="stt"> </span><span
                      class="texMathInline">\mathit{Env}</span><span class="stt">)</span></span></td>
              </tr>
              <tr>
                <td><span class="texMathInline">\mathit{Var} = \mathit{Sym}</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><a name="(idx._(gentag._220))"></a></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">empty-env</span></span> : <span
                    class="texMathInline">() \to \mathit{Env}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">empty-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">)</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">list</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">empty-env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><a name="(idx._(gentag._221))"></a></td>
              </tr>
              <tr>
                <td><a name="(idx._(gentag._222))"></a></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">extend-env</span></span> : <span
                    class="texMathInline">\mathit{Var} \times \mathit{SchemeVal} \times \mathit{Env} \to
                    \mathit{Env}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">extend-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">var</span><span
                    class="hspace"> </span><span class="RktSym">val</span><span class="hspace"> </span><span
                    class="RktSym">env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">list</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">extend-env</span><span
                    class="hspace"> </span><span class="RktSym">var</span><span class="hspace"> </span><span
                    class="RktSym">val</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><a name="(idx._(gentag._223))"></a></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">apply-env</span></span> : <span
                    class="texMathInline">\mathit{Env} \times \mathit{Var} \to \mathit{SchemeVal}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">apply-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">env</span><span
                    class="hspace"> </span><span class="RktSym">search-var</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cond</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">eqv?</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">empty-env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">report-no-binding-found</span><span class="hspace"> </span><span
                    class="RktSym">search-var</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">eqv?</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">extend-env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">saved-var</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">cadr</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">saved-val</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">caddr</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">saved-env</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">cadddr</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">eqv?</span><span class="hspace"> </span><span class="RktSym">search-var</span><span
                    class="hspace"> </span><span class="RktSym">saved-var</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktSym">saved-val</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">apply-env</span><span class="hspace"> </span><span
                    class="RktSym">saved-env</span><span class="hspace"> </span><span
                    class="RktSym">search-var</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">else</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">report-invalid-env</span><span class="hspace"> </span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">report-no-binding-found</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">search-var</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">eopl:error</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">apply-env</span><span class="hspace"> </span><span class="RktVal">"~s未绑定"</span><span
                    class="hspace"> </span><span class="RktSym">search-var</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">report-invalid-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">env</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">eopl:error</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">apply-env</span><span class="hspace"> </span><span class="RktVal">"非法环境:
                    ~s"</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
          <blockquote class="caption">
            <p>环境的数据结构表示<a name="(elem._fig-2..1)"></a></p>
          </blockquote>
        </blockquote>
      </div>
      <div class="SIntrapara"><a name="(idx._(gentag._224))"></a>
        <a name="(idx._(gentag._225))"></a>
      </div>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..5)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._226))"></a>
          <a name="(idx._(gentag._227))"></a>
          <a name="(idx._(gentag._228))"></a>
          <a name="(idx._(gentag._229))"></a>
          只要能区分空环境和非空环境，并能从后者中提取出数据片段，就能用任何数据结构表示环
          境。按这种方式实现环境：空环境由空列表表示，<span class="stt">extend-env</span>生成如下环境：
        </p>
        <blockquote class="SubFlow">
          <blockquote class="SCentered">
            <p><img src="alist-env.svg" alt="关联列表表示法" width="216.0pt" height="104.4pt" /></p>
          </blockquote>
          <p><a name="(idx._(gentag._230))"></a>
            <a name="(idx._(gentag._231))"></a>
            这叫 <span class="emph">a-list</span> 或<span class="emph">关联列表</span> (<span
              class="emph">association-list</span>) 表示法。
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..6)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>发明三种以上的环境接口表示，给出实现。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..7)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>重写<span class="EoplFigureRef"></span> 中的 <span
            class="stt">apply-env</span>，给出更详细的错误信息。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..8)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._232))"></a>
          <a name="(idx._(gentag._233))"></a>
          给环境接口添加观测器 <span class="stt">empty-env?</span>，用 a-list 表示法实现它。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..9)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>给环境接口添加观测器 <span class="stt">has-binding?</span>，它取一环境 <span
            class="texMathInline">env</span>，一个变量 <span class="texMathInline">s</span>，判断
          <span class="texMathInline">s</span> 在 <span class="texMathInline">env</span> 中是否有绑定值。用 a-list 表示法实现它。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..10)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._234))"></a>
          给环境接口添加构造器 <span class="stt">extend-env*</span>，用 a-list 表示法实现它。这个构造器取一变
          量列表和一长度相等的值列表，以及一环境，其定义为：</p>
        <p><span class="Iidentity">\begin{align*}& <span class="stt">(extend-env* (</span><span
              class="Iidentity">var_1</span><span class="stt"> </span><span class="Iidentity">\dots</span><span
              class="stt"> </span><span class="Iidentity">var_k</span><span class="stt">) (</span><span
              class="Iidentity">val_1</span><span class="stt"> </span><span class="Iidentity">\dots</span><span
              class="stt"> </span><span class="Iidentity">var_k</span><span class="stt">) </span><span
              class="Iidentity">\lceil f \rceil</span><span class="stt">)</span> = \lceil g \rceil, \\
            & \quad 其中，g(var) =
            <span class="Iidentity">\begin{cases}val_i & 若 \ var = var_i \ 对某个 \ i \ 成立，1 \leqslant i \leqslant k \\
              f(var) & 否则\end{cases}</span>\end{align*}</span>
          <a name="(idx._(gentag._235))"></a>
          <a name="(idx._(gentag._236))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..11)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>前一题中的
          <span class="stt">extend-env*</span> 实现比较拙劣的话，运行时间与 <span class="texMathInline">k</span> 成正比。有一种表
          示可使 <span class="stt">extend-env*</span> 的运行时间为常数：用空列表表示空环境，用下面的数据结构表
          示非空环境：</p>
        <blockquote class="SCentered">
          <p><img src="rib-cage-one.svg" alt="肋排环境表示法片段" width="201.6pt" height="102.6pt" /></p>
        </blockquote>
        <blockquote class="SubFlow">
          <p>那么一个环境看起来像是这样：</p>
          <blockquote class="SCentered">
            <p><img src="rib-cage.svg" alt="肋排环境表示法" width="522.0pt" height="156.0pt" /></p>
          </blockquote>
          <p><a name="(idx._(gentag._237))"></a>
            <a name="(idx._(gentag._238))"></a>
            这叫做<span class="emph">肋排</span> (<span class="emph">ribcage</span>) 表示法。环境由名为<span class="emph">肋骨</span>
            (<span class="emph">rib</span>) 的序对列表表示；
            每根左肋是变量列表，右肋是对应的值列表。
          </p>
          <p>用这种表示实现 <span class="stt">extend-env*</span> 和其他环境接口。
            <a name="(idx._(gentag._239))"></a>
            <a name="(idx._(gentag._240))"></a>
            <a name="(idx._(gentag._241))"></a>
          </p>
        </blockquote>
      </blockquote>
      <h5>2.2.3<tt> </tt><a name="(part._s2..2..3)"></a>过程表示法</h5>
      <p><a name="(idx._(gentag._242))"></a>
        <a name="(idx._(gentag._243))"></a>
        环境接口有一条重要性质：它只有 <span class="stt">apply-env</span> 一个观测器。这样就能用取一变量，返
        回绑定值的 Scheme 过程表示环境。
      </p>
      <p>要这样表示，定义 <span class="stt">empty-env</span> 和 <span class="stt">extend-env</span> 的返回值为过程，调用二者的返
        回值就如同调用上一节的 <span class="stt">apply-env</span> 一样。由此得出下面的实现。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="texMathInline">\mathit{Env} = \mathit{Var} \to \mathit{SchemeVal}</span></td>
            </tr>
            <tr>
              <td><span class="texMathInline">\mathit{Var} = \mathit{Sym}</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><a name="(idx._(gentag._244))"></a></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">empty-env</span></span> : <span
                  class="texMathInline">() \to \mathit{Env}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">empty-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">search-var</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">report-no-binding-found</span><span class="hspace"> </span><span
                  class="RktSym">search-var</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><a name="(idx._(gentag._245))"></a></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">extend-env</span></span> : <span
                  class="texMathInline">\mathit{Var} \times \mathit{SchemeVal} \times \mathit{Env} \to
                  \mathit{Env}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">extend-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">saved-var</span><span
                  class="hspace"> </span><span class="RktSym">saved-val</span><span class="hspace"> </span><span
                  class="RktSym">saved-env</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">search-var</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">eqv?</span><span
                  class="hspace"> </span><span class="RktSym">search-var</span><span class="hspace"> </span><span
                  class="RktSym">saved-var</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktSym">saved-val</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">apply-env</span><span class="hspace"> </span><span class="RktSym">saved-env</span><span
                  class="hspace"> </span><span class="RktSym">search-var</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><a name="(idx._(gentag._246))"></a></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">apply-env</span></span> : <span
                  class="texMathInline">\mathit{Env} \times \mathit{Var} \to \mathit{SchemeVal}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">apply-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">env</span><span
                  class="hspace"> </span><span class="RktSym">search-var</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">env</span><span
                  class="hspace"> </span><span class="RktSym">search-var</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p><span class="stt">empty-env</span> 创建的空环境收到任何变量都会报错，表明给定的变量不在其中。过程
        <span class="stt">extend-env</span> 返回的过程代表扩展而得的环境。这个过程收到变量 <span class="stt">search-var</span>
        后，判断该变量是否与环境中绑定的相同。如果相同，就返回保存的值；否则，就在保存的
        环境中查找它。
      </p>
      <p>这种表示法中，数据由 <span class="stt">apply-env</span> <span class="emph">执行的动作</span>表示，我们称之
        为<span class="emph">过程表示法</span> (<span class="emph">procedural representation</span>)。</p>
      <p>数据类型只有一个观测器的情形并非想象中那般少见。比如，当数据是一组函数，就能用调
        用时执行的动作<a name="(idx._(gentag._247))"></a>表示。这种情况下，可以按照下
        列步骤提炼出接口和过程表示法：</p>
      <ol>
        <li>
          <p>找出客户代码中求取指定类型值的 lambda 表达式。为每个这样的 lambda 表达式
            写一个构造器过程。构造器过程的参数用作 lambda 表达式中的自由变量。在客户代码中，
            用构造器调用替换对应的 lambda 表达式。</p>
        </li>
        <li>
          <p>像定义 <span class="stt">apply-env</span> 那样定义一个 <span class="stt">apply-</span> 过程。找出客户代码中所有使
            用指定类型值的地方，包括构造器过程的主体。所有使用指定类型值的地方都改用
            <span class="stt">apply-</span> 过程。
          </p>
        </li>
      </ol>
      <p><a name="(idx._(gentag._248))"></a>
        一旦完成这些步骤，接口就包含所有的构造器过程和 <span class="stt">apply-</span> 过程，客户代码则与表
        示无关：它不再依赖表示，我们将能随意换用另一套接口实现，正如 <a href="#%28part._s2..2..2%29" data-pltdoc="x">数据结构表示法</a>所述。</p>
      <p>如果用于实现的语言不支持高阶过程，那就得再做一些步骤，用数据结构表示法和解释器秘
        方实现所需接口，就像上一节那样。这一操作叫做<span class="emph">消函</span> (<span class="emph">defunctionalization</span>)。
        <a name="(idx._(gentag._249))"></a>
        环境的数据结构表示中，各种变体都是消函的简单例子。过程表示法和消函表示法的关系将
        是本书反复出现的主题。
        <a name="(idx._(gentag._250))"></a>
        <a name="(idx._(gentag._251))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..12)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._252))"></a>
          <a name="(idx._(gentag._253))"></a>
          <a name="(idx._(gentag._254))"></a>
          <a name="(idx._(gentag._255))"></a>
          用过程表示法实现<span class="EoplExerciseRef"></span> 中的栈数据类型。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..13)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>扩展过程表示法，用两个过程组成的列表表示环境，实现 <span class="stt">empty-env?</span>。一个过程像前
          面那样，返回变量的绑定值；一个返回环境是否为空。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..14)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>扩展前一题中的表示法，加入第三个过程，用它来 <span class="stt">has-binding?</span> （见
          <span class="EoplExerciseRef"></span>）。
          <a name="(idx._(gentag._256))"></a>
          <a name="(idx._(gentag._257))"></a>
        </p>
      </blockquote>
      <h4>2.3<tt> </tt><a name="(part._s2..3)"></a>递推数据类型的接口</h4>
      <p><a name="(idx._(gentag._258))"></a>
        <a href="isd.html" data-pltdoc="x">归纳式数据集</a>大部分都在处理递推数据类型。例如，<span class="EoplDefinitionRef"></span> 给出了
        lambda 演算表达式的语法：
      </p>
      <p><span class="Iidentity">\begin{align*}\mathit{Lc\text{-}Exp}
          &::= \mathit{Identifier} \\
          &::= \normalfont{<span class="stt">(lambda (</span><span class="Iidentity">\mathit{Identifier}</span><span
            class="stt">) </span><span class="Iidentity">\mathit{Lc\text{-}Exp}</span><span class="stt">)</span>} \\
          &::= \normalfont{<span class="stt">(</span><span class="Iidentity">\mathit{Lc\text{-}Exp}</span><span
            class="stt"> </span><span class="Iidentity">\mathit{Lc\text{-}Exp}</span><span
            class="stt">)</span>}\end{align*}</span></p>
      <p>我们还写出了过程 <span class="stt">occurs-free?</span>。像当时提到的，<a href="isd.html#%28part._s1..2..4%29"
          data-pltdoc="x"><span class="stt">occurs-free?</span></a>中
        <span class="stt">occurs-free?</span> 的定义不大容易读懂。比如，很难搞明白 <span class="stt">(car (cadr exp))</span> 指
        代 <span class="stt">lambda</span> 表达式中的变量声明，或者 <span class="stt">(caddr exp)</span> 指代表达式的主体。
      </p>
      <p><a name="(idx._(gentag._259))"></a>
        要改善这种情况，可以给 lambda 演算表达式添加一套接口。我们的接口有几个构造器，以
        及两种观测器：谓词和提取器。</p>
      <p>构造器有：</p>
      <blockquote>
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span style="font-weight: bold"><span class="stt">var-exp</span></span><span class="stt">: </span><span
                  class="texMathInline">\mathit{Var} \to \mathit{Lc\text{-}Exp}</span><span class="stt"></span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span style="font-weight: bold"><span
                    class="stt">lambda-exp</span></span><span class="stt">: </span><span
                  class="texMathInline">\mathit{Var} \times \mathit{Lc\text{-}Exp} \to
                  \mathit{Lc\text{-}Exp}</span><span class="stt"></span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span style="font-weight: bold"><span class="stt">app-exp</span></span><span
                  class="stt">: </span><span class="texMathInline">\mathit{Lc\text{-}Exp} \times \mathit{Lc\text{-}Exp}
                  \to \mathit{Lc\text{-}Exp}</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>谓词有：</p>
      <blockquote>
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span style="font-weight: bold"><span class="stt">var-exp?</span></span><span class="stt">:
                </span><span class="texMathInline">\mathit{Lc\text{-}Exp} \to \mathit{Bool}</span><span
                  class="stt"></span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span style="font-weight: bold"><span
                    class="stt">lambda-exp?</span></span><span class="stt">: </span><span
                  class="texMathInline">\mathit{Lc\text{-}Exp} \to \mathit{Bool}</span><span class="stt"></span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span style="font-weight: bold"><span class="stt">app-exp?</span></span><span
                  class="stt">: </span><span class="texMathInline">\mathit{Lc\text{-}Exp} \to \mathit{Bool}</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p><a name="(idx._(gentag._260))"></a>
        提取器有：</p>
      <blockquote>
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span style="font-weight: bold"><span class="stt">var-exp->var</span></span><span class="stt">:
                </span><span class="texMathInline">\mathit{Lc\text{-}Exp} \to \mathit{Var}</span><span
                  class="stt"></span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span style="font-weight: bold"><span
                    class="stt">lambda-exp->bound-var</span></span><span class="stt">: </span><span
                  class="texMathInline">\mathit{Lc\text{-}Exp} \to \mathit{Var}</span><span class="stt"></span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span style="font-weight: bold"><span
                    class="stt">lambda-exp->body</span></span><span class="stt">: </span><span
                  class="texMathInline">\mathit{Lc\text{-}Exp} \to \mathit{Lc\text{-}Exp}</span><span
                  class="stt"></span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span style="font-weight: bold"><span
                    class="stt">app-exp->rator</span></span><span class="stt">: </span><span
                  class="texMathInline">\mathit{Lc\text{-}Exp} \to \mathit{Lc\text{-}Exp}</span><span
                  class="stt"></span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span style="font-weight: bold"><span
                    class="stt">app-exp->rand</span></span><span class="stt">: </span><span
                  class="texMathInline">\mathit{Lc\text{-}Exp} \to \mathit{Lc\text{-}Exp}</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>每个提取器对应 lambda 演算表达式中的一部分。现在可以写出一版只依赖接口的
        <span class="stt">occurs-free?</span>。
      </p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara"><a name="(idx._(gentag._261))"></a>
        </div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><a name="(elem._occurs-free~3f)"></a><span style="font-weight: bold"><span
                      class="stt">occurs-free?</span></span> : <span class="texMathInline">\mathit{Sym} \times
                    \mathit{LcExp} \to \mathit{Bool}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">occurs-free?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">search-var</span><span
                    class="hspace"> </span><span class="RktSym">exp</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cond</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">var-exp?</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">eqv?</span><span class="hspace"> </span><span class="RktSym">search-var</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">var-exp->var</span><span
                    class="hspace"> </span><span class="RktSym">exp</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">lambda-exp?</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">and</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">not</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">eqv?</span><span class="hspace"> </span><span class="RktSym">search-var</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">lambda-exp->bound-var</span><span class="hspace"> </span><span
                    class="RktSym">exp</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                    class="RktSym">search-var</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">lambda-exp->body</span><span class="hspace"> </span><span
                    class="RktSym">exp</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">else</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">or</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                    class="RktSym">search-var</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">app-exp->rator</span><span class="hspace"> </span><span
                    class="RktSym">exp</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                    class="RktSym">search-var</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">app-exp->rand</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._262))"></a></div>
        </p>
      </blockquote>
      <p>只要使用上述构造器，怎样表示 lambda 演算表达式都可以。
        <a name="(idx._(gentag._263))"></a>
      </p>
      <p><a name="(idx._(gentag._264))"></a>
        我们可以写出设计递推数据类型接口的一般步骤：</p>
      <blockquote class="Tip">
        <blockquote class="SCentered">
          <p><span style="font-weight: bold">设计递推数据类型的接口</span></p>
        </blockquote>
        <blockquote class="TipContent">
          <ol>
            <li>
              <p>为数据类型的每种变体加入一个构造器。</p>
            </li>
            <li>
              <p>为数据类型的每种变体加入一个谓词。</p>
            </li>
            <li>
              <p>为传给数据类型构造器的每段数据加入一个提取器。
                <a name="(idx._(gentag._265))"></a>
                <a name="(idx._(gentag._266))"></a>
              </p>
            </li>
          </ol>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..15)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._267))"></a>
          上述语法指定了 lambda 演算表达式的表示方式，实现其接口。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..16)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>修改实现，换用另一种表示，去掉 <span class="stt">lambda</span> 表达式绑定变量周围的括号。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..17)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>再发明至少两种方式来表示数据类型 lambda 演算表达式，实现它们。
          <a name="(idx._(gentag._268))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..18)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._269))"></a>
          <a name="(idx._(gentag._270))"></a>
          我们常用列表表示值的序列。在这种表示法中，很容易从序列中的一个元素移动到下一个，
          但是不借助上下文参数，很难从一个元素移动到上一个。实现非空双向整数序列，语法为：
        </p>
        <p><span class="Iidentity">\[\mathit{NodeInSequence} ::= <span class="stt">(</span><span
              class="Iidentity">\mathit{Int}</span><span class="stt">
            </span><span class="Iidentity">\mathit{Listof<span class="stt">(</span><span
                class="Iidentity">\mathit{Int}</span><span class="stt">)</span>}</span><span class="stt"> </span><span
              class="Iidentity">\mathit{Listof<span class="stt">(</span><span class="Iidentity">\mathit{Int}</span><span
                class="stt">)</span>}</span><span class="stt">)</span>\]</span></p>
        <p>第一个整数列表是当前元素之前的序列，反向排列。第二个列表是当前元素之后的序列。例
          如，<span class="stt">(6 (5 4 3 2 1) (7 8 9))</span> 表示列表 <span class="stt">(1 2 3 4 5 6 7 8 9)</span>，当前元素为6。
        </p>
        <p>用这种表示实现过程 <span class="stt">number->sequence</span>，它取一数字，生成只包含该数字的序列。接
          着实现 <span class="stt">current-element</span>、<span class="stt">move-to-left</span>、<span
            class="stt">move-to-right</span>、
          <span class="stt">insert-to-left</span>、<span class="stt">insert-to-right</span>、<span
            class="stt">at-left-end?</span> 和
          <span class="stt">at-right-end?</span>。
        </p>
        <p>例如：</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">number->sequence</span><span class="hspace"> </span><span
                    class="RktVal">7</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(7<span class="stt"> </span>()<span class="stt"> </span>())</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">current-element</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">(</span><span class="RktVal">6</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">5</span><span class="hspace"> </span><span
                    class="RktVal">4</span><span class="hspace"> </span><span class="RktVal">3</span><span
                    class="hspace"> </span><span class="RktVal">2</span><span class="hspace"> </span><span
                    class="RktVal">1</span><span class="RktVal">)</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">7</span><span class="hspace"> </span><span
                    class="RktVal">8</span><span class="hspace"> </span><span class="RktVal">9</span><span
                    class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">6</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">move-to-left</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">6</span><span class="hspace"> </span><span class="RktVal">(</span><span
                    class="RktVal">5</span><span class="hspace"> </span><span class="RktVal">4</span><span
                    class="hspace"> </span><span class="RktVal">3</span><span class="hspace"> </span><span
                    class="RktVal">2</span><span class="hspace"> </span><span class="RktVal">1</span><span
                    class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">(</span><span
                    class="RktVal">7</span><span class="hspace"> </span><span class="RktVal">8</span><span
                    class="hspace"> </span><span class="RktVal">9</span><span class="RktVal">)</span><span
                    class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(5<span class="stt"> </span>(4<span class="stt"> </span>3<span class="stt">
                      </span>2<span class="stt"> </span>1)<span class="stt"> </span>(6<span class="stt"> </span>7<span
                        class="stt"> </span>8<span class="stt"> </span>9))</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">move-to-right</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">(</span><span class="RktVal">6</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">5</span><span class="hspace"> </span><span
                    class="RktVal">4</span><span class="hspace"> </span><span class="RktVal">3</span><span
                    class="hspace"> </span><span class="RktVal">2</span><span class="hspace"> </span><span
                    class="RktVal">1</span><span class="RktVal">)</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">7</span><span class="hspace"> </span><span
                    class="RktVal">8</span><span class="hspace"> </span><span class="RktVal">9</span><span
                    class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(7<span class="stt"> </span>(6<span class="stt"> </span>5<span class="stt">
                      </span>4<span class="stt"> </span>3<span class="stt"> </span>2<span class="stt"> </span>1)<span
                        class="stt"> </span>(8<span class="stt"> </span>9))</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">insert-to-left</span><span class="hspace"> </span><span class="RktVal">13</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">6</span><span class="hspace"> </span><span class="RktVal">(</span><span
                    class="RktVal">5</span><span class="hspace"> </span><span class="RktVal">4</span><span
                    class="hspace"> </span><span class="RktVal">3</span><span class="hspace"> </span><span
                    class="RktVal">2</span><span class="hspace"> </span><span class="RktVal">1</span><span
                    class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">(</span><span
                    class="RktVal">7</span><span class="hspace"> </span><span class="RktVal">8</span><span
                    class="hspace"> </span><span class="RktVal">9</span><span class="RktVal">)</span><span
                    class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(6<span class="stt"> </span>(13<span class="stt"> </span>5<span class="stt">
                      </span>4<span class="stt"> </span>3<span class="stt"> </span>2<span class="stt"> </span>1)<span
                        class="stt"> </span>(7<span class="stt"> </span>8<span class="stt"> </span>9))</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">insert-to-right</span><span class="hspace"> </span><span
                    class="RktVal">13</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">(</span><span class="RktVal">6</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">5</span><span class="hspace"> </span><span
                    class="RktVal">4</span><span class="hspace"> </span><span class="RktVal">3</span><span
                    class="hspace"> </span><span class="RktVal">2</span><span class="hspace"> </span><span
                    class="RktVal">1</span><span class="RktVal">)</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">7</span><span class="hspace"> </span><span
                    class="RktVal">8</span><span class="hspace"> </span><span class="RktVal">9</span><span
                    class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(6<span class="stt"> </span>(5<span class="stt"> </span>4<span class="stt">
                      </span>3<span class="stt"> </span>2<span class="stt"> </span>1)<span class="stt"> </span>(13<span
                        class="stt"> </span>7<span class="stt"> </span>8<span class="stt"> </span>9))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>如果参数在序列最右端，过程<span class="stt">move-to-right</span>应失败。如果参数在序列最左端，过程
          <span class="stt">move-to-left</span>应失败。
          <a name="(idx._(gentag._271))"></a>
          <a name="(idx._(gentag._272))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..19)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._273))"></a>
          空二叉树和用整数标记内部节点的二叉树可以用语法表示为：</p>
        <p><span class="Iidentity">\[\mathit{BinTree} ::= <span class="stt">()</span> \mid <span
              class="stt">(</span><span class="Iidentity">\mathit{Int}</span><span class="stt"> </span><span
              class="Iidentity">\mathit{BinTree}</span><span class="stt">
            </span><span class="Iidentity">\mathit{BinTree}</span><span class="stt">)</span>\]</span></p>
        <p>用这种表示实现过程 <span class="stt">number->bintree</span>，它取一个整数，产生一棵新的二叉树，树的
          唯一节点包含该数字。接着实现 <span class="stt">current-element</span>、<span class="stt">move-to-left-son</span>、
          <span class="stt">move-to-right-son</span>、<span class="stt">at-leaf?</span>、<span
            class="stt">insert-to-left</span> 和
          <span class="stt">insert-to-right</span>。例如：
        </p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">number->bintree</span><span class="hspace"> </span><span
                    class="RktVal">13</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(13<span class="stt"> </span>()<span class="stt"> </span>())</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <table cellspacing="0" cellpadding="0" class="RktBlk">
                    <tr>
                      <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">define</span><span
                          class="hspace"> </span><span class="RktSym">t1</span><span class="hspace"> </span><span
                          class="RktPn">(</span><span class="RktSym">insert-to-right</span><span
                          class="hspace"> </span><span class="RktVal">14</span></td>
                    </tr>
                    <tr>
                      <td><span class="hspace">  </span><span class="hspace">             </span><span
                          class="RktPn">(</span><span class="RktSym">insert-to-left</span><span
                          class="hspace"> </span><span class="RktVal">12</span></td>
                    </tr>
                    <tr>
                      <td><span class="hspace">  </span><span class="hspace">               </span><span
                          class="RktPn">(</span><span class="RktSym">number->bintree</span><span
                          class="hspace"> </span><span class="RktVal">13</span><span class="RktPn">)</span><span
                          class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
                    </tr>
                  </table>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktSym">t1</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(13<span class="stt"> </span>(12<span class="stt"> </span>()<span
                        class="stt"> </span>())<span class="stt"> </span>(14<span class="stt"> </span>()<span
                        class="stt"> </span>()))</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">move-to-left-son</span><span class="hspace"> </span><span
                    class="RktSym">t1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(12<span class="stt"> </span>()<span class="stt"> </span>())</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">current-element</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">move-to-left-son</span><span class="hspace"> </span><span
                    class="RktSym">t1</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">12</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">at-leaf?</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">move-to-right-son</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">move-to-left-son</span><span class="hspace"> </span><span
                    class="RktSym">t1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">#t</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">insert-to-left</span><span class="hspace"> </span><span class="RktVal">15</span><span
                    class="hspace"> </span><span class="RktSym">t1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(13<span class="stt"> </span>(15<span class="stt"> </span>(12<span
                        class="stt"> </span>()<span class="stt"> </span>())<span class="stt"> </span>())<span
                        class="stt"> </span>(14<span class="stt"> </span>()<span class="stt"> </span>()))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..20)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>按照<span class="EoplExerciseRef"></span> 中的二叉树表示，很容易从父节点移到某个子节点，但是不借
          助上下文参数，无法从子节点移动到父节点。扩展<span class="EoplExerciseRef"></span> 中的列表表示法，
          用以表示二叉树中的节点。提示：想想怎样用逆序列表表示二叉树在当前节点以上的部分，
          就像<span class="EoplExerciseRef"></span> 那样。</p>
        <p>用这种表示实现<span class="EoplExerciseRef"></span> 中的过程。接着实现 <span class="stt">move-up</span> 和
          <span class="stt">at-root?</span>。
        </p>
      </blockquote>
      <h4>2.4<tt> </tt><a name="(part._s2..4)"></a>定义递推数据类型的工具</h4>
      <p><a name="(idx._(gentag._274))"></a>
        对复杂的数据类型，按照上述步骤设计接口很快就会使人厌倦。本节介绍用 Scheme 自动设
        计和实现接口的工具。这个工具产生的接口与前一节的虽不完全相同，却很类似。</p>
      <p><a name="(idx._(gentag._275))"></a>
        <a name="(idx._(gentag._276))"></a>
        仍考虑前一节讨论的数据类型 lambda 演算表达式。lambda 演算表达式的接口可以这样写：
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><a name="(elem._lc-exp)"></a><span
                  class="RktSym">define-datatype</span><span class="hspace"> </span><span
                  class="RktSym">lc-exp</span><span class="hspace"> </span><span class="RktSym">lc-exp?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">var-exp</span></td>
            </tr>
            <tr>
              <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">var</span><span
                  class="hspace"> </span><span class="RktSym">identifier?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda-exp</span></td>
            </tr>
            <tr>
              <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">bound-var</span><span
                  class="hspace"> </span><span class="RktSym">identifier?</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">body</span><span
                  class="hspace"> </span><span class="RktSym">lc-exp?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">app-exp</span></td>
            </tr>
            <tr>
              <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">rator</span><span
                  class="hspace"> </span><span class="RktSym">lc-exp?</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">rand</span><span
                  class="hspace"> </span><span class="RktSym">lc-exp?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>这里的名字 <span class="stt">var-exp</span>、<span class="stt">var</span>、<span class="stt">bound-var</span>、<span
          class="stt">app-exp</span>、<span class="stt">rator</span> 和
        <span class="stt">rand</span> 分别是 <span class="emph">变量表达式</span> (<span class="emph">variable
          expression</span>)、<span class="emph">变
          量</span> (<span class="emph">variable</span>)、<span class="emph">绑定变量</span> (<span class="emph">bound
          variable</span>)、<span class="emph">调用表达
          式</span> (<span class="emph">application expression</span>)、<span class="emph">操作符</span> (<span
          class="emph">operator</span>) 和<span class="emph">操作数</span> (<span class="emph">operand</span>) 的缩写。
      </p>
      <p>这些表达式声明了三种构造器：<span class="stt">var-exp</span>、<span class="stt">lambda-exp</span> 和 <span
          class="stt">app-exp</span>，以及
        一个谓词 <span class="stt">lc-exp?</span>。三个构造器用谓词 <span class="stt">identifier?</span> 和 <span
          class="stt">lc-exp?</span> 检查它
        们的参数，确保参数合法。所以，如果生成 lc-exp 时只用这些构造器，可以确保表达式及
        其所有子表达式合法。如此一来，处理 lambda 表达式时就能跳过许多检查。</p>
      <p><a name="(idx._(gentag._277))"></a>
        <a name="(idx._(gentag._278))"></a>
        我们用形式 <span class="stt">cases</span> 代替谓词和提取器，判断数据类型的实例属于哪种变体，并提取出
        它的组件。为解释这一形式，我们用数据类型 <span class="stt">lc-exp</span> 重写
        <span class="stt">occurs-free?</span>（<span class="stt">occurs-free?</span>）：
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="texMathInline"><span style="font-weight: bold"><span
                      class="stt">occurs-free?</span></span> : \mathit{Sym} \times \mathit{LcExp} \to
                  \mathit{Bool}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">occurs-free?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">search-var</span><span
                  class="hspace"> </span><span class="RktSym">exp</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">lc-exp</span><span class="hspace"> </span><span
                  class="RktSym">exp</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">var-exp</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">var</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">eqv?</span><span class="hspace"> </span><span class="RktSym">var</span><span
                  class="hspace"> </span><span class="RktSym">search-var</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">lambda-exp</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">bound-var</span><span class="hspace"> </span><span class="RktSym">body</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">and</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span class="RktSym">not</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">eqv?</span><span
                  class="hspace"> </span><span class="RktSym">search-var</span><span class="hspace"> </span><span
                  class="RktSym">bound-var</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                  class="RktSym">search-var</span><span class="hspace"> </span><span class="RktSym">body</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">app-exp</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">rator</span><span
                  class="hspace"> </span><span class="RktSym">rand</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">or</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                  class="RktSym">search-var</span><span class="hspace"> </span><span class="RktSym">rator</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                  class="RktSym">search-var</span><span class="hspace"> </span><span class="RktSym">rand</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>要理解它，假设 <span class="stt">exp</span> 是由 <span class="stt">app-exp</span> 生成的 lambda 演算表达式。根据
        <span class="stt">exp</span> 的取值，分支 <span class="stt">app-exp</span> 将被选中，<span class="stt">rator</span> 和 <span
          class="stt">rand</span> 则绑定到两
        个子表达式，接着，表达式
      </p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">or</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                    class="RktSym">search-var</span><span class="hspace"> </span><span class="RktSym">rator</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                    class="RktSym">search-var</span><span class="hspace"> </span><span class="RktSym">rand</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>将会求值，就像我们写：</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">app-exp?</span><span class="hspace"> </span><span
                    class="RktSym">exp</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">rator</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">app-exp->rator</span><span class="hspace"> </span><span
                    class="RktSym">exp</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">rand</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">app-exp->rand</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">or</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                    class="RktSym">search-var</span><span class="hspace"> </span><span class="RktSym">rator</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                    class="RktSym">search-var</span><span class="hspace"> </span><span class="RktSym">rand</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="RktSym">...</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>递归调用 <span class="stt">occurs-free?</span> 像这样完成运算。
          <a name="(idx._(gentag._279))"></a>
        </p>
      </blockquote>
      <p>一般的 <span class="stt">define-datatype</span> 声明形如：</p>
      <blockquote class="SubFlow">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><a name="(elem._define-datatype)"></a><span
                  class="RktSym">define-datatype</span><span class="hspace"> </span><span
                  class="texMathInline">type\text{-}name</span><span class="hspace"> </span><span
                  class="texMathInline">type\text{-}predicate\text{-}name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="texMathInline">\{<span
                    class="stt">(</span>variant\text{-}name \quad \{<span class="stt">(</span>filed\text{-}name \quad
                  predicate<span class="stt">)</span>\}^{*} <span class="stt">)</span>\}^{+}</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>这新定义了一种数据类型，名为 <span class="texMathInline">type\text{-}name</span>，它有一些<span class="emph">变
          体</span> (<span class="emph">variants</span>)。<a name="(idx._(gentag._280))"></a>每个变体有一变体名，以及 0 或多个字段，每个字段各有其
        字段名和相应的谓词。不论是否属于不同的类型，变体都不能重名。类型也不能重名，且类
        型名不能用作变体名。每个字段的谓词必须是一个 Scheme 谓词。</p>
      <p>每个变体都有一个构造器过程，用于创建该变体的值。这些过程的名字与对应的变体相同。
        如果一个变体有 <span class="texMathInline">n</span> 个字段，那么它的构造器取 <span class="texMathInline">n</span> 个参数，用对应的谓词检查每个
        参数值，并返回变体值，值的第 <span class="texMathInline">i</span> 个字段为第 <span class="texMathInline">i</span> 个参数值。</p>
      <p><span class="texMathInline">type\text{-}predicate\text{-}name</span> 绑定到一个谓词。这个谓词判断其参数值是否是
        相应的类型。</p>
      <p><span class="emph">记录表</span> (<span class="emph">record</span>)<a name="(idx._(gentag._281))"></a>
        可以用只有一种变体的数据类型定义。
        为了区分只有一种变体的数据类型，我们遵循一种命名惯例：当只有一个变体时，我们以
        <span class="stt">a-</span><span class="texMathInline">type\text{-}name</span>
        <a name="(idx._(gentag._282))"></a>
        或 <span class="stt">an-</span><span class="texMathInline">type\text{-}name</span> 命名构造器；否则，以
        <span class="texMathInline">variant\text{-}name\text{-}type\text{-}name</span> 命名构造器。
      </p>
      <p><a name="(idx._(gentag._283))"></a>
        <a name="(idx._(gentag._284))"></a>
        <a name="(idx._(gentag._285))"></a>
        <a name="(idx._(gentag._286))"></a>
        由 <span class="stt">define-datatype</span> 生成的数据结构可以互递归。例如，<a href="isd.html#%28part._s1..1%29"
          data-pltdoc="x">递推定义的数据</a>中的 s-list
        语法为：
      </p>
      <p><span class="Iidentity">\begin{align*}\mathit{S\text{-}list} &::= {\normalfont{<span class="stt">(</span><span
            class="Iidentity">\{\mathit{S\text{-}exp}\}^{*}</span><span class="stt">)</span>}} \\
          \mathit{S\text{-}exp} &::= \mathit{Symbol} \mid \mathit{S\text{-}list}\end{align*}</span></p>
      <p>s-list中的数据可以用数据类型 <span class="stt">s-list</span>表示为：</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                  class="hspace"> </span><span class="RktSym">s-list</span><span class="hspace"> </span><span
                  class="RktSym">s-list?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">empty-s-list</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">non-empty-s-list</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">first</span><span
                  class="hspace"> </span><span class="RktSym">s-exp?</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">rest</span><span
                  class="hspace"> </span><span class="RktSym">s-list?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                  class="hspace"> </span><span class="RktSym">s-exp</span><span class="hspace"> </span><span
                  class="RktSym">s-exp?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">symbol-s-exp</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">sym</span><span
                  class="hspace"> </span><span class="RktSym">symbol?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">s-list-s-exp</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">slst</span><span
                  class="hspace"> </span><span class="RktSym">s-list?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>数据类型 <span class="stt">s-list</span> 用 <span class="stt">(empty-s-list)</span> 和 <span
          class="stt">non-empty-s-list</span> 代替
        <span class="stt">()</span> 和 <span class="stt">cons</span> 来表示列表。如果我们还想用 Scheme 列表，可以写成：
      </p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                    class="hspace"> </span><span class="RktSym">s-list</span><span class="hspace"> </span><span
                    class="RktSym">s-list?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">an-s-list</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">sexps</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">list-of</span><span
                    class="hspace"> </span><span class="RktSym">s-exp?</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">list-of</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">pred</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">val</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">or</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">null?</span><span
                    class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">and</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">pair?</span><span
                    class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">pred</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">val</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">list-of</span><span class="hspace"> </span><span class="RktSym">pred</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">val</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>这里 <span class="stt">(list-of </span><span class="texMathInline">pred</span><span class="stt">)</span>
          生成一个谓词，检查其参数值是否是一个列表，且列表的
          每个元素都满足 <span class="texMathInline">pred</span>。
          <a name="(idx._(gentag._287))"></a>
          <a name="(idx._(gentag._288))"></a>
        </p>
      </blockquote>
      <p><a name="(idx._(gentag._289))"></a>
        <span class="stt">cases</span> 语法的一般姓形式为：
      </p>
      <blockquote class="SubFlow">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">cases</span><span class="hspace"> </span><span
                  class="texMathInline">type\text{-}name</span><span class="hspace"> </span><span
                  class="texMathInline">expression</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="texMathInline">\{<span
                    class="stt">(</span>variant\text{-}name \phantom{x} <span
                    class="stt">(</span>\{filed\text{-}name\}^{*}<span class="stt">)</span> \phantom{x} consequent<span
                    class="stt">)</span>\}^{*}</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">else</span><span
                  class="hspace"> </span><span class="texMathInline">default</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
        <p>该形式指定类型，一个待求值和检查的表达式，以及一些从句。每个从句以指定类型的某一
          变体名及相应字段名为标识。<span class="stt">else</span> 从句可有可无。首先求 <span class="texMathInline">expression</span> 的值，得
          到 <span class="texMathInline">type\text{-}name</span> 的某个值 <span class="texMathInline">v</span>。如果 <span
            class="texMathInline">v</span> 是某个
          <span class="texMathInline">variant\text{-}name</span> 的变体，那就选中对应的从句。各 <span
            class="texMathInline">type\text{-}name</span> 绑定
          到 <span class="texMathInline">v</span> 中对应的字段值。然后在这些绑定的作用域内求取并返回 <span class="texMathInline">consequent</span>
          的值。
          如果 <span class="texMathInline">v</span> 不属于任何变体，且有 <span class="stt">else</span> 从句，则求取并返回 <span
            class="texMathInline">default</span> 的值。
          如果没有 <span class="stt">else</span> 从句，必须为指定数据类型的<span class="emph">每个</span>变体指定从句。
        </p>
      </blockquote>
      <p>形式 <span class="stt">cases</span> 根据位置绑定变量： 第 <span class="texMathInline">i</span> 个变量绑定到第 <span
          class="texMathInline">i</span> 个字段。所以，
        我们可以用：</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">app-exp</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">exp1</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp2</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">or</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">occurs-free?</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">search-var</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">exp1</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">occurs-free?</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">search-var</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">exp2</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>代替</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">app-exp</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">rator</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">rand</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">or</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">occurs-free?</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">search-var</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">rator</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">occurs-free?</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">search-var</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">rand</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <p><span class="stt">define-datatype</span> 和 <span class="stt">cases</span> 形式提供了一种简洁的方式来定义递推数据类型，
        但这种方式并不是唯一的。根据使用场景，可能得用专门的表示方式，它们利用数据的特殊
        性质，更紧凑或者更高效。获得这些优势的代价是必须动手实现接口中的过程。</p>
      <p><a name="(idx._(gentag._290))"></a>
        <span class="stt">define-datatype</span> 形式是<span class="emph">特定领域语言</span> (<span class="emph">domain-specific
          language</span>) 的例
        子。特定领域语言是一种小巧的语言，用来描述小而明确的任务中的单一任务。本例中的任
        务是定义一种递推数据类型。这种语言可能像 <span class="stt">define-datatype</span> 一样，存在于通用语
        言中；也可能是一门单独的语言，别有一套工具。一般来说，创造这类语言首先要找出任务
        的不同变体，然后设计语言，描述这些变体。这种策略通常非常有效。
        <a name="(idx._(gentag._291))"></a>
        <a name="(idx._(gentag._292))"></a>
        <a name="(idx._(gentag._293))"></a>
        <a name="(idx._(gentag._294))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..21)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._295))"></a>
          用 <span class="stt">define-datatype</span> 实现<a href="#%28part._s2..2..2%29"
            data-pltdoc="x">数据结构表示法</a>中的环境数据类型。然后
          实现<span class="EoplExerciseRef"></span> 中的 <span class="stt">has-binding?</span>。
          <a name="(idx._(gentag._296))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..22)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._297))"></a>
          用 <span class="stt">define-datatype</span> 实现<span class="EoplExerciseRef"></span> 中的栈数据类型。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..23)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._298))"></a>
          <span class="stt">lc-exp</span> 的定义忽略了<span class="EoplDefinitionRef"></span> 中的条件：
          “<span class="texMathInline">\mathit{Identifier}</span> 是除 <span class="stt">lambda</span> 之外的任何符号。
          ”修改 <span class="stt">identifier?</span> 的定义，补充这一条件。提示：任何谓词都能在
          <span class="stt">define-datatype</span> 中使用，你定义的也能。
          <a name="(idx._(gentag._299))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..24)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._300))"></a>
          这是用 <span class="stt">define-datatype</span> 表示的二叉树：</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                    class="hspace"> </span><span class="RktSym">bintree</span><span class="hspace"> </span><span
                    class="RktSym">bintree?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">leaf-node</span></td>
              </tr>
              <tr>
                <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">num</span><span
                    class="hspace"> </span><span class="RktSym">integer?</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">interior-node</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">key</span><span
                    class="hspace"> </span><span class="RktSym">symbol?</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">left</span><span
                    class="hspace"> </span><span class="RktSym">bintree?</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">right</span><span
                    class="hspace"> </span><span class="RktSym">bintree?</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>实现操作二叉树的过程 <span class="stt">bintree-to-list</span>，则 <span class="stt">(bintree-to-list</span><span
            class="stt">
          </span><span class="stt">(interior-node </span><span class="stt">’</span><span class="stt">a (leaf-node 3)
            (leaf-node 4)))</span> 应返回列表：</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">interior-node</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktSym">a</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">leaf-node</span><span
                    class="hspace"> </span><span class="RktVal">3</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">leaf-node</span><span
                    class="hspace"> </span><span class="RktVal">4</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..25)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._301))"></a>
          用 <span class="stt">cases</span> 写出 <span class="stt">max-interior</span>，它取至少有一个内部节点的整数二叉树（像前一
          道练习那样），返回叶子之和最大的内部节点对应的标签。</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td>
                  <table cellspacing="0" cellpadding="0" class="RktBlk">
                    <tr>
                      <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">define</span><span
                          class="hspace"> </span><span class="RktSym">tree-1</span></td>
                    </tr>
                    <tr>
                      <td><span class="hspace">  </span><span class="hspace">  </span><span class="RktPn">(</span><span
                          class="RktSym">interior-node</span><span class="hspace"> </span><span
                          class="RktVal">'</span><span class="RktVal">foo</span><span class="hspace"> </span><span
                          class="RktPn">(</span><span class="RktSym">leaf-node</span><span class="hspace"> </span><span
                          class="RktVal">2</span><span class="RktPn">)</span><span class="hspace"> </span><span
                          class="RktPn">(</span><span class="RktSym">leaf-node</span><span class="hspace"> </span><span
                          class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                          class="RktPn">)</span></td>
                    </tr>
                  </table>
                </td>
              </tr>
              <tr>
                <td>
                  <table cellspacing="0" cellpadding="0" class="RktBlk">
                    <tr>
                      <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">define</span><span
                          class="hspace"> </span><span class="RktSym">tree-2</span></td>
                    </tr>
                    <tr>
                      <td><span class="hspace">  </span><span class="hspace">  </span><span class="RktPn">(</span><span
                          class="RktSym">interior-node</span><span class="hspace"> </span><span
                          class="RktVal">'</span><span class="RktVal">bar</span><span class="hspace"> </span><span
                          class="RktPn">(</span><span class="RktSym">leaf-node</span><span class="hspace"> </span><span
                          class="RktVal"><span class="nobreak">-1</span></span><span class="RktPn">)</span><span
                          class="hspace"> </span><span class="RktSym">tree-1</span><span class="RktPn">)</span><span
                          class="RktPn">)</span></td>
                    </tr>
                  </table>
                </td>
              </tr>
              <tr>
                <td>
                  <table cellspacing="0" cellpadding="0" class="RktBlk">
                    <tr>
                      <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">define</span><span
                          class="hspace"> </span><span class="RktSym">tree-3</span></td>
                    </tr>
                    <tr>
                      <td><span class="hspace">  </span><span class="hspace">  </span><span class="RktPn">(</span><span
                          class="RktSym">interior-node</span><span class="hspace"> </span><span
                          class="RktVal">'</span><span class="RktVal">baz</span><span class="hspace"> </span><span
                          class="RktSym">tree-2</span><span class="hspace"> </span><span class="RktPn">(</span><span
                          class="RktSym">leaf-node</span><span class="hspace"> </span><span class="RktVal">1</span><span
                          class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
                    </tr>
                  </table>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">max-interior</span><span
                    class="hspace"> </span><span class="RktSym">tree-2</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'foo</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">max-interior</span><span
                    class="hspace"> </span><span class="RktSym">tree-3</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'baz</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>最后一次调用 <span class="stt">max-interior</span> 也可能返回 <span class="stt">foo</span>，因为节点 <span
            class="stt">foo</span> 和
          <span class="stt">baz</span> 的叶子之和都为 5。
          <a name="(idx._(gentag._302))"></a>
          <a name="(idx._(gentag._303))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..26)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._304))"></a>
          <span class="EoplExerciseRef"></span> 还有一种写法。树的集合可以用下列语法定义：
        </p>
        <p><span class="Iidentity">\begin{align*}\mathit{Red\text{-}blue\text{-}tree} &::=
            \mathit{Red\text{-}blue\text{-}subtree} \\
            \mathit{Red\text{-}blue\text{-}subtree} &::= <span class="stt">(red-node </span><span
              class="Iidentity">\mathit{Red\text{-}blue\text{-}subtree}</span><span class="stt"> </span><span
              class="Iidentity">\mathit{Red\text{-}blue\text{-}subtree}</span><span class="stt">)</span> \\
            &::= <span class="stt">(blue-node </span><span
              class="Iidentity">\{\mathit{Red\text{-}blue\text{-}subtree}\}^{*}</span><span class="stt">)</span> \\
            &::= <span class="stt">(leaf-node </span><span class="Iidentity">\mathit{Int}</span><span
              class="stt">)</span>\end{align*}</span></p>
        <p>用 <span class="stt">define-datatype</span> 写出等价定义，用得到的接口写出一个过程，它取一棵树，生成
          形状相同的另一棵树，但把每片叶子的值改为从当前叶子节点到树根之间红色节点的数目。
          <a name="(idx._(gentag._305))"></a>
        </p>
      </blockquote>
      <h4>2.5<tt> </tt><a name="(part._s2..5)"></a>抽象语法及其表示</h4>
      <p>
      <div class="SIntrapara"><a name="(idx._(gentag._306))"></a>
        <a name="(idx._(gentag._307))"></a>
      </div>
      <div class="SIntrapara">
        <blockquote class="EoplFigure">
          <p>
          <div class="SIntrapara">[!t]</div>
          <div class="SIntrapara">
            <blockquote class="SCentered">
              <p><img src="ast.svg" alt="(lambda (x) (f (f x)))的抽象语法树" width="478.8pt" height="284.4pt" /></p>
            </blockquote>
          </div>
          </p>
          <blockquote class="caption">
            <p><span class="stt">(lambda (x) (f (f x)))</span> 的抽象语法树<a name="(elem._fig-2..2)"></a></p>
          </blockquote>
        </blockquote>
      </div>
      </p>
      <p><a name="(idx._(gentag._308))"></a>
        <a name="(idx._(gentag._309))"></a>
        语法通常指定归纳式数据类型的某一具体表示，后者使用前者生成的字符串或值。这种表示
        叫做<span class="emph">具体语法</span> (<span class="emph">concrete syntax</span>)，或<span class="emph">外在</span>
        (<span class="emph">external</span>) 表示。
      </p>
      <p>例如，<span class="EoplDefinitionRef"></span> 指定集合 lambda 演算表达式，用的就是 lambda 演算表
        达式的具体语法。我们可以用其他具体语法表示 lambda 演算表达式。例如，可以用</p>
      <blockquote class="SubFlow">
        <p><a name="(elem._lambda-2)"></a><span class="Iidentity">\begin{align*}\mathit{Lc\text{-}exp} &::=
            \mathit{Identifier} \\
            &::= <span class="stt">proc </span><span class="Iidentity">\mathit{Identifier}</span><span class="stt">
            </span><span class="stt">=></span><span class="stt"> </span><span
              class="Iidentity">\mathit{Lc\text{-}exp}</span> \\
            &::= <span class="Iidentity">\mathit{Lc\text{-}exp}</span><span class="stt"> (</span><span
              class="Iidentity">\mathit{Lc\text{-}exp}</span><span class="stt">)</span>\end{align*}</span></p>
        <p>把 lambda 演算表达式定义为另一个字符串集合。</p>
      </blockquote>
      <p>为了处理这样的数据，需要将其转换为<span class="emph">内在</span> (<span class="emph">internal</span>) 表示。
        <span class="stt">define-datatype</span> 形式提供了一种简洁的方式来定义这样的内在表示。我们称之
        为<span class="emph">抽象语法</span> (<span class="emph">abstract syntax</span>)。在抽象语法中，不需要存储括号之类的终止符，
        因为它们不传达信息。另一方面，我们要确保数据结构足以区分它所表示的 lambda 演算表
        达式，并提取出各部分。<span class="stt">lc-exp</span>的数据类型 <span class="stt">lc-exp</span> 助我们轻松实现这些。
      </p>
      <p><a name="(idx._(gentag._310))"></a>
        <a name="(idx._(gentag._311))"></a>
        <a name="(idx._(gentag._312))"></a>
        将内在表示形象化为<span class="emph">抽象语法树</span> (<span class="emph">abstract syntax tree</span>) 也很不错。
        <span class="EoplFigureRef"></span> 展示了一棵抽象语法树，它代表数据类型 <span class="stt">lc-exp</span> 表示的
        lambda 演算表达式 <span class="stt">(lambda (x) (f (f x)))</span>。树的每个内部节点以相应的生成式名
        字为标识。树枝以所出现的非终结符名字为标识。叶子对应终止符字符串。
      </p>
      <p>要为某种具体语法设计抽象语法，需要给其中的每个生成式，以及生成式中出现的每个非终
        止符命名。很容易将抽象语法写成 <span class="stt">define-datatype</span> 声明。我们为每个非终结符添加
        一个 <span class="stt">define-datatype</span>，为每个生成式添加一个变体。
        <a name="(idx._(gentag._313))"></a>
        <a name="(idx._(gentag._314))"></a>
      </p>
      <p><span class="EoplFigureRef"></span> 中挑出的内容可以精确表示如下：</p>
      <p><a name="(elem._lc-grammar2)"></a><span class="Iidentity">\begin{align*}\mathit{Lc\text{-}Exp} &::=
          \mathit{Identifier} \\[-3pt]
          &\mathrel{\phantom{::=}} \fbox{<span class="stt">var-exp (var)</span>} \\[5pt]
          &::= \normalfont{<span class="stt">(lambda (</span><span class="Iidentity">\mathit{Identifier}</span><span
            class="stt">) </span><span class="Iidentity">\mathit{Lc\text{-}Exp}</span><span class="stt">)</span>}
          \\[-3pt]
          &\mathrel{\phantom{::=}} \fbox{<span class="stt">lambda-exp (bound-var body)</span>} \\[5pt]
          &::= \normalfont{<span class="stt">(</span><span class="Iidentity">\mathit{Lc\text{-}Exp}</span><span
            class="stt"> </span><span class="Iidentity">\mathit{Lc\text{-}Exp}</span><span class="stt">)</span>}
          \\[-3pt]
          &\mathrel{\phantom{::=}} \fbox{<span class="stt">app-exp (rator rand)</span>}\end{align*}</span></p>
      <p>本书采用这种表示，同时指明具体语法和抽象语法。
        <a name="(idx._(gentag._315))"></a>
      </p>
      <p>具体语法主要供人使用，抽象语法主要供计算机使用，既已区分二者，现在来看看如何将一
        种语法转换为另一种。</p>
      <p>当具体语法是个字符串集合，推导出对应的抽象语法树可能相当棘手。这一任务
        叫做<span class="emph">解析</span> (<span class="emph">parsing</span>)，由<span class="emph">解析器</span> (<span
          class="emph">parser</span>) 完成。因为写解析器通常比较
        麻烦，所以最好借由工具<span class="emph">解析器生成器</span> (<span class="emph">parser generator</span>) 完成。
        <a name="(idx._(gentag._316))"></a>
        <a name="(idx._(gentag._317))"></a>
        解析器生成器以一套语法作为输入，产生一个解析器。由于语法是由工具处理的，它们必需
        以某种机器能够理解的语言写成，即写语法用的特定领域语言。有很多现成的解析器生成器。
        <a name="(idx._(gentag._318))"></a>
      </p>
      <p><a name="(idx._(gentag._319))"></a>
        如果具体语法以列表集合的形式给出，解析过程就会大大简化。比如，
        和<span class="stt">define-datatype</span> <span class="stt">define-datatype</span> 的语法类似，
        <a href="#%28elem._lambda-2%29" data-pltdoc="x">本节开头</a>的 lambda 演算表达式指定了一个列表集合。这样，Scheme
        过程 <span class="stt">read</span> 会自动把字符串解析为列表和符号。然后，把这些列表结构解析为抽象语
        法树就容易多了，就像 <span class="stt">parse-expression</span> 这样。
      </p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara"><a name="(idx._(gentag._320))"></a>
        </div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">parse-expression</span></span> : <span
                    class="texMathInline">\mathit{SchemeVal} \to \mathit{LcExp}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">parse-expression</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">datum</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cond</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">symbol?</span><span class="hspace"> </span><span class="RktSym">datum</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">var-exp</span><span class="hspace"> </span><span class="RktSym">datum</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">pair?</span><span class="hspace"> </span><span class="RktSym">datum</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">eqv?</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">car</span><span
                    class="hspace"> </span><span class="RktSym">datum</span><span class="RktPn">)</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">lambda</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">lambda-exp</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">cadr</span><span class="hspace"> </span><span class="RktSym">datum</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">parse-expression</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">caddr</span><span class="hspace"> </span><span class="RktSym">datum</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">app-exp</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">parse-expression</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">datum</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">parse-expression</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">cadr</span><span class="hspace"> </span><span class="RktSym">datum</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">else</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">report-invalid-concrete-syntax</span><span class="hspace"> </span><span
                    class="RktSym">datum</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._321))"></a></div>
        </p>
      </blockquote>
      <p><a name="(idx._(gentag._322))"></a>
        通常，很容易把抽象语法树重新转换为列表-符号表示。我们这样做了，Scheme 的打印过程
        就会将其显示为列表形式的具体语法。这由 <span class="stt">unparse-lc-exp</span> 完成：</p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">unparse-lc-exp</span></span> : <span
                    class="texMathInline">\mathit{LcExp} \to \mathit{SchemeVal}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">unparse-lc-exp</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">exp</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">lc-exp</span><span class="hspace"> </span><span
                    class="RktSym">exp</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">var-exp</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">var</span><span class="RktPn">)</span><span class="hspace"> </span><span
                    class="RktSym">var</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">lambda-exp</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">bound-var</span><span class="hspace"> </span><span class="RktSym">body</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">list</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">lambda</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">list</span><span class="hspace"> </span><span class="RktSym">bound-var</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">unparse-lc-exp</span><span class="hspace"> </span><span
                    class="RktSym">body</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">app-exp</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">rator</span><span class="hspace"> </span><span class="RktSym">rand</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">list</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">unparse-lc-exp</span><span class="hspace"> </span><span
                    class="RktSym">rator</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">unparse-lc-exp</span><span class="hspace"> </span><span
                    class="RktSym">rand</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._323))"></a>
          <a name="(idx._(gentag._324))"></a>
          <a name="(idx._(gentag._325))"></a>
          <a name="(idx._(gentag._326))"></a>
        </div>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..27)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._327))"></a>
          画出下面 lambda 演算表达式的抽象语法树：</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">a</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">a</span><span class="hspace"> </span><span class="RktSym">b</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="hspace"> </span><span
                    class="RktSym">c</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">lambda</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">y</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">x</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">       </span><span class="RktPn">(</span><span class="RktSym">x</span><span
                    class="hspace"> </span><span class="RktSym">y</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">     </span><span class="RktSym">x</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..28)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._328))"></a>
          写出反向解析器，将lc-exp的抽象语法转换为符合本节第二个语法
          （<span class="stt">lc-grammar2</span>）的字符串。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..29)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._329))"></a>
          <a name="(idx._(gentag._330))"></a>
          <a name="(idx._(gentag._331))"></a>
          当具体语法使用克莱尼星号或加号（<span class="stt">kleene-star</span>）时，生成抽象语法树时最好
          使用相应子树的<span class="emph">列表</span>。例如，如果 lambda 演算表达式的语法为：
        </p>
        <blockquote class="SubFlow">
          <p><span class="Iidentity">\begin{align*}\mathit{Lc\text{-}Exp} &::= \mathit{Identifier} \\[-3pt]
              &\mathrel{\phantom{::=}} \fbox{<span class="stt">var-exp (var)</span>} \\[5pt]
              &::= \normalfont{<span class="stt">(lambda (</span><span
                class="Iidentity">\{\mathit{Identifier}\}^{*}</span><span class="stt">) </span><span
                class="Iidentity">\mathit{Lc\text{-}Exp}</span><span class="stt">)</span>} \\[-3pt]
              &\mathrel{\phantom{::=}} \fbox{<span class="stt">lambda-exp (bound-vars body)</span>} \\[5pt]
              &::= \normalfont{<span class="stt">(</span><span class="Iidentity">\mathit{Lc\text{-}Exp}</span><span
                class="stt"> </span><span class="Iidentity">\{\mathit{Lc\text{-}Exp}\}^{*}</span><span
                class="stt">)</span>} \\[-3pt]
              &\mathrel{\phantom{::=}} \fbox{<span class="stt">app-exp (rator rands)</span>}\end{align*}</span></p>
          <p>那么字段 <span class="stt">bound-vars</span> 的谓词可写作 <span class="stt">(list-of identifier?)</span>，<span
              class="stt">rands</span> 的
            谓词可写作 <span class="stt">(list-of lc-exp?)</span>。以这种方式写出该语法的 <span class="stt">define-datatype</span>
            和解析器。
            <a name="(idx._(gentag._332))"></a>
            <a name="(idx._(gentag._333))"></a>
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..30)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>上面定义的过程
          <span class="stt">parse-expression</span> 很不可靠：它检查不到某些可能的语法错误，例
          如 <span class="stt">(a b c)</span>，并且因其他表达式终止时给不出恰当的错误信息，如 <span class="stt">(lambda)</span>。
          修改一下，使之更健壮，可接受任何s-exp，并且对不表示 lambda 演算表达式的 s-exp 给
          出恰当的错误信息。
          <a name="(idx._(gentag._334))"></a>
          <a name="(idx._(gentag._335))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex2..31)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._336))"></a>
          有时，把具体语法定义为括号包围的符号和整数序列很有用。例如，可以把
          集合<span class="emph">前缀列表</span> (<span class="emph">prefix list</span>) 定义为：</p>
        <blockquote class="SubFlow">
          <p><span class="Iidentity">\begin{align*}\mathit{Prefix\text{-}list} &::= <span class="stt">(</span><span
                class="Iidentity">\mathit{Prefix\text{-}exp}</span><span class="stt">)</span> \\
              \mathit{Prefix\text{-}exp} &::= \mathit{Int} \\
              &::= <span class="stt">- </span><span class="Iidentity">\mathit{Prefix\text{-}exp}</span><span
                class="stt"> </span><span class="Iidentity">\mathit{Prefix\text{-}exp}</span>\end{align*}</span></p>
          <p>那么 <span class="stt">(- - 3 2 - 4 - 12 7)</span>是一个合法的前缀列表。有时为纪念其发明者Jan
            Łukasiewicz，称之为<span class="emph">波兰前缀表示法</span> (<span class="emph">Polish prefix notation</span>)。写一个
            解析器，将前缀列表表示法转换为抽象语法：
            <a name="(idx._(gentag._337))"></a>
            <a name="(idx._(gentag._338))"></a>
          </p>
          <blockquote class="EoplCodeInset">
            <blockquote class="SCodeFlow">
              <table cellspacing="0" cellpadding="0" class="RktBlk">
                <tr>
                  <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                      class="hspace"> </span><span class="RktSym">prefix-exp</span><span class="hspace"> </span><span
                      class="RktSym">prefix-exp?</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">const-exp</span>
                  </td>
                </tr>
                <tr>
                  <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">num</span><span
                      class="hspace"> </span><span class="RktSym">integer?</span><span class="RktPn">)</span><span
                      class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">diff-exp</span>
                  </td>
                </tr>
                <tr>
                  <td><span class="hspace">   </span><span class="RktPn">(</span><span
                      class="RktSym">operand1</span><span class="hspace"> </span><span
                      class="RktSym">prefix-exp?</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">   </span><span class="RktPn">(</span><span
                      class="RktSym">operand2</span><span class="hspace"> </span><span
                      class="RktSym">prefix-exp?</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                      class="RktPn">)</span></td>
                </tr>
              </table>
            </blockquote>
          </blockquote>
          <p>使上例与这几个构造器生成相同抽象语法树：</p>
          <blockquote class="EoplCodeInset">
            <blockquote class="SCodeFlow">
              <table cellspacing="0" cellpadding="0" class="RktBlk">
                <tr>
                  <td><span class="RktPn">(</span><span class="RktSym">diff-exp</span></td>
                </tr>
                <tr>
                  <td><span class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">diff-exp</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">  </span><span class="RktPn">(</span><span
                      class="RktSym">const-exp</span><span class="hspace"> </span><span class="RktVal">3</span><span
                      class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">  </span><span class="RktPn">(</span><span
                      class="RktSym">const-exp</span><span class="hspace"> </span><span class="RktVal">2</span><span
                      class="RktPn">)</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">diff-exp</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">  </span><span class="RktPn">(</span><span
                      class="RktSym">const-exp</span><span class="hspace"> </span><span class="RktVal">4</span><span
                      class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">diff-exp</span>
                  </td>
                </tr>
                <tr>
                  <td><span class="hspace">   </span><span class="RktPn">(</span><span
                      class="RktSym">const-exp</span><span class="hspace"> </span><span class="RktVal">12</span><span
                      class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">   </span><span class="RktPn">(</span><span
                      class="RktSym">const-exp</span><span class="hspace"> </span><span class="RktVal">7</span><span
                      class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                      class="RktPn">)</span></td>
                </tr>
              </table>
            </blockquote>
          </blockquote>
          <p>提示：想想如何写一个过程，取一列表，产生一个 <span class="stt">prefix-exp</span> 和列表剩余元素组成
            的列表。
            <a name="(idx._(gentag._339))"></a>
          </p>
        </blockquote>
      </blockquote>
      <div class="navsetbottom"><span class="navleft">
          <div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);"
              title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
        </span><span class="navright">  <a href="isd.html" title="backward to " 1 归纳式数据集"" data-pltdoc="x">←
            prev</a>  <a href="index.html" title="up to " 编程语言要素"" data-pltdoc="x">up</a>  <a href="expr.html"
            title="forward to " 3 表达式"" data-pltdoc="x">next →</a></span> </div>
    </div>
  </div>
  <div id="contextindicator"> </div>
</body>

</html>