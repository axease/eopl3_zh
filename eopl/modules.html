<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=0.8" />
  <title>8 模块</title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default" />
  <link rel="stylesheet" type="text/css" href="racket.css" title="default" />
  <link rel="stylesheet" type="text/css" href="footnote.css" title="default" />
  <script type="text/javascript" src="scribble-common.js"></script>
  <script src="katex/katex.min.js"></script>
  <script src="onload.js"></script>
</head>

<body id="scribble-racket-lang-org">
  <div class="tocset">
    <div class="tocview">
      <div class="tocviewlist tocviewlisttopspace">
        <div class="tocviewtitle">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle"
                  onclick="TocviewToggle(this," tocview_0");">▼</a></td>
              <td></td>
              <td><a href="index.html" class="tocviewlink" data-pltdoc="x">编程语言要素</a></td>
            </tr>
          </table>
        </div>
        <div class="tocviewsublisttop" style="display: block;" id="tocview_0">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td align="right"></td>
              <td><a href="fw-trans.html" class="tocviewlink" data-pltdoc="x">译者的话</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="glo.html" class="tocviewlink" data-pltdoc="x">译名表</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="fw.html" class="tocviewlink" data-pltdoc="x">序</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="pf.html" class="tocviewlink" data-pltdoc="x">前言</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="awk.html" class="tocviewlink" data-pltdoc="x">致谢</a></td>
            </tr>
            <tr>
              <td align="right">1 </td>
              <td><a href="isd.html" class="tocviewlink" data-pltdoc="x">归纳式数据集</a></td>
            </tr>
            <tr>
              <td align="right">2 </td>
              <td><a href="da.html" class="tocviewlink" data-pltdoc="x">数据抽象</a></td>
            </tr>
            <tr>
              <td align="right">3 </td>
              <td><a href="expr.html" class="tocviewlink" data-pltdoc="x">表达式</a></td>
            </tr>
            <tr>
              <td align="right">4 </td>
              <td><a href="state.html" class="tocviewlink" data-pltdoc="x">状态</a></td>
            </tr>
            <tr>
              <td align="right">5 </td>
              <td><a href="cpi.html" class="tocviewlink" data-pltdoc="x">传递续文的解释器</a></td>
            </tr>
            <tr>
              <td align="right">6 </td>
              <td><a href="cps.html" class="tocviewlink" data-pltdoc="x">续文传递风格</a></td>
            </tr>
            <tr>
              <td align="right">7 </td>
              <td><a href="types.html" class="tocviewlink" data-pltdoc="x">类型</a></td>
            </tr>
            <tr>
              <td align="right">8 </td>
              <td><a href="" class="tocviewselflink" data-pltdoc="x">模块</a></td>
            </tr>
            <tr>
              <td align="right">9 </td>
              <td><a href="oac.html" class="tocviewlink" data-pltdoc="x">对象和类</a></td>
            </tr>
            <tr>
              <td align="right">10 </td>
              <td><a href="further-reading.html" class="tocviewlink" data-pltdoc="x">扩展阅读</a></td>
            </tr>
            <tr>
              <td align="right">11 </td>
              <td><a href="sllgen-parsing-system.html" class="tocviewlink" data-pltdoc="x">SLLGEN解析系统</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="bib.html" class="tocviewlink" data-pltdoc="x">参考书目</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="indices.html" class="tocviewlink" data-pltdoc="x">索引</a></td>
            </tr>
          </table>
        </div>
      </div>
      <div class="tocviewlist">
        <table cellspacing="0" cellpadding="0">
          <tr>
            <td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle"
                onclick="TocviewToggle(this," tocview_1");">►</a></td>
            <td>8 </td>
            <td><a href="" class="tocviewselflink" data-pltdoc="x">模块</a></td>
          </tr>
        </table>
        <div class="tocviewsublistbottom" style="display: none;" id="tocview_1">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td align="right">8.1 </td>
              <td><a href="#%28part._s8..1%29" class="tocviewlink" data-pltdoc="x">简单模块系统</a></td>
            </tr>
            <tr>
              <td align="right">8.2 </td>
              <td><a href="#%28part._s8..2%29" class="tocviewlink" data-pltdoc="x">声明类型的模块</a></td>
            </tr>
            <tr>
              <td align="right">8.3 </td>
              <td><a href="#%28part._s8..3%29" class="tocviewlink" data-pltdoc="x">模块过程</a></td>
            </tr>
          </table>
        </div>
      </div>
    </div>
    <div class="tocsub">
      <div class="tocsubtitle">On this page:</div>
      <table class="tocsublist" cellspacing="0">
        <tr>
          <td><span class="tocsublinknumber">8.1<tt> </tt></span><a href="#%28part._s8..1%29" class="tocsubseclink"
              data-pltdoc="x">简单模块系统</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">8.1.1<tt> </tt></span><a href="#%28part._s8..1..1%29" class="tocsubseclink"
              data-pltdoc="x">例子</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">8.1.2<tt> </tt></span><a href="#%28part._s8..1..2%29" class="tocsubseclink"
              data-pltdoc="x">实现简单模块系统</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber"></span><a href="#%28part._s8..1-syntax%29" class="tocsubseclink"
              data-pltdoc="x">语法</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber"></span><a href="#%28part._s8..1-the-interpreter%29" class="tocsubseclink"
              data-pltdoc="x">解释器</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber"></span><a href="#%28part._s8..1-checker%29" class="tocsubseclink"
              data-pltdoc="x">检查器</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">8.2<tt> </tt></span><a href="#%28part._s8..2%29" class="tocsubseclink"
              data-pltdoc="x">声明类型的模块</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">8.2.1<tt> </tt></span><a href="#%28part._s8..2..1%29" class="tocsubseclink"
              data-pltdoc="x">例子</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber"></span><a href="#%28part._s8..2-transparent-types%29" class="tocsubseclink"
              data-pltdoc="x">透明类型</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber"></span><a href="#%28part._s8..2-opaque-types%29" class="tocsubseclink"
              data-pltdoc="x">模糊类型</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">8.2.2<tt> </tt></span><a href="#%28part._s8..2..2%29" class="tocsubseclink"
              data-pltdoc="x">实现</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber"></span><a href="#%28part._syntax-and-the-interpreter%29"
              class="tocsubseclink" data-pltdoc="x">语法和解释器</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber"></span><a href="#%28part._the-checker%29" class="tocsubseclink"
              data-pltdoc="x">检查器</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">8.3<tt> </tt></span><a href="#%28part._s8..3%29" class="tocsubseclink"
              data-pltdoc="x">模块过程</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">8.3.1<tt> </tt></span><a href="#%28part._s8..3..1%29" class="tocsubseclink"
              data-pltdoc="x">例子</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">8.3.2<tt> </tt></span><a href="#%28part._s8..3..2%29" class="tocsubseclink"
              data-pltdoc="x">实现</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber"></span><a href="#%28part._s8..3-syntax%29" class="tocsubseclink"
              data-pltdoc="x">语法</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber"></span><a href="#%28part._s8..3-interpreter%29" class="tocsubseclink"
              data-pltdoc="x">解释器</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber"></span><a href="#%28part._s8..3-checker%29" class="tocsubseclink"
              data-pltdoc="x">检查器</a></td>
        </tr>
      </table>
    </div>
  </div>
  <div class="maincolumn">
    <div class="main">
      <div class="navsettop"><span class="navleft">
          <div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);"
              title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
        </span><span class="navright">  <a href="types.html" title="backward to " 7 类型"" data-pltdoc="x">← prev</a>  <a
            href="index.html" title="up to " 编程语言要素"" data-pltdoc="x">up</a>  <a href="oac.html" title="forward to " 9
            对象和类"" data-pltdoc="x">next →</a></span> </div>
      <h3>8<tt> </tt><a name="(part._modules)"></a>模块</h3>
      <p><a name="(idx._(gentag._1181))"></a>
        要构建只有几百行代码的系统，我们介绍的语言特性已非常强大。如果我们要构建更大的系
        统，有数千行代码，我们就还需要一些别的佐料。</p>
      <ol>
        <li>
          <p>我们需要一种好的方式，将系统分为相对独立的部分，并能编写文档，解释各部分
            之间的依赖关系。</p>
        </li>
        <li>
          <p>我们需要一种更好的方式来控制名字的作用域和绑定。词法定界是命名控制的强大
            工具，但不足以应对更大或分割为多份源代码的程序。</p>
        </li>
        <li>
          <p>我们需要一种方式强化抽象边界。在<a href="da.html" data-pltdoc="x">数据抽象</a>，我们介绍了抽象数据类型的思想。
            在类型的实现中，我们可以对值做任意操作，但在实现之外，类型的值只能通过类型接口
            中的过程创建和操作。我们把这叫做<a name="(idx._(gentag._1182))"></a><span class="emph">抽象边界</span> (<span
              class="emph">abstraction boundary</span>)。如果程序遵守这一界限，我们可
            以改变数据类型的实现。但是，如果某些代码打破了抽象，依赖实现细节，我们就无法任
            意修改实现而不破坏其他代码。</p>
        </li>
        <li>
          <p>最后，我们需要一种方式，将这些部分灵活组合，让同一部分可复用于不同地方。</p>
        </li>
      </ol>
      <p>本章，我们介绍<span class="emph">模块</span> (<span class="emph">module</span>)，以满足这些需求。具体来说，我们展示了如何用
        类型系统创建和强化抽象边界。</p>
      <p>我们的模块语言中，程序包含一系列<span class="emph">模块定义</span> (<span class="emph">module definition</span>)，后跟一个待
        求值的表达式。每个模块定义把一个名字绑定到一个<span class="emph">模块</span>。创建的模块可能
        是<span class="emph">简单模块</span> (<span class="emph">simple module</span>)，类似环境，是一组绑定；也可能是<span
          class="emph">模块过程</span> (<span class="emph">module
          procedure</span>)，取一模块，生成另一模块。</p>
      <p><a name="(idx._(gentag._1183))"></a>
        每个模块都有一套<span class="emph">接口</span> (<span class="emph">interface</span>)。作为一组绑定的模块具有<span
          class="emph">简单接口</span> (<span class="emph">simple
          interface</span>)，接口列出模块提供的绑定及其类型。模块过程的接口指定模块的
        参数接口和返回模块的接口，就像过程的类型指定参数和结果的类型。</p>
      <p>这些接口就像类型一样，决定了模块组合的方式。因为求出示例程序的值非常直接，因此我
        们关注其类型。如前所见，理解这种语言的定界和绑定规则是程序分析和求值的关键。
        <a name="(idx._(gentag._1184))"></a>
      </p>
      <h4>8.1<tt> </tt><a name="(part._s8..1)"></a>简单模块系统</h4>
      <p><a name="(idx._(gentag._1185))"></a>
        <a name="(idx._(gentag._1186))"></a>
        我们的第一种语言名叫 SIMPLE-MODULES，只有简单模块。它没有模块过程，只创建非常简
        单的抽象边界。几种流行语言使用与之类似的模块系统。
      </p>
      <h5>8.1.1<tt> </tt><a name="(part._s8..1..1)"></a>例子</h5>
      <p>设想一个软件项目中有三名开发者：爱丽丝、鲍伯和查理。爱丽丝、鲍伯和查理正在开发项
        目中相对独立的几部分。这些开发者散居各地，时区都可能不同。项目的每部分都要实现一
        套<a href="da.html#%28part._s2..1%29" data-pltdoc="x">用接口定义数据</a>那样的接口，但接口的实现可能涉及大量其他过程。而且，当各部分集成
        到一起时，开发者需要确保不存在干扰项目其他部分的命名冲突。</p>
      <p>要实现这一目标，开发者们需要公布一套接口，列出每个供他人使用的过程名字。模块系统
        要保证这些名字是公开的，而它们使用的其他名字则是私有的，且不会被项目中的其他代码
        修改。</p>
      <p>我们可以用<a href="expr.html" data-pltdoc="x">表达式</a>中的定界技术，但这些无法应对更大的工程。相反，我们使用模
        块系统。开发者们各设计一个模块，包含公开接口和私有实现。他们能看到自己模块的接口
        和实现，但爱丽丝只能看到他人模块的接口。她的所做所为不会影响其他模块的实现，其他
        模块的实现也不会影响她的（如<span class="EoplFigureRef"></span> 所示）。</p>
      <p>这里是 SIMPLE-MODULES 的简短例子。</p>
      <blockquote class="EoplExample">
        <p>
        <div class="SIntrapara"><a name="(elem._eg-8..1)"></a></div>
        <div class="SIntrapara">
          <blockquote class="SubFlow">
            <blockquote class="EoplCodeInset">
              <table cellspacing="0" cellpadding="0" class="SVerbatim">
                <tr>
                  <td>
                    <p><span class="stt">module m1</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[a : int</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">   </span><span class="stt">b : int</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">   </span><span class="stt">c : int]</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[a = 33</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">   </span><span class="stt">x = -(a,1)</span><span
                        class="hspace">  </span><span class="stt">% = 32</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">   </span><span class="stt">b = -(a,x)</span><span
                        class="hspace">  </span><span class="stt">% = 1</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">   </span><span class="stt">c = -(x,b)] % =
                        31</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">let a = 10</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">in -(-(from m1 take a,</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">       </span><span class="stt">from m1 take
                        b),</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">     </span><span class="stt">a)</span></p>
                  </td>
                </tr>
              </table>
            </blockquote>
            <p>类型为 <span class="stt">int</span>，值为 <span class="texMathInline">((33-1)-10)=22</span>。</p>
          </blockquote>
        </div>
        </p>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="SCentered">
            <p><img src="alice-view.svg" alt="项目中，爱丽丝所见的三个模块" width="464.54999999999995pt" height="498.75pt" /></p>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>项目中，爱丽丝所见的三个模块<a name="(elem._fig-8..1)"></a></p>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._1187))"></a>
        <a name="(idx._(gentag._1188))"></a>
        <a name="(idx._(gentag._1189))"></a>
        这个程序从名为 <span class="stt">m1</span> 的模块定义开始。像任何模块一样，它有<span class="emph">接口</span>和<span class="stt">主体</span>。
        主体<span class="emph">实现</span>接口。接口<span class="emph">声明</span>变量 <span class="stt">a</span>、<span
          class="stt">b</span> 和 <span class="stt">c</span>。主体<span class="emph">定
          义</span>了 <span class="stt">a</span>、<span class="stt">x</span>、<span class="stt">b</span> 和 <span
          class="stt">c</span> 的绑定。
        <a name="(idx._(gentag._1190))"></a>
      </p>
      <p>当我们求程序的值时，也会求出 <span class="stt">m1</span> 主体中表达式的值。变量 <span class="stt">from m1 take a</span>、
        <span class="stt">from m1 take b</span> 和 <span class="stt">from m1 take c</span> 绑定到适当的值，它们的作用域为模块定
        义之后。由于 <span class="stt">from m1 take x</span> 未在接口中声明，所以它的作用域不包含模块定义之
        后。
      </p>
      <p><a name="(idx._(gentag._1191))"></a>
        <a name="(idx._(gentag._1192))"></a>
        为了同<span class="emph">简单变量</span> (<span class="emph">simple variables</span>) 区别，我们称这些新变量
        为<span class="emph">受限变量</span> (<span class="emph">qualified variables</span>)。在一般的语言中，受限变量可能写作
        <span class="stt">m1.a</span>、<span class="stt">m1:a</span> 或 <span class="stt">m1::a</span>。在<a href="oac.html"
          data-pltdoc="x">对象和类</a>探讨的面向对象语言中，
        <span class="stt">m1.a</span> 通常另有含义。
      </p>
      <p>我们说接口<span class="emph">提出</span> (<span class="emph">offer</span>)（或称<span class="emph">公布</span> (<span
          class="emph">advertise</span>)，
        或称<span class="emph">承诺</span> (<span class="emph">promise</span>)）三个整型值，主体<span class="emph">提
          供</span> (<span class="emph">supply</span>, <span class="emph">provide</span>)（或称<span class="emph">输出</span>
        (<span class="emph">export</span>)）这些值。当模块主体提供的值类型与接口命名变量时公
        布的类型相符时，主体<span class="emph">满足</span>其接口。</p>
      <p><a name="(idx._(gentag._1193))"></a>
        在主体中，定义具有 <span class="stt">let*</span> 那样的作用域，所以 <span class="stt">x</span>、<span class="stt">b</span> 和 <span
          class="stt">c</span> 的定义
        在 <span class="stt">a</span> 的作用域内。一些作用域如<span class="EoplFigureRef"></span> 所示。</p>
      <p><a name="(idx._(gentag._1194))"></a>
        本例中，以 <span class="stt">let a = 10</span> 开头的表达式是<span class="emph">程序主体</span> (<span class="emph">program
          body</span>)。它的值
        即程序的值。</p>
      <p><a name="(idx._(gentag._1195))"></a>每个模块都在模块主体和程序其余部分之间建立了抽
        象边界。模块主体中的表达式在抽象边界<span class="emph">之内</span>，其他部分在抽象边界<span class="emph">之外</span>。
        模块主体也可以提供不在接口中的名字绑定，但那些绑定在程序主体和其他模块中不可见，
        正如<span class="EoplFigureRef"></span> 所示。在我们的例子中，程序主体不在 <span class="stt">from m1 take x</span>
        的作用域内。如果我们写 <span class="stt">-(from m1 take a, from m1 take x)</span>，程序就会类型异常。</p>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..2)"></a>程序</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module m1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u : bool]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u = 33]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">44</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>类型异常。即使程序的其他部分不使用那些值，模块主体也要将接口中的名字与适当类型的
            值关联起来。</p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCentered">
            <p><img src="module-contour.svg" alt="简单模块中的一些作用域" width="498.0pt" height="402.0pt" /></p>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>简单模块中的一些作用域<a name="(elem._fig-8..2)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..3)"></a>模块主体必须提供接口中声明的所有绑定。例如，</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module m1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u : int</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">v : int]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u = 33]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">44</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>类型异常，因为 <span class="stt">m1</span> 的主体没有提供接口中公布的所有值。</p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..4)"></a>为了让实现简单一点，我们的语言要求模块主体按照接口声明的顺序给出各值。因此</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module m1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u : int</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">v : int]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[v = 33</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">u = 44]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">from m1 take u</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>类型异常。可以免除这一限制（<span class="EoplExerciseRef"></span>、<span class="stt">ex8.17</span>）。</p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..5)"></a><a name="(idx._(gentag._1196))"></a>
          在我们的语言中，模块具有 <span class="stt">let*</span> 式的作用域（<span class="EoplExerciseRef"></span>）。例如，</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module m1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u : int]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u = 44]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">module m2</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[v : int]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[v = -(from m1 take
                      u,11)]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">-(from m1 take u, from m2 take v)</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>类型为 <span class="stt">int</span>。但如果我们交换定义的顺序，</p>
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module m2</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[v : int]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[v = -(from m1 take
                      u,11)]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">module m1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u : int]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u = 44]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">-(from m1 take u, from m2 take v)</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>则类型异常，因为 <span class="stt">m2</span> 主体中使用 <span class="stt">from m1 take u</span> 的地方不在后者的作用域
            内。</p>
        </blockquote>
      </blockquote>
      <h5>8.1.2<tt> </tt><a name="(part._s8..1..2)"></a>实现简单模块系统</h5>
      <h5><a name="(part._s8..1-syntax)"></a>语法</h5>
      <p>SIMPLE-MODULES 的程序包含一串模块定义，然后是一个表达式。</p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*} \mathit{Program} &::= \{\mathit{ModuleDefn}\}^{*} \mathit{Expression}
            \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">a-program (m-defs body)</span>}\end{align*}</span></p>
      </blockquote>
      <p>模块定义包含名字、接口和主体。</p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*}\mathit{ModuleDefn} &::= <span class="stt">module</span> \
            \mathit{Identifier} \ <span class="stt">interface</span> \ \mathit{Iface} \ <span class="stt">body</span> \
            \mathit{ModuleBody} \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">a-module-definition (m-name expected-iface
              m-body)</span>}\end{align*}</span></p>
      </blockquote>
      <p>简单模块的接口包含任意数量的声明。每个声明指定程序中一个变量的类型。
        我们称之为<span class="emph">值声明</span> (<span class="emph">value declaration</span>)，因为要声明的变量表示一个值。在后面
        几节中，我们介绍其他类别的接口和声明。</p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*} \mathit{Iface} &::= <span class="stt">[</span> \{\mathit{Decl}\}^{*}
            <span class="stt">]</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">simple-iface (decls)</span>} \\[-5pt]
            \mathit{Decl} &::= \mathit{Identifier} <span class="stt">:</span> \mathit{Type} \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">val-decl (var-name ty)</span>}\end{align*}</span></p>
      </blockquote>
      <p>模块主体包含任意数量的定义。每个定义将变量和某个表达式的值关联起来。</p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*}\mathit{ModuleBody} &::= <span class="stt">[</span>
            \{\mathit{Defn}\}^{*} <span class="stt">]</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">defns-module-body (defns)</span>} \\[-5pt]
            \mathit{Defn} &::= \mathit{Identifier} <span class="stt">=</span> \mathit{Expression} \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">val-defn (var-name exp)</span>}\end{align*}</span></p>
      </blockquote>
      <p>我们的表达式与 CHECKED（<a href="types.html#%28part._s7..3%29"
          data-pltdoc="x">CHECKED：带有类型检查的语言</a>）相同，但我们要修改语法，新增一种表达式，
        以便使用受限变量。</p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*}\mathit{Expression} &::= <span class="stt">from</span>
            \mathit{Identifier} <span class="stt">take</span> \mathit{Identifier} \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">qualified-var-exp (m-name
              var-name)</span>}\end{align*}</span></p>
      </blockquote>
      <h5><a name="(part._s8..1-the-interpreter)"></a>解释器</h5>
      <p><a name="(idx._(gentag._1197))"></a>
        求模块主体的值会得到一个<span class="emph">模块</span>。在我们的简单模块语言中，模块是一个环境，包
        含模块输出的所有绑定。我们用数据类型 <span class="stt">typed-module</span> 表示这些。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                  class="hspace"> </span><span class="RktSym">typed-module</span><span class="hspace"> </span><span
                  class="RktSym">typed-module?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">simple-module</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">bindings</span><span
                  class="hspace"> </span><span class="RktSym">environment?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>我们用一种新的绑定在环境中绑定模块名：</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                  class="hspace"> </span><span class="RktSym">environment</span><span class="hspace"> </span><span
                  class="RktSym">environment?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">empty-env</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">extend-env</span><span
                  class="hspace"> </span><span class="RktSym">...as</span><span class="hspace"> </span><span
                  class="RktSym">before...</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">extend-env-rec</span><span class="hspace"> </span><span
                  class="RktSym">...as</span><span class="hspace"> </span><span class="RktSym">before...</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">extend-env-with-module</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktSym">symbol?</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">m-val</span><span
                  class="hspace"> </span><span class="RktSym">typed-module?</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">saved-env</span><span
                  class="hspace"> </span><span class="RktSym">environment?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>例如，如果我们的程序是</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module m1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[a : int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">b : int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">c : int]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[a = 33</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">b = 44</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">c = 55]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">module m2</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[a : int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">b : int]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[a = 66</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">b = 77]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">let z = 99</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in -(z, -(from m1 take a, from m2 take a))</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>那么声明 <span class="texMathInline">z</span> 之后的环境是</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktVal">#</span><span class="RktVal">(</span><span
                    class="RktVal">struct:extend-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">   </span><span class="RktVal">z</span><span class="hspace"> </span><span
                    class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">struct:num-val</span><span
                    class="hspace"> </span><span class="RktVal">99</span><span class="RktVal">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">   </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                    class="RktVal">struct:extend-env-with-module</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktVal">m2</span><span class="hspace"> </span><span
                    class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">struct:simple-module</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktVal">#</span><span
                    class="RktVal">(</span><span class="RktVal">struct:extend-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">               </span><span class="RktVal">a</span><span
                    class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                    class="RktVal">struct:num-val</span><span class="hspace"> </span><span class="RktVal">66</span><span
                    class="RktVal">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">               </span><span class="RktVal">#</span><span
                    class="RktVal">(</span><span class="RktVal">struct:extend-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktVal">b</span><span
                    class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                    class="RktVal">struct:num-val</span><span class="hspace"> </span><span class="RktVal">77</span><span
                    class="RktVal">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktVal">#</span><span
                    class="RktVal">(</span><span class="RktVal">struct:empty-env</span><span
                    class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                    class="RktVal">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                    class="RktVal">struct:extend-env-with-module</span></td>
              </tr>
              <tr>
                <td><span class="hspace">         </span><span class="RktVal">m1</span><span
                    class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                    class="RktVal">struct:simple-module</span></td>
              </tr>
              <tr>
                <td><span class="hspace">               </span><span class="RktVal">#</span><span
                    class="RktVal">(</span><span class="RktVal">struct:extend-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktVal">a</span><span
                    class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                    class="RktVal">struct:num-val</span><span class="hspace"> </span><span class="RktVal">33</span><span
                    class="RktVal">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktVal">#</span><span
                    class="RktVal">(</span><span class="RktVal">struct:extend-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                     </span><span class="RktVal">b</span><span
                    class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                    class="RktVal">struct:num-val</span><span class="hspace"> </span><span class="RktVal">44</span><span
                    class="RktVal">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                     </span><span class="RktVal">#</span><span
                    class="RktVal">(</span><span class="RktVal">struct:extend-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                        </span><span class="RktVal">c</span><span
                    class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                    class="RktVal">struct:num-val</span><span class="hspace"> </span><span class="RktVal">55</span><span
                    class="RktVal">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                        </span><span class="RktVal">#</span><span
                    class="RktVal">(</span><span class="RktVal">struct:empty-env</span><span
                    class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                    class="RktVal">)</span><span class="RktVal">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">         </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                    class="RktVal">struct:empty-env</span><span class="RktVal">)</span><span
                    class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>在这个环境中，<span class="stt">m1</span> 和 <span class="stt">m2</span> 各绑定到一个简单模块，二者分别包含一个小环境。</p>
      </blockquote>
      <p><a name="(idx._(gentag._1198))"></a>
        我们用 <span class="stt">lookup-qualified-var-in-env</span> 求受限变量 <span class="stt">from </span><span
          class="texMathInline">m</span><span class="stt"> take </span><span class="texMathInline">var</span>
        引用的值。它在当前环境中查找模块 <span class="texMathInline">m</span>，然后在得到的环境中查找 <span class="texMathInline">var</span>。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">lookup-qualified-var-in-env!</span></span> : <span
                  class="texMathInline">\mathit{Sym} \times \mathit{Sym} \times \mathit{Env} \to \mathit{ExpVal}</span>
              </td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">lookup-qualified-var-in-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktSym">var-name</span><span class="hspace"> </span><span
                  class="RktSym">env</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">m-val</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-module-name-in-env</span><span class="hspace"> </span><span
                  class="RktSym">m-name</span><span class="hspace"> </span><span class="RktSym">env</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">typed-module</span><span class="hspace"> </span><span
                  class="RktSym">m-val</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">simple-module</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">bindings</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">apply-env</span><span class="hspace"> </span><span class="RktSym">bindings</span><span
                  class="hspace"> </span><span class="RktSym">var-name</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>要求程序的值，我们把所有模块定义加入当前环境中，得到初始环境，然后求程序主体的值。
        过程 <span class="stt">add-module-defns-to-env</span> 遍历模块定义，求每个模块定义主体的值，并将得到
        的模块加入当前环境中，如<span class="EoplFigureRef"></span> 所示。</p>
      <p><a name="(idx._(gentag._1199))"></a>
        <a name="(idx._(gentag._1200))"></a>
        最后，要求模块主体的值，我们按照 <span class="stt">let*</span> 式定界，在适当的环境内求每个表达式的
        值，得出一环境。过程 <span class="stt">defns-to-env</span> 生成的环境只包含定义 <span class="stt">defns</span> 产生的绑
        定（<span class="EoplFigureRef"></span>）。
        <a name="(idx._(gentag._1201))"></a>
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">value-of-program</span></span> : <span
                    class="texMathInline">\mathit{Program} \to \mathit{ExpVal}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">value-of-program</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">pgm</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">program</span><span class="hspace"> </span><span
                    class="RktSym">pgm</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">a-program</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">m-defns</span><span class="hspace"> </span><span class="RktSym">body</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">value-of</span><span class="hspace"> </span><span class="RktSym">body</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">add-module-defns-to-env</span><span class="hspace"> </span><span
                    class="RktSym">m-defns</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">empty-env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">add-module-defns-to-env</span></span> : <span
                    class="texMathInline">\mathit{Listof(Defn)} \times \mathit{Env} \to \mathit{Env}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">add-module-defns-to-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">defns</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">null?</span><span
                    class="hspace"> </span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktSym">env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">module-definition</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">car</span><span
                    class="hspace"> </span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">a-module-definition</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">m-name</span><span class="hspace"> </span><span
                    class="RktSym">iface</span><span class="hspace"> </span><span class="RktSym">m-body</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">add-module-defns-to-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">defns</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">extend-env-with-module</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktSym">m-name</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">value-of-module-body</span><span class="hspace"> </span><span
                    class="RktSym">m-body</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <p>
        <div class="SIntrapara">
          <blockquote class="caption">
            <p>SIMPLE-MODULES 的解释器，第 1 部分<a name="(elem._fig-8..3)"></a></p>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._1202))"></a></div>
        </p>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">value-of-module-body</span></span> : <span
                    class="texMathInline">\mathit{ModuleBody} \times \mathit{Env} \to \mathit{TypedModule}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">value-of-module-body</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-body</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">module-body</span><span class="hspace"> </span><span
                    class="RktSym">m-body</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">defns-module-body</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">simple-module</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">defns-to-env</span><span class="hspace"> </span><span
                    class="RktSym">defns</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">defns-to-env</span></span> : <span
                    class="texMathInline">\mathit{Listof(Defn)} \times \mathit{Env} \to \mathit{Env}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">defns-to-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">defns</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">null?</span><span
                    class="hspace"> </span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">empty-env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">definition</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                    class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">val-defn</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">var</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">val</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">value-of</span><span class="hspace"> </span><span
                    class="RktSym">exp</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">new-env</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">extend-env</span><span class="hspace"> </span><span
                    class="RktSym">var</span><span class="hspace"> </span><span class="RktSym">val</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">extend-env</span><span class="hspace"> </span><span class="RktSym">var</span><span
                    class="hspace"> </span><span class="RktSym">val</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">defns-to-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                    class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">defns</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">new-env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <p>
        <div class="SIntrapara">
          <blockquote class="caption">
            <p>SIMPLE-MODULES 的解释器，第 2 部分<a name="(elem._fig-8..4)"></a></p>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._1203))"></a></div>
        </p>
      </blockquote>
      <h5><a name="(part._s8..1-checker)"></a>检查器</h5>
      <p><a name="(idx._(gentag._1204))"></a>
        检查器的工作是确保所有模块主体满足其接口，且所有变量的使用符合其类型。</p>
      <p><a name="(idx._(gentag._1205))"></a>
        我们语言的定界规则很简单：模块遵循 <span class="stt">let*</span> 式定界，依次进入模块输出绑定中的受
        限变量的作用域。接口告诉我们每个受限变量的类型。声明和定义也都遵循 <span class="stt">let*</span> 式
        定界（如<span class="EoplFigureRef"></span>）。</p>
      <p>就像<a href="types.html" data-pltdoc="x">类型</a>中的检查器那样，我们用类型环境记录与当前作用域内各名字的相关信
        息。因为我们现在有了模块名，我们要在类型环境中绑定模块名。每个模块名绑定到模块的
        接口，作为其类型。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                  class="hspace"> </span><span class="RktSym">type-environment</span><span class="hspace"> </span><span
                  class="RktSym">type-environment?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">empty-tenv</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">extend-tenv</span><span
                  class="hspace"> </span><span class="emph">...同前...</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">extend-tenv-with-module</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">name</span><span
                  class="hspace"> </span><span class="RktSym">symbol?</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">interface</span><span
                  class="hspace"> </span><span class="RktSym">interface?</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">saved-tenv</span><span class="hspace"> </span><span
                  class="RktSym">type-environment?</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>要找出受限变量 <span class="stt">from </span><span class="texMathInline">m</span><span class="stt"> take </span><span
          class="texMathInline">var</span> 的类型，我们首先在类型环境中找出
        <span class="texMathInline">m</span>，然后在得到的接口中查找 <span class="texMathInline">var</span> 的类型。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">lookup-qualified-var-in-tenv</span></span> : <span
                  class="texMathInline">\mathit{Sym} \times \mathit{Sym} \times \mathit{Tenv} \to \mathit{Type}</span>
              </td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">lookup-qualified-var-in-tenv</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktSym">var-name</span><span class="hspace"> </span><span
                  class="RktSym">tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-module-name-in-tenv</span><span class="hspace"> </span><span
                  class="RktSym">tenv</span><span class="hspace"> </span><span class="RktSym">m-name</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">interface</span><span class="hspace"> </span><span
                  class="RktSym">iface</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">simple-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">decls</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-variable-name-in-decls</span><span class="hspace"> </span><span
                  class="RktSym">var-name</span><span class="hspace"> </span><span class="RktSym">decls</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">type-of-program</span></span> : <span
                    class="texMathInline">\mathit{Program} \to \mathit{Type}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">type-of-program</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">pgm</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">program</span><span class="hspace"> </span><span
                    class="RktSym">pgm</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">a-program</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">module-defns</span><span class="hspace"> </span><span class="RktSym">body</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">type-of</span><span class="hspace"> </span><span class="RktSym">body</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">add-module-defns-to-tenv</span><span class="hspace"> </span><span
                    class="RktSym">module-defns</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">empty-tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">add-module-defns-to-tenv</span></span> : <span
                    class="texMathInline">\mathit{Listof(ModuleDefn)} \times \mathit{Tenv} \to \mathit{Tenv}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">add-module-defns-to-tenv</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">defns</span><span
                    class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">null?</span><span
                    class="hspace"> </span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktSym">tenv</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">module-definition</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">car</span><span
                    class="hspace"> </span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">a-module-definition</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">m-name</span><span class="hspace"> </span><span
                    class="RktSym">expected-iface</span><span class="hspace"> </span><span
                    class="RktSym">m-body</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">actual-iface</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">interface-of</span><span class="hspace"> </span><span
                    class="RktSym">m-body</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym"><:-iface< /span><span class="hspace"> </span><span
                        class="RktSym">actual-iface</span><span class="hspace"> </span><span
                        class="RktSym">expected-iface</span><span class="hspace"> </span><span
                        class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">new-tenv</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                      </span><span class="RktPn">(</span><span
                    class="RktSym">extend-tenv-with-module</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                        </span><span class="RktSym">m-name</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                        </span><span class="RktSym">expected-iface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                        </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">add-module-defns-to-tenv</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                    class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">defns</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">new-tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">report-module-doesnt-satisfy-iface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktSym">m-name</span><span
                    class="hspace"> </span><span class="RktSym">expected-iface</span><span class="hspace"> </span><span
                    class="RktSym">actual-iface</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>SIMPLE-MODULES 的检查器，第 1 部分<a name="(elem._fig-8..5)"></a></p>
        </blockquote>
      </blockquote>
      <p>就像<a href="types.html" data-pltdoc="x">类型</a>那样，对程序做类型检查的过程类模仿程序的求值，但我们记录的不是
        值，而是类型。我们用 <span class="stt">type-of-program</span> 代替 <span class="stt">value-of-program</span>，用
        <span class="stt">add-module-defns-to-tenv</span> 代替 <span class="stt">add-module-defns-to-env</span>。过程
        <span class="stt">add-module-defns-to-tenv</span> 用 <span class="stt"><:-iface< /span> 检查各模块主体产生的接口与提出的
            接口是否相符；如果相符，就将模块加入到类型环境中；否则报错。
      </p>
      <p><a name="(idx._(gentag._1206))"></a>
        模块主体的接口将主体中定义的各个变量与定义中的类型关联起来。例如，如果我们查看第
        一个例子的主体，</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">[a = 33</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">x = -(a,1)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">b = -(a,x)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">c = -(x,b)]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>可得</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">[a : int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">x : int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">b : int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">c : int]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>一旦我们建立了一套接口来描述模块主体输出的所有绑定，我们就能将其与模块公布的接口
        比较。</p>
      <p>回忆一下，简单接口包含一个声明列表。过程 <span class="stt">defns-to-decls</span> 创建这样的列表，调
        用 <span class="stt">type-of</span> 找出每个定义的类型。在每一步，它还按 <span class="stt">let*</span> 定界，扩展局部类
        型环境（见<span class="EoplFigureRef"></span>）。</p>
      <p>剩下的只是用 <span class="stt"><:-iface< /span> 比较每个模块的期望类型与实际类型。我们将 <span class="stt">
              <:< /span> 定义
                为：若 <span class="texMathInline">i_1 <span class="stt">
                    <:< /span> i_2
                  </span>，则满足接口 <span class="texMathInline">i_1</span> 的任何模块也满足接口 <span
                    class="texMathInline">i_2</span>。例如</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">[u : int</span><span class="hspace">         </span><span class="stt">[u :
                    int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">v : int</span><span
                    class="hspace">    </span><span class="stt">
                    <:< /span><span class="hspace">    </span><span class="stt">z : int]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">z : int]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>因为满足接口 <span class="stt">[u : int v : bool z : int]</span> 的任何模块都提供了接口 <span class="stt">[u : int
            z : int]</span> 公布的所有值。</p>
      </blockquote>
      <p>对我们的简单模块语言，<span class="stt"><:-iface< /span> 只需调用 <span class="stt"><:-decls< /span> 比较声明。这些过程取
                一 <span class="stt">tenv</span> 参数，简单模块系统不使用它，但<a href="#%28part._s8..2%29"
                  data-pltdoc="x">声明类型的模块</a>需要。
                见<span class="EoplFigureRef"></span>。</p>
      <p>过程 <span class="stt"><-decls< /span> 执行主要工作，比较两个声明集合。如果 <span class="texMathInline">decls_1</span> 和
            <span class="texMathInline">decls_2</span> 是两个声明集合，当且仅当任何能提供 <span class="texMathInline">decls_1</span>
            中声明绑定的模块，也
            能提供 <span class="texMathInline">decls_2</span> 中声明的绑定时，我们说 <span class="texMathInline">decls_1 <:
                decls_2</span>。如果
                <span class="texMathInline">decls_2</span> 中的所有声明，在 <span class="texMathInline">decls_1</span>
                中都有与之匹配的声明，就能保证这一点，
                就像上面的例子那样。</p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">interface-of</span></span> : <span
                    class="texMathInline">\mathit{ModuleBody} \times \mathit{Tenv} \to \mathit{Iface}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">interface-of</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-body</span><span
                    class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">module-body</span><span class="hspace"> </span><span
                    class="RktSym">m-body</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">defns-module-body</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">simple-iface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">defns-to-decls</span><span class="hspace"> </span><span
                    class="RktSym">defns</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">defns-to-decls</span></span> : <span
                    class="texMathInline">\mathit{Listof(Defn)} \times \mathit{Tenv} \to \mathit{Decl}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">defns-to-decls</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">defns</span><span
                    class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">null?</span><span
                    class="hspace"> </span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">definition</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                    class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">val-defn</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">var-name</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">ty</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">type-of</span><span class="hspace"> </span><span
                    class="RktSym">exp</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span class="RktSym">cons</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">val-decl</span><span class="hspace"> </span><span class="RktSym">var-name</span><span
                    class="hspace"> </span><span class="RktSym">ty</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">defns-to-decls</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">defns</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">extend-tenv</span><span class="hspace"> </span><span
                    class="RktSym">var-name</span><span class="hspace"> </span><span class="RktSym">ty</span><span
                    class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>SIMPLE-MODULES 的检查器，第 2 部分<a name="(elem._fig-8..6)"></a></p>
        </blockquote>
      </blockquote>
      <p>过程 <span class="stt"><:-decls< /span> 首先检查 <span class="stt">decls1</span> 和 <span class="stt">decls2</span>。若
            <span class="stt">decls2</span> 为空，那
            么它对 <span class="stt">decls1</span> 无所要求，所以结果为 <span class="stt">#t</span>。若 <span class="stt">decls2</span>
            非空，但
            <span class="stt">decls1</span> 为空，那么 <span class="stt">decls2</span> 有所要求，但 <span class="stt">decls1</span>
            无可提供，所以结果为
            <span class="stt">#f</span>。否则，我们比较 <span class="stt">decls1</span> 和 <span class="stt">decls2</span>
            声明的第一对变量的名字；若二
            者相同，那么它们的类型必须匹配，然后我们递归处理两个声明列表余下的部分；若他们不
            同，那么我们递归处理 <span class="stt">decls1</span> 的 <span class="stt">cdr</span>，找出匹配 <span
              class="stt">decls2</span> 中第一个声明
            的内容。</p>
      <p>这样，简单模块系统就完成了。
        <a name="(idx._(gentag._1207))"></a>
        <a name="(idx._(gentag._1208))"></a>
        <a name="(idx._(gentag._1209))"></a>
        <a name="(idx._(gentag._1210))"></a>
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt"><:-iface< /span></span> : <span
                      class="texMathInline">\mathit{Iface} \times \mathit{Iface} \times \mathit{Tenv} \to
                      \mathit{Bool}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym"><:-iface< /span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">iface1</span><span
                    class="hspace"> </span><span class="RktSym">iface2</span><span class="hspace"> </span><span
                    class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">interface</span><span class="hspace"> </span><span
                    class="RktSym">iface1</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">simple-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">decls1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">cases</span><span class="hspace"> </span><span class="RktSym">interface</span><span
                    class="hspace"> </span><span class="RktSym">iface2</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">simple-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">decls2</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span class="RktSym"><:-decls<
                      /span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                        class="hspace"> </span><span class="RktSym">decls2</span><span class="hspace"> </span><span
                        class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                        class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                        class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt"><:-decls< /span></span> : <span
                      class="texMathInline">\mathit{Listof(Decl)} \times \mathit{Listof(Decl)} \times \mathit{Tenv} \to
                      \mathit{Bool}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym"><:-decls< /span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">decls1</span><span
                    class="hspace"> </span><span class="RktSym">decls2</span><span class="hspace"> </span><span
                    class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cond</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">decls2</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">#t</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">#f</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">else</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">name1</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">decl->name</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">name2</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">decl->name</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">decls2</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">eqv?</span><span class="hspace"> </span><span class="RktSym">name1</span><span
                    class="hspace"> </span><span class="RktSym">name2</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span class="RktSym">and</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">equal?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">decl->type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">decl->type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">decls2</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span class="RktSym"><:-decls<
                      /span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                        class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">decls2</span><span
                        class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                        class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span class="RktSym"><:-decls<
                      /span><span class="hspace"> </span><span class="RktPn">(</span><span
                        class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                        class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">decls2</span><span
                        class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span><span
                        class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                        class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>SIMPLE-MODULES 的接口比较<a name="(elem._fig-8..7)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..1)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>修改检查器，检测并拒绝任何定义两个同名模块的程序。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..2)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>过程 <span class="stt">add-module-defns-to-env</span> 不完全正确，因为它加入了模块定义的所有值，而不
          只是接口中的值。修改 <span class="stt">add-module-defns-to-env</span>，只加入接口中声明的值。
          <span class="stt">add-module-defns-to-tenv</span> 也有此问题吗？
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..3)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>修改语言的语法，以 <span class="stt">m.v</span> 代替 <span class="stt">from m take v</span>
          使用受限变量。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..4)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._1211))"></a>
          <a name="(idx._(gentag._1212))"></a>
          <a name="(idx._(gentag._1213))"></a>
          修改语言的表达式，像<span class="EoplExerciseRef"></span> 那样，加入多声明 <span class="stt">let</span>、多参数过程
          和多声明 <span class="stt">letrec</span>。
          <a name="(idx._(gentag._1214))"></a>
          <a name="(idx._(gentag._1215))"></a>
          <a name="(idx._(gentag._1216))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..5)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>允许在模块主体中使用 <span class="stt">let</span> 和 <span class="stt">letrec</span> 声明。例如，可以写
        </p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module even-odd</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[even : (int -> bool)</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">odd</span><span
                    class="hspace">  </span><span class="stt">: (int -> bool)]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">letrec</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">bool local-odd (x :
                    int)</span><span class="hspace">  </span><span class="stt">= ... (local-even -(x,1)) ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">bool local-even (x : int) =
                    ... (local-odd -(x,1)) ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">in [even = local-even</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">      </span><span class="stt">odd = local-odd]</span>
                </p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..6)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>允许在模块主体中定义局部模块。例如，可以写</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module m1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u : int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">v : int]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">module m2</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">interface [v : int]</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">body [v = 33]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u = 44</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">v = -(from m2 take v,
                    1)]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..7)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>扩展前一题的解答，允许模块将其他模块作为输出的一部分。例如，可以写</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module m1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u : int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">n : [v : int]]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">module m2</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">interface [v : int]</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">body [v = 33]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[u = 44</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">n = m2]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">from m1 take n take v</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..8)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>在我们的语言中，模块必须按照接口中的顺序产生值，可以取消这种限制。取消它。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..9)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>我们说我们的模块系统应当能解释模块之间的依赖关系。给 SIMPLE-MODULES 添加这种能力，
          在模块主体和程序主体中添加一条 <span class="stt">depends-on</span> 语句。那么，模块 <span class="stt">m</span> 不是在之
          前声明的所有模块的作用域中，而是在自身 <span class="stt">depends-on</span> 语句中列出模块的作用域中。
          例如，考虑程序</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module m1 ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">module m2 ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">module m3 ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">module m4 ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">module m5</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface [...]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">depends-on m1, m3</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[...]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p><span class="stt">m5</span> 的主体仅在来自 <span class="stt">m1</span> 或 <span class="stt">m3</span> 的受限变量的作用域中。即使
          <span class="stt">m4</span> 输
          出了 <span class="stt">x</span> 的值，使用 <span class="stt">from m4 take x</span> 也将造成类型异常。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..10)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>我们还可以用 <span class="stt">depends-on</span> 这样的特性控制模块主体求值的时机。给 SIMPLE-MODULES
          增加这种能力，在各模块主体和程序主体添加一条 <span class="stt">imports</span> 语句。<span class="stt">imports</span> 就
          像 <span class="stt">depends-on</span>，不同之处是，仅当（用 <span class="stt">imports</span> 语句）将模块输入到其他模块
          时，才求其主体的值。</p>
        <p>这样，如果我们的语言有打印表达式，程序</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module m1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface [] body [x =
                    print(1)]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">module m2</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface [] body [x =
                    print(2)]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">module m3</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface []</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">import m2</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[x = print(3)]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">import m3, m1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">33</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>在返回 33 之前，将打印 2、3 和 1。这里的模块接口为空，因为我们只关心它们主体求值
          的顺序。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..11)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._1217))"></a>
          修改检查器，用 INFERRED 作为语言的表达式。这道练习中，你需要修改 <span class="stt"><:-decls< /span>，
              不能用 <span class="stt">equal?</span> 比较类型。例如，在</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module m</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface [f : (int ->
                    int)]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body [f = proc (x : ?)
                    x]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>中，类型推导器报告的 <span class="stt">f</span> 实际类型可能是 <span class="stt">(tvar07 -> tvar07)</span>，这应当接受。
          但是，我们应拒绝模块</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module m</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface [f : (int ->
                    bool)]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body [f = proc (x : ?)
                    x]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>即使类型推导器报告的类型仍为 <span class="stt">(tvar07 -> tvar07)</span>。
          <a name="(idx._(gentag._1218))"></a>
        </p>
      </blockquote>
      <h4>8.2<tt> </tt><a name="(part._s8..2)"></a>声明类型的模块</h4>
      <p><a name="(idx._(gentag._1219))"></a>
        <a name="(idx._(gentag._1220))"></a>至今为止，我们的接口只声明了普通变量及其类型。在下面这
        种模块语言 OPAQUE-TYPES 中，我们还允许接口声明类型。例如，在定义
      </p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module m1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">zero : t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">succ : (t -> t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">pred : (t -> t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-zero : (t ->
                    bool)]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">...</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p><a name="(idx._(gentag._1221))"></a>
          中，接口声明了类型 <span class="stt">t</span>，以及该类型值的操作 <span class="stt">zero</span>、<span
            class="stt">succ</span>、<span class="stt">pred</span> 和
          <span class="stt">is-zero</span>。如同<a href="da.html#%28part._s2..1%29"
            data-pltdoc="x">用接口定义数据</a>，这套接口可能与算术操作的实现相关。这里的声明
          <span class="stt">t</span> 为<span class="emph">模糊类型</span> (<span class="emph">opaque
            type</span>)，意为，模块之外的代码不知道这种类型的值
          如何表示。所有的外部代码都知道可以用 <span class="stt">from m1 take zero</span> 和 <span class="stt">from m1 take
            succ</span> 等过程处理 <span class="stt">from m1 take t</span> 类型的值。这样，<span class="stt">from m1 take t</span>
          的表现
          就像 <span class="stt">int</span> 和 <span class="stt">bool</span> 之类的原生类型一样。
        </p>
      </blockquote>
      <p><a name="(idx._(gentag._1222))"></a>
        <a name="(idx._(gentag._1223))"></a>
        <a name="(idx._(gentag._1224))"></a>
        我们将介绍两种类型声明：<span class="emph">透明</span> (<span class="emph">transparent</span>) 类型和<span class="emph">模糊</span>
        (<span class="emph">opaque</span>)
        类型。好的模块系统中，二者缺一不可。
      </p>
      <h5>8.2.1<tt> </tt><a name="(part._s8..2..1)"></a>例子</h5>
      <p>欲知其用途，再想想我们的几位开发者。爱丽丝一直用包含整数对的数据结构表示点的横纵
        坐标。她使用的语言具有<span class="EoplExerciseRef"></span> 那样的类型，所以她的模块
        <span class="stt">Alices-points</span> 接口具有如下声明：
      </p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt">initial-point : (int -> pairof int * int)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">increment-x : (pairof int * int -> pairof int * int)</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>鲍伯和查理对此直发牢骚。他们不想一遍又一遍地写 <span class="stt">pairof int * int</span>。因此，爱丽
        丝用透明类型声明重写她的接口。这样，她可以写</p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt">module Alices-points</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[transparent point = pairof
                  int * int</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">initial-point : (int ->
                  point)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">increment-x : (point ->
                  point)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">get-x : (point -> int)</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">...]</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>这减轻了她的工作，因为她写得更少；这也减轻了她合作者的工作，因为他们在实现中可以
        写这样的定义：</p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt">[transparent point = from Alices-points take point</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">foo = proc (p1 : point)</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">        </span><span class="stt">proc (p2 : point)
                  ...</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">...]</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>对某些项目中，这很不错。不过，爱丽丝的项目正好要表示固定形状金属导轨上的点，所以
        横纵坐标不是相互独立的。<span class="NoteBox"><span class="NoteContent">不妨将金属导轨视为有长度无宽度的圆形轨迹，以圆心为
            坐标原点。要保证横坐标变化时，得到的点仍在圆上，则纵坐标也要相应改变。反之亦
            然。——<span class="emph">译注</span></span></span>爱丽丝实现 <span class="stt">increment-x</span> 时，要小心翼翼地更新纵坐标，以匹配
        横坐标的改变。但是鲍伯不知道这点，所以他的过程写作</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">increment-y = proc (p : point)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">               </span><span class="stt">unpair x y =
                    p</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">               </span><span class="stt">in newpair(x,
                    -(y,-1))</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>由于鲍伯的代码修改纵坐标时不随之修改横坐标，爱丽丝的代码就没法正常工作了。</p>
      </blockquote>
      <p>更糟糕的是，如果爱丽丝打算修改点的表示，把纵坐标作为第一部分呢？她可以按照新的表
        示修改她的代码。但是鲍伯的代码就坏掉了，因为过程 <span class="stt">increment-y</span> 修改了序对中的
        错误部分。</p>
      <p>爱丽丝可以把 <span class="stt">point</span> 声明为<span class="emph">模糊</span>数据类型来解决她的问题。她把接口重写为</p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt">opaque point</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">initial-point : (int -> point)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">increment-x : (point -> point)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">get-x : (point -> int)</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>现在鲍伯用过程 <span class="stt">initial-point</span> 创建新的点，而且他可以用 <span class="stt">from
          Alices-points take get-x</span> 和 <span class="stt">from Alices-points take increment-x</span> 处理点，但
        是除了爱丽丝接口中的过程外，他无法用其他过程处理点。尤其是，他写不出过程
        <span class="stt">increment-y</span>，因为它用了爱丽丝接口之外的过程处理点。
      </p>
      <p>在本节的剩余部分中，我们探究这些组件的更多例子。</p>
      <h5><a name="(part._s8..2-transparent-types)"></a>透明类型</h5>
      <p><a name="(idx._(gentag._1225))"></a>
        <a name="(idx._(gentag._1226))"></a>
        <a name="(idx._(gentag._1227))"></a>
        我们首先讨论透明类型声明。有时这些又称作<span class="emph">具体</span> (<span class="emph">concrete</span>) 类型
        或<span class="emph">类型缩写</span> (<span class="emph">type abbreviation</span>)。
      </p>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..6)"></a>程序</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module m1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[transparent t =
                      int</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">z : t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">s : (t -> t)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-z? : (t ->
                      bool)]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[type t = int</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">z = 33</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">s = proc (x : t)
                      -(x,-1)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-z? = proc (x : t)
                      zero?(-(x,z))]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">proc (x : from m1 take
                      t)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">(from m1 take is-z?
                      -(x,0))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>类型为 <span class="stt">(int -> bool)</span>。</p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCentered">
            <p><img src="module-type.svg" alt="模块类型声明的作用域" width="570.0pt" height="372.0pt" /></p>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>模块类型声明的作用域<a name="(elem._fig-8..8)"></a></p>
        </blockquote>
      </blockquote>
      <p>在接口的剩余部分中，声明 <span class="stt">transparent t = int</span> 将 <span class="stt">t</span> 绑定到类型 <span
          class="stt">int</span>，
        所以我们可以写 <span class="stt">z : t</span>。更重要的是，在程序的剩余部分中，声明也将 <span class="stt">from m1
          take t</span> 绑定到 <span class="stt">int</span>。我们称之为<span class="emph">受限类型</span> (<span
          class="emph">qualified type</span>)。
        <a name="(idx._(gentag._1228))"></a>
        这里，我们用它声明了绑定到变量 <span class="stt">z</span> 的类型。声明的作用域是接口的剩余部分，以及
        模块定义之后程序的剩余部分。
      </p>
      <p>模块主体中的定义 <span class="stt">type t = int</span> 在主体的剩余部分中，将 <span class="stt">t</span> 绑定到 <span
          class="stt">int</span>，
        所以我们可以写 <span class="stt">s = proc (x : t) ...</span>。像之前那样，定义的作用域是主体的剩余部
        分（见<span class="EoplFigureRef"></span>）。</p>
      <p>当然，我们可以给类型起任意名字，也可以声明多个类型。类型声明可以出现在接口中任意
        位置，只要每个声明都先于使用。</p>
      <p><a name="(idx._(gentag._1229))"></a>
        <a name="(idx._(gentag._1230))"></a>
        <a name="(idx._(gentag._1231))"></a>
      </p>
      <h5><a name="(part._s8..2-opaque-types)"></a>模糊类型</h5>
      <p><a name="(idx._(gentag._1232))"></a>
        <a name="(idx._(gentag._1233))"></a>
        模块还可以用 <span class="stt">opaque-type</span> 声明输出<span class="emph">模糊</span>类型。模糊类型有时又
        称作<span class="emph">抽象类型</span> (<span class="emph">abstract type</span>)。
      </p>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..7)"></a>我们把<span class="EoplExampleRef"></span> 程序中的透明类型替换为模糊
          类型。得出的程序是</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module m1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">z : t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">s : (t -> t)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-z? : (t ->
                      bool)]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[type t = int</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">z = 33</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">s = proc (x : t)
                      -(x,-1)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-z? = proc (x : t)
                      zero?(-(x,z))]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">proc (x : from m1 take
                      t)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">(from m1 take is-z?
                      -(x,0))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <p>接口中的声明 <span class="stt">opaque t</span> 把 <span class="stt">t</span> 作为一种新的模糊类型名字。模糊类型的行为就
        像 <span class="stt">int</span> 或 <span class="stt">bool</span> 之类的原生类型。名为 <span class="stt">t</span>
        的类型在接口的剩余部分中绑
        定到这种模糊类型，而受限类型 <span class="stt">from m1 take t</span> 在程序的剩余部分中绑定到同一模
        糊类型。程序的剩余部分都知道 <span class="stt">from m1 take z</span> 绑定到一个值，其类型为 <span class="stt">from
          m1 take t</span>；<span class="stt">from m1 take s</span> 和 <span class="stt">from m1 take is-z?</span>
        绑定到过程，用来处理
        这种类型的值。<a name="(idx._(gentag._1234))"></a>这就是抽象边界。类型检查器确保表
        达式的类型为 <span class="stt">from m1 take t</span>时，求值是安全的，所以表达式的值只能通过这些操作
        符生成，如<span class="stt">suitable-env</span>所述。</p>
      <p>与之对应，定义 <span class="stt">type t = int</span> 在模块主体内部将 <span class="stt">t</span> 作为 <span
          class="stt">int</span> 的名字，
        但是，由于程序的剩余部分从模块接口获得绑定，所以对此一无所知。</p>
      <p>所以 <span class="stt">-(x,0)</span> 类型异常，因为主程序不知道类型 <span class="stt">from m1 take t</span> 为的值就是类
        型为 <span class="stt">int</span> 的值。</p>
      <p>我们改变程序，删掉算术操作，得</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module m1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">z : t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">s : (t -> t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-z? : (t -> bool)]</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[type t = int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">z = 33</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">s = proc (x : t)
                    -(x,-1)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-z? = proc (x : t)
                    zero?(-(x,z))]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">proc (x : from m1 take
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">(from m1 take is-z?
                    x)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>现在，我们的程序类型正常，类型为 <span class="stt">(from m1 take t -> bool)</span>。</p>
      </blockquote>
      <p>通过强化抽象边界，类型检查器确保程序只能通过接口提供的过程处理接口提供的值。
        如<a href="da.html" data-pltdoc="x">数据抽象</a>所述，这给我们提供了机制来分离数据类型的用户和实现。接下来，我们给
        出这一技术的几个例子。</p>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..8)"></a>如果程序使用了模块定义</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module colors</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque color</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">red : color</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">green : color</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-red? : (color ->
                      bool)]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[type color = int</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">red = 0</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">green = 1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-red? = proc (c :
                      color) zero?(c)]</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>程序没法知道 <span class="stt">from colors take color</span> 实际为 <span class="stt">int</span>，也不知道 <span
              class="stt">from
              colors take green</span> 实际为 1（也许有一个例外：返回颜色作为最终答案，然后打印出
            来）。</p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..9)"></a>程序</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module ints1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">zero : t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">succ : (t -> t)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">pred : (t -> t)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-zero : (t ->
                      bool)]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[type t = int</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">zero = 0</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">succ = proc(x : t)
                      -(x,-5)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">pred = proc(x : t)
                      -(x,5)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-zero = proc (x : t)
                      zero?(x)]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let z = from ints1 take zero</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in let s = from ints1 take succ</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in (s (s z))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>类型为 <span class="stt">from ints1 take t</span>，值为 10。但我们只能通过 <span class="stt">ints1</span> 输出的过程处理
            这个值。这个模块用表达值 <span class="texMathInline">5*k</span> 表示整数 <span class="texMathInline">k</span>。用<a
              href="da.html#%28part._s2..1%29" data-pltdoc="x">用接口定义数据</a>的表示法，写作
            <span class="texMathInline">\lceil k \rceil = 5 * k</span>。
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..10)"></a>在这个模块中，<span class="texMathInline">\lceil k \rceil = -3 * k</span>。</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module ints2</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">zero : t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">succ : (t -> t)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">pred : (t -> t)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-zero : (t ->
                      bool)]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[type t = int</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">zero = 0</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">succ = proc(x : t)
                      -(x,3)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">pred = proc(x : t)
                      -(x,-3)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">is-zero = proc (x : t)
                      zero?(x)]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let z = from ints2 take zero</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in let s = from ints2 take succ</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in (s (s z))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>类型为 <span class="stt">from ints2 take t</span>，值为 -6。</p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..11)"></a>在前面的例子中，我们不能直接处理值，但我们能用模块输出
          的过程处理它们。像<a href="da.html" data-pltdoc="x">数据抽象</a>那样，我们可以结合这些过程做有用的工作。这里，我们
          将它们结合起来，写出过程 <span class="stt">to-int</span>，把模块中的值转回 <span class="stt">int</span> 类型。</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module ints1 </span><span class="emph">...同前...</span><span class="stt"></span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let z = from ints1 take zero</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in let s = from ints1 take succ</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in let p = from ints1 take pred</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in let z? = from ints1 take is-zero</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in letrec int to-int (x : from ints1 take t) =</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">              </span><span class="stt">if (z?
                      x)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">              </span><span class="stt">then 0</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">              </span><span class="stt">else -((to-int
                      (p x)), -1)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in (to-int (s (s z)))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>类型为 <span class="stt">int</span>，值为 2。</p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..12)"></a>这里用到的技术与 <span class="stt">ints2</span> 中算术操作的实现相同。</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module ints2 </span><span class="emph">...同前...</span><span class="stt"></span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let z = from ints2 take zero</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in let s = from ints2 take succ</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in let p = from ints2 take pred</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in let z? = from ints2 take is-zero</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in letrec int to-int (x : from ints2 take t) =</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">              </span><span class="stt">if (z?
                      x)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">              </span><span class="stt">then 0</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">              </span><span class="stt">else -((to-int
                      (p x)), -1)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in (to-int (s (s z)))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>类型同样为 <span class="stt">int</span>，值为 2。</p>
        </blockquote>
      </blockquote>
      <p>在<a href="#%28part._s8..3%29" data-pltdoc="x">模块过程</a>中，我们展示如何将两个抽象出来。</p>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..13)"></a>在下面的程序中，我们设计一个模块来封装布尔类型。布尔值用整数值表示，
          但是像<span class="EoplExampleRef"></span> 那样，程序的剩余部分对此一无所知。</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module mybool</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">true : t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">false : t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">and : (t -> (t ->
                      t))</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">not : (t -> t)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">to-bool : (t ->
                      bool)]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[type t = int</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">true = 0</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">false = 13</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">and = proc (x : t)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">          </span><span class="stt">proc (y :
                      t)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">           </span><span class="stt">if zero?(x) then
                      y else false</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">not = proc (x : t)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">           </span><span class="stt">if zero?(x) then
                      false else true</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">to-bool = proc (x : t)
                      zero?(x)]</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let true = from mybool take true</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in let false = from mybool take false</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in let and = from mybool
                      take and</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">      </span><span class="stt">in ((and true)
                      false)</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>类型为 <span class="stt">from mybool take t</span>，值为 13。</p>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._1235))"></a>
        <a name="(idx._(gentag._1236))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..12)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>在<span class="EoplExampleRef"></span> 中，<span class="stt">and</span> 和 <span
            class="stt">not</span> 的定义可以从模块内部移到外面
          吗？<span class="stt">to-bool</span> 呢？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..13)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写一个模块，用 <span class="texMathInline">5*k+3</span> 表示整数 <span
            class="texMathInline">k</span>，实现算术操作。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..14)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>下面是 <span class="stt">mybool</span>（<span class="EoplExampleRef"></span>）的另一种定义：</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module mybool</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">true : t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">false : t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">and : (t -> (t ->
                    t))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">not : (t -> t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">to-bool : (t ->
                    bool)]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[type t = int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">true = 1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">false = 0</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">and = proc (x : t)</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">proc (y : t)</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">           </span><span class="stt">if zero?(x) then
                    false else y</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">not = proc (x : t)</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">if zero?(x) then
                    true else false</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">to-bool = proc (x :
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">              </span><span class="stt">if zero?(x) then
                    zero?(1) else zero?(0)]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>有没有程序类型为 <span class="stt">int</span>，用 <span class="stt">mybool</span> 原来的定义返回一个值，用新的定义返回另
          一个值？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..15)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._1237))"></a>
          <a name="(idx._(gentag._1238))"></a>
          写一个模块，实现抽象表。你实现的表应类似环境，但不是把符号绑定到 Scheme 值，而是
          把整数值绑定到整数值。接口提供一个值，表示空表；两个过程 <span class="stt">add-to-table</span> 和
          <span class="stt">lookup-in-table</span> 类似 <span class="stt">extend-env</span> 和 <span
            class="stt">apply-env</span>。由于我们的语言只有
          单参数过程，我们用咖喱化（<span class="EoplExerciseRef"></span>）实现等效的多参数过程。你可以用
          查询任何值都返回 0 的表模拟空表。这是该模块的一个例子：
        </p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module tables</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque table</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">empty : table</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">add-to-table : (int -> (int
                    -> (table -> table)))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">lookup-in-table : (int ->
                    (table -> int))]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[type table = (int ->
                    int)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">...]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">let empty = from tables take empty</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in let add-binding = from tables take add-to-table</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in let lookup = from tables
                    take lookup-in-table</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">      </span><span class="stt">in let table1 =
                    (((add-binding 3) 300)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                       </span><span
                    class="stt">(((add-binding 4) 400)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                        </span><span
                    class="stt">(((add-binding 3) 600)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                         </span><span
                    class="stt">empty)))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">         </span><span class="stt">in -(((lookup 4)
                    table1),</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">              </span><span class="stt">((lookup 3)
                    table1))</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>这个程序类型应为 <span class="stt">int</span>。表 <span class="stt">table1</span> 把 4 绑定到 400，把 3 绑定到 300，所以
          程序的值应为 100。
          <a name="(idx._(gentag._1239))"></a>
          <a name="(idx._(gentag._1240))"></a>
        </p>
      </blockquote>
      <h5>8.2.2<tt> </tt><a name="(part._s8..2..2)"></a>实现</h5>
      <p>现在我们来扩展系统，实现透明类型和模糊类型声明，及受限类型的引用。</p>
      <h5><a name="(part._syntax-and-the-interpreter)"></a>语法和解释器</h5>
      <p><a name="(idx._(gentag._1241))"></a>
        <a name="(idx._(gentag._1242))"></a>
        我们给两种新类型添加语法：有名类型（如 <span class="stt">t</span>）和受限类型（如 <span class="stt">from m1 take
          t</span>）。
      </p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*}\mathit{Type} &::= \mathit{Identifier} \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">named-type (name)</span>} \\[5pt]
            \mathit{Type} &::= <span class="stt">from </span><span class="Iidentity">\mathit{Identifier}</span><span
              class="stt"> take </span><span class="Iidentity">\mathit{Identifier}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">qualified-type (m-name t-name)</span>}\end{align*}</span>
        </p>
      </blockquote>
      <p>我们为模糊类型和透明类型新增两种声明。</p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*}\mathit{Decl} &::= <span class="stt">opaque </span><span
              class="Iidentity">\mathit{Identifier}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">opaque-type-decl (t-name)</span>} \\[5pt]
            \mathit{Decl} &::= <span class="stt">transparent </span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> = </span><span
              class="Iidentity">\mathit{Type}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">transparent-type-decl (t-name
              ty)</span>}\end{align*}</span></p>
      </blockquote>
      <p><a name="(idx._(gentag._1243))"></a>
        我们还要新增一种定义：类型定义，用来定义模糊类型和透明类型。</p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*}\mathit{Defn} &::= <span class="stt">type </span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> = </span><span
              class="Iidentity">\mathit{Type}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">type-defn (name ty)</span>}\end{align*}</span></p>
      </blockquote>
      <p>解释器不需要查看类型和声明，所以解释器的唯一改动是忽略类型定义。</p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">defns-to-env</span></span> : <span
                    class="texMathInline">\mathit{Listof(Defn)} \times \mathit{Env} \to \mathit{Env}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">defns-to-env</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">defns</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">null?</span><span
                    class="hspace"> </span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">empty-env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">definition</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                    class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">val-defn</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">var</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">...as</span><span
                    class="hspace"> </span><span class="RktSym">before...</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">type-defn</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">type-name</span><span class="hspace"> </span><span class="RktSym">type</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">defns-to-env</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">defns</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._1244))"></a></div>
        </p>
      </blockquote>
      <h5><a name="(part._the-checker)"></a>检查器</h5>
      <p><a name="(idx._(gentag._1245))"></a>
        <a name="(idx._(gentag._1246))"></a>
        检查器的改动就多多了，因为所有关于类型的操作都要扩展，以便处理新的类型。
      </p>
      <p>首先，我们介绍一种系统性的方法来处理模糊类型和透明类型。模糊类型就像 <span class="stt">int</span> 或
        <span class="stt">bool</span> 之类的原生类型一样。而透明类型名副其实，是透明的：它们的行为与定义相同。
        所以每个类型都等价于下列语法描述的：
      </p>
      <blockquote class="SubFlow">
        <blockquote class="Small">
          <p><span class="texMathDisplay">\mathit{Type} ::= <span class="stt">int</span>\ |\ <span
                class="stt">bool</span>\ |\ <span class="stt">from </span><span class="texMathInline">m</span><span
                class="stt"> take </span><span class="texMathInline">t</span>\ |\ <span class="stt">(</span><span
                class="texMathInline">\mathit{Type}</span><span class="stt"> -> </span><span
                class="texMathInline">\mathit{Type}</span><span class="stt">)</span></span></p>
        </blockquote>
        <p>其中，<span class="texMathInline">t</span> 为 <span class="texMathInline">m</span> 中的模糊类型声明。我们称这种形式的类型为<span
            class="emph">展开类型</span> (<span class="emph">expanded
            type</span>)。</p>
      </blockquote>
      <p>接下来我们扩展类型环境，处理新类型。我们的类型环境将每个有名类型或受限类型绑定到
        一个展开类型。新的类型环境定义为</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                    class="hspace"> </span><span class="RktSym">type-environment</span><span
                    class="hspace"> </span><span class="RktSym">type-environment?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">empty-tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">extend-tenv</span><span class="hspace"> </span><span
                    class="emph">...同前...</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">extend-tenv-with-module</span><span class="hspace"> </span><span
                    class="emph">...同前...</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">extend-tenv-with-type</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">t-name</span><span
                    class="hspace"> </span><span class="RktSym">symbol?</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">type</span><span
                    class="hspace"> </span><span class="RktSym">type?</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">saved-tenv</span><span class="hspace"> </span><span
                    class="RktSym">type-environment?</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>它满足条件：<span class="stt">type</span> 总是一个展开类型。像<span class="stt">invariant</span>讨论的，这个条件是
          一<span class="emph">不变式</span>。</p>
      </blockquote>
      <p><a name="(idx._(gentag._1247))"></a>
        接着我们写出函数 <span class="stt">expand-type</span>，它取一个类型和一个类型环境，用后者中的绑定展
        开前者。根据不变式“结果类型已展开”，它在类型环境中查
        询有名类型和受限类型，对<span class="stt">proc</span> 类型，它递归处理参数和结果类型。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">expand-type</span></span> : <span
                  class="texMathInline">\mathit{Type} \times \mathit{Tenv} \to \mathit{ExpandedType}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">expand-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">ty</span><span
                  class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">type</span><span class="hspace"> </span><span
                  class="RktSym">ty</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">int-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">int-type</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">bool-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">bool-type</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">proc-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">arg-type</span><span class="hspace"> </span><span
                  class="RktSym">result-type</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">proc-type</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">expand-type</span><span class="hspace"> </span><span
                  class="RktSym">arg-type</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">expand-type</span><span class="hspace"> </span><span
                  class="RktSym">result-type</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">named-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">name</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-type-name-in-tenv</span><span class="hspace"> </span><span
                  class="RktSym">tenv</span><span class="hspace"> </span><span class="RktSym">name</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">qualified-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">m-name</span><span class="hspace"> </span><span class="RktSym">t-name</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-qualified-type-in-tenv</span><span class="hspace"> </span><span
                  class="RktSym">m-name</span><span class="hspace"> </span><span class="RktSym">t-name</span><span
                  class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>为了维持这一不变式，我们必须保证不论何时扩展类型环境，都要调用 <span class="stt">expand-type</span>。
        这种地方有三处：</p>
      <ul>
        <li>
          <p>在检查器中的 <span class="stt">type-of</span> 内；</p>
        </li>
        <li>
          <p>用 <span class="stt">defns-to-decls</span> 处理类型定义列表之处；</p>
        </li>
        <li>
          <p>在 <span class="stt">add-module-defns-to-tenv</span> 中，向类型环境添加模块之处。</p>
        </li>
      </ul>
      <p>在检查器中，我们把形如</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <p><span class="RktPn">(</span><span class="RktSym">extend-tenv</span><span class="hspace"> </span><span
                class="RktSym">sym</span><span class="hspace"> </span><span class="RktSym">ty</span><span
                class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></p>
          </blockquote>
        </blockquote>
        <p>的调用替换为</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <p><span class="RktPn">(</span><span class="RktSym">extend-tenv</span><span class="hspace"> </span><span
                class="RktSym">var</span><span class="hspace"> </span><span class="RktPn">(</span><span
                class="RktSym">expand-type</span><span class="hspace"> </span><span class="RktSym">ty</span><span
                class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span><span
                class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></p>
          </blockquote>
        </blockquote>
      </blockquote>
      <p>在 <span class="stt">defns-to-decls</span> 中，当我们遇到类型定义时，我们展开右边的定义，然后将其加
        入类型环境中。<span class="stt">type-of</span> 返回的类型一定是展开的，所以我们不需要再次展开它。由
        于在模块主体中，所有类型绑定都是透明的，所以我们把类型定义转换为透明类型声明。在
        <span class="stt">add-module-defns-to-tenv</span> 中，我们调用 <span class="stt">extend-tenv-with-module</span>，将接口
        添加到类型环境中。这里，我们需要展开接口，以确保它包含的所有类型都已展开。要完成
        这一点，我们修改 <span class="stt">add-module-defns-to-tenv</span>，调用 <span class="stt">expand-iface</span>。
        见<span class="EoplFigureRef"></span>。
      </p>
      <p>过程 <span class="stt">expand-iface</span>（<span class="EoplFigureRef"></span>）调用 <span
          class="stt">expand-decls</span>。我们提取
        出这些过程，为<a href="#%28part._s8..3%29" data-pltdoc="x">模块过程</a>做准备。</p>
      <blockquote class="EoplFigure">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">defns-to-decls</span></span> : <span
                  class="texMathInline">\mathit{Listof(Defn)} \times \mathit{Tenv} \to \mathit{Decl}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">defns-to-decls</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">defns</span><span
                  class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">null?</span><span
                  class="hspace"> </span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">definition</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                  class="RktSym">defns</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">val-defn</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">var-name</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">ty</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">type-of</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                  class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span
                  class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktPn">(</span><span class="RktSym">new-env</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">extend-tenv</span><span class="hspace"> </span><span
                  class="RktSym">var-name</span><span class="hspace"> </span><span class="RktSym">ty</span><span
                  class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span class="RktSym">cons</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">val-decl</span><span class="hspace"> </span><span class="RktSym">var-name</span><span
                  class="hspace"> </span><span class="RktSym">ty</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">defns-to-decls</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">defns</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">new-env</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">type-defn</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">name</span><span class="hspace"> </span><span class="RktSym">ty</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">new-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                  class="RktSym">extend-tenv-with-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                    </span><span class="RktSym">name</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">expand-type</span><span
                  class="hspace"> </span><span class="RktSym">ty</span><span class="hspace"> </span><span
                  class="RktSym">tenv</span><span class="RktPn">)</span><span class="hspace"> </span><span
                  class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span class="RktSym">cons</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">transparent-type-decl</span><span class="hspace"> </span><span
                  class="RktSym">name</span><span class="hspace"> </span><span class="RktSym">ty</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">defns-to-decls</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">defns</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">new-env</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">add-module-defns-to-tenv</span></span> : <span
                  class="texMathInline">\mathit{Listof(ModuleDefn)} \times \mathit{Tenv} \to \mathit{Tenv}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">add-module-defns-to-tenv</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">defns</span><span
                  class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">null?</span><span
                  class="hspace"> </span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktSym">tenv</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">module-definition</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                  class="RktSym">defns</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">a-module-definition</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">m-name</span><span class="hspace"> </span><span
                  class="RktSym">expected-iface</span><span class="hspace"> </span><span
                  class="RktSym">m-body</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">actual-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">interface-of</span><span class="hspace"> </span><span class="RktSym">m-body</span><span
                  class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym"><:-iface< /span><span class="hspace"> </span><span
                      class="RktSym">actual-iface</span><span class="hspace"> </span><span
                      class="RktSym">expected-iface</span><span class="hspace"> </span><span
                      class="RktSym">tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktPn">(</span><span class="RktSym">new-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                      </span><span class="RktPn">(</span><span
                  class="RktSym">extend-tenv-with-module</span><span class="hspace"> </span><span
                  class="RktSym">m-name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                        </span><span class="RktPn">(</span><span
                  class="RktSym">expand-iface</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                          </span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktSym">expected-iface</span><span class="hspace"> </span><span
                  class="RktSym">tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                        </span><span class="RktSym">tenv</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">add-module-defns-to-tenv</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                  class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">defns</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">new-env</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">report-module-doesnt-satisfy-iface</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktSym">expected-iface</span><span class="hspace"> </span><span
                  class="RktSym">actual-iface</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
        <blockquote class="caption">
          <p>OPAQUE-TYPES 的检查器，第 1 部分<a name="(elem._fig-8..9)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">expand-iface</span></span> : <span
                  class="texMathInline">\mathit{Sym} \times \mathit{Iface} \times \mathit{Tenv} \to
                  \mathit{Iface}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">expand-iface</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktSym">iface</span><span class="hspace"> </span><span
                  class="RktSym">tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">interface</span><span class="hspace"> </span><span
                  class="RktSym">iface</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">simple-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">decls</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">simple-iface</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">expand-decls</span><span class="hspace"> </span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktSym">decls</span><span class="hspace"> </span><span
                  class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">expand-decls</span></span> : <span
                  class="texMathInline">\mathit{Sym} \times \mathit{Listof(Decl)} \times \mathit{Tenv} \to
                  \mathit{Listof(Decl)}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">expand-decls</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktSym">decls</span><span class="hspace"> </span><span
                  class="RktSym">internal-tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">null?</span><span
                  class="hspace"> </span><span class="RktSym">decls</span><span class="RktPn">)</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">declaration</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                  class="RktSym">decls</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">opaque-type-decl</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">t-name</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">expanded-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                  class="RktSym">qualified-type</span><span class="hspace"> </span><span
                  class="RktSym">m-name</span><span class="hspace"> </span><span class="RktSym">t-name</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span
                  class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktPn">(</span><span class="RktSym">new-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                    </span><span class="RktPn">(</span><span
                  class="RktSym">extend-tenv-with-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                      </span><span class="RktSym">t-name</span><span
                  class="hspace"> </span><span class="RktSym">expanded-type</span><span class="hspace"> </span><span
                  class="RktSym">internal-tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span class="RktSym">cons</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">transparent-type-decl</span><span class="hspace"> </span><span
                  class="RktSym">t-name</span><span class="hspace"> </span><span
                  class="RktSym">expanded-type</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">expand-decls</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">cdr</span><span
                  class="hspace"> </span><span class="RktSym">decls</span><span class="RktPn">)</span><span
                  class="hspace"> </span><span class="RktSym">new-env</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">transparent-type-decl</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">t-name</span><span class="hspace"> </span><span
                  class="RktSym">ty</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">expanded-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                  class="RktSym">expand-type</span><span class="hspace"> </span><span class="RktSym">ty</span><span
                  class="hspace"> </span><span class="RktSym">internal-tenv</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span
                  class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktPn">(</span><span class="RktSym">new-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                    </span><span class="RktPn">(</span><span
                  class="RktSym">extend-tenv-with-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                      </span><span class="RktSym">t-name</span><span
                  class="hspace"> </span><span class="RktSym">expanded-type</span><span class="hspace"> </span><span
                  class="RktSym">internal-tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span class="RktSym">cons</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">transparent-type-decl</span><span class="hspace"> </span><span
                  class="RktSym">t-name</span><span class="hspace"> </span><span
                  class="RktSym">expanded-type</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">expand-decls</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">cdr</span><span
                  class="hspace"> </span><span class="RktSym">decls</span><span class="RktPn">)</span><span
                  class="hspace"> </span><span class="RktSym">new-env</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">val-decl</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">var-name</span><span class="hspace"> </span><span class="RktSym">ty</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">expanded-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                  class="RktSym">expand-type</span><span class="hspace"> </span><span class="RktSym">ty</span><span
                  class="hspace"> </span><span class="RktSym">internal-tenv</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span class="RktSym">cons</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">val-decl</span><span class="hspace"> </span><span class="RktSym">var-name</span><span
                  class="hspace"> </span><span class="RktSym">expanded-type</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">expand-decls</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">cdr</span><span
                  class="hspace"> </span><span class="RktSym">decls</span><span class="RktPn">)</span><span
                  class="hspace"> </span><span class="RktSym">internal-tenv</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
        <blockquote class="caption">
          <p>OPAQUE-TYPES 的检查器，第 2 部分
            <a name="(idx._(gentag._1248))"></a><a name="(elem._fig-8..10)"></a>
          </p>
        </blockquote>
      </blockquote>
      <p>过程 <span class="stt">expand-decls</span> 遍历声明集合，创建新的类型环境，其中的每个类型和变量名都
        绑定到一个展开类型。麻烦之处是声明遵循 <span class="stt">let*</span> 式作用域：集合中的每个声明的作
        用域包含它之后的所有声明。
        <a name="(idx._(gentag._1249))"></a>
      </p>
      <p>要明白这意味着什么，考虑模块定义</p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt">module m1</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque t</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">transparent u = int</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">transparent uu = (t ->
                  u)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">% A 处</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">f : uu</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">...]</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[...]</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>要满足不变式，类型环境中的 <span class="stt">m1</span> 应绑定到包含如下声明的接口</p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt">[transparent t = from m1 take t</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">transparent u = int</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">transparent uu = (from m1 take
                  t -> int)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">f : (from m1 take t ->
                  int)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">...]</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>只要我们这样做，不论何时我们从类型环境中查询类型时，得到的都是期望的展开类型。</p>
      <p>在 A 处，紧随声明 <span class="stt">f</span> 之后，类型环境应绑定到</p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0">
          <tr>
            <td>
              <p><span class="stt">t</span></p>
            </td>
            <td>
              <p><span class="hspace"> </span></p>
            </td>
            <td>
              <p>绑定到</p>
            </td>
            <td>
              <p><span class="hspace"> </span></p>
            </td>
            <td>
              <p><span class="stt">from m1 take t</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">u</span></p>
            </td>
            <td>
              <p><span class="hspace"> </span></p>
            </td>
            <td>
              <p>绑定到</p>
            </td>
            <td>
              <p><span class="hspace"> </span></p>
            </td>
            <td>
              <p><span class="stt">int</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">uu</span></p>
            </td>
            <td>
              <p><span class="hspace"> </span></p>
            </td>
            <td>
              <p>绑定到</p>
            </td>
            <td>
              <p><span class="hspace"> </span></p>
            </td>
            <td>
              <p><span class="stt">(from m1 take t -> int)</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>我们把类似上面 A 处的类型环境称为<span class="emph">内部</span>类型环境。它作为参数传给
        <span class="stt">expand-decls</span>。
      </p>
      <p>现在我们可以写出 <span class="stt">expand-decls</span>。像 <span class="stt">defns-to-decls</span>，这个过程只创建透明声
        明，因为它的用途就是创建查询受限类型所用的数据结构。</p>
      <p>最后，我们修改 <span class="stt"><:-decls< /span>，处理两种新声明。我们必须处理声明集合内部的作用域关
            系。例如，如果我们比较</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">[transparent t = int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">x : bool</span><span class="hspace">                </span><span class="stt">
                    <:< /span><span class="hspace">    </span><span class="stt">[y : int]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">y : t]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>处理声明 <span class="stt">y</span> 时，我们需要知道 <span class="stt">t</span> 指代 <span class="stt">int</span>
          类型。所以，当我们递归向下
          处理声明列表时，我们需要随之扩展类型环境，就像在 <span class="stt">expand-decls</span> 中生成
          <span class="stt">internal-tenv</span> 一样。我们调用 <span class="stt">extend-tenv-with-decl</span> 处理这些，它取一声
          明，根据类型环境将其展开为适当的类型（<span class="EoplFigureRef"></span>）。
        </p>
      </blockquote>
      <blockquote class="EoplFigure">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt"><:-decls< /span></span> : <span
                    class="texMathInline">\mathit{Listof(Decl)} \times \mathit{Listof(Decl)} \times \mathit{Tenv} \to
                    \mathit{Bool}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym"><:-decls< /span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">decls1</span><span
                  class="hspace"> </span><span class="RktSym">decls2</span><span class="hspace"> </span><span
                  class="RktSym">tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cond</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">decls2</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">#t</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">#f</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">else</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">name1</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">decl->name</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">name2</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">decl->name</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">decls2</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">eqv?</span><span
                  class="hspace"> </span><span class="RktSym">name1</span><span class="hspace"> </span><span
                  class="RktSym">name2</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span class="RktSym">and</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span class="RktSym"><:-decl<
                    /span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">decls2</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span class="RktSym"><:-decls<
                    /span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">decls2</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">extend-tenv-with-decl</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                  class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span class="RktSym"><:-decls<
                    /span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">decls2</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">extend-tenv-with-decl</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">extend-tenv-with-decl</span></span> : <span
                  class="texMathInline">\mathit{Decl} \times \mathit{Tenv} \to \mathit{Tenv}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">extend-tenv-with-decl</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">decl</span><span
                  class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">declaration</span><span class="hspace"> </span><span
                  class="RktSym">decl</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">val-decl</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">name</span><span class="hspace"> </span><span class="RktSym">ty</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">transparent-type-decl</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">name</span><span class="hspace"> </span><span
                  class="RktSym">ty</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">extend-tenv-with-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktSym">name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">expand-type</span><span class="hspace"> </span><span class="RktSym">ty</span><span
                  class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktSym">tenv</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">opaque-type-decl</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">name</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">extend-tenv-with-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktSym">name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">qualified-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">fresh-module-name</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">%unknown</span><span class="RktPn">)</span><span class="hspace"> </span><span
                  class="RktSym">name</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktSym">tenv</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
        <blockquote class="caption">
          <p>OPAQUE-TYPES 的检查器，第 3 部分
            <a name="(idx._(gentag._1250))"></a><a name="(elem._fig-8..11)"></a>
          </p>
        </blockquote>
      </blockquote>
      <p>在展开过程中，我们总是用 <span class="stt">decls1</span>。欲知其原因，考虑比较</p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt">[transparent t = int</span><span class="hspace">           </span><span
                  class="stt">[opaque t</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">transparent u = (t -> t)</span><span class="hspace">  </span><span class="stt">
                  <:< /span><span class="hspace">    </span><span class="stt">transparent u = (t -> int)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">f : (t -> u)]</span><span class="hspace">                   </span><span
                  class="stt">f : (t -> (int -> int))]</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>这一比较应该通过，因为当模块主体提供左侧的绑定时，也是右侧接口的正确实现。</p>
      <p>比较类型 <span class="stt">u</span> 的两个定义时，我们得知道类型 <span class="stt">t</span> 实际上是 <span
          class="stt">int</span>。即使左边
        的声明没有出现在右边，同样的技巧也适用，就像上面第一个例子中的声明 <span class="stt">t</span> 所展示
        的。我们调用 <span class="stt">expand-type</span> 来维持不变式“类型环境中的所有类型均
        已展开”。<span class="stt">extend-tenv-with-decl</span> 最后一句中选什么模块名无关紧要，
        因为受限类型支持的唯一操作是 <span class="stt">equal?</span>。所以用 <span class="stt">fresh-module-name</span> 足以保证
        这一受限类型是新生成的。</p>
      <p>现在来处理关键问题：如何比较声明？仅当二者使用相同的名字（变量或类型）时，声明才
        能匹配。如果一对声明同名，有四种匹配方式：</p>
      <ul>
        <li>
          <p>二者均为值声明，且类型匹配。</p>
        </li>
        <li>
          <p>二者均为模糊类型声明。</p>
        </li>
        <li>
          <p>二者均为透明类型声明，且定义匹配。</p>
        </li>
        <li>
          <p><span class="stt">decl1</span> 为透明类型声明，<span class="stt">decl2</span> 为模糊类型声明。例如，假设有个模块
            的接口声明了 <span class="stt">opaque t</span>，主体中的定义为 <span class="stt">type t = int</span>，应当接受这种做法。
            过程 <span class="stt">defns-to-decls</span> 将定义 <span class="stt">type t = int</span> 转换为透明类型声明，所以
            <span class="stt">add-module-defns-to-tenv</span> 中的条件
          </p>
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">actual-iface <: expected-iface</span>
                  </p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>需要检查
            <span class="texMathDisplay"><span class="stt">(transparent </span><span class="texMathInline">t</span><span
                class="stt"> = int)</span>
              <: <span class="stt">(opaque
            </span><span class="texMathInline">t</span><span class="stt">)</span></span>
            是否成立。
          </p>
          <p>由于这一模块应被接受，该项测试应返回真。</p>
          <p>这告诉我们，类型已知的对象总能作为类型未知的对象。反之则不然。例如，
            <span class="texMathDisplay"><span class="stt">(opaque </span><span class="texMathInline">t</span><span
                class="stt">)</span>
              <: <span class="stt">(transparent
            </span><span class="texMathInline">t</span><span class="stt"> = int)</span></span>
            应为假，因为模糊类型值的实际类型可能不是 <span class="stt">int</span>，而且满足 <span class="stt">opaque t</span> 的模
            块可能无法满足 <span class="stt">transparent t = int</span>。
          </p>
        </li>
      </ul>
      <p>
      <div class="SIntrapara">这样，我们就得出<span class="EoplFigureRef"></span> 中的代码。<span class="stt">equiv-type?</span>
        的定义扩展其类
        型，所以，在上面的例子
      </div>
      <div class="SIntrapara">
        <blockquote class="Small">
          <blockquote class="SCentered">
            <p><span class="stt">[transparent t = int x : bool y : t] <: [y : int]</span>
            </p>
          </blockquote>
        </blockquote>
      </div>
      <div class="SIntrapara">
        <blockquote class="SubFlow">
          <p>中，左边的 <span class="stt">t</span> 展开为 <span class="stt">int</span>，匹配成功。
            <a name="(idx._(gentag._1251))"></a>
            <a name="(idx._(gentag._1252))"></a>
          </p>
        </blockquote>
      </div>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..16)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._1253))"></a>
          <a name="(idx._(gentag._1254))"></a>
          <a name="(idx._(gentag._1255))"></a>
          用<span class="EoplExerciseRef"></span> 中的语言扩展本节的系统，然后重写<span class="EoplExerciseRef"></span>，
          用多参数过程代替返回过程的过程。
          <a name="(idx._(gentag._1256))"></a>
          <a name="(idx._(gentag._1257))"></a>
          <a name="(idx._(gentag._1258))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..17)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>仿照<span
            class="EoplExerciseRef"></span>，允许模块以不同于接口声明的顺序产生值。但是记住，定义——
          尤其是类型的定义——必须遵守定界规则。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..18)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>我们代码依赖的不变式是：类型环境中的所有类型均已展开。我们在代码中多次调用
          <span class="stt">expand-type</span> 来维持这一不变式。这就很容易因忘记调用 <span class="stt">expand-type</span> 而破坏
          系统。重构代码，减少 <span class="stt">expand-type</span> 的调用，以便更稳定地维持不变式。
          <a name="(idx._(gentag._1259))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt"><:-decl< /span></span> : <span
                      class="texMathInline">\mathit{Decl} \times \mathit{Decl} \times \mathit{Tenv} \to
                      \mathit{Bool}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym"><:-decl< /span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">decl1</span><span
                    class="hspace"> </span><span class="RktSym">decl2</span><span class="hspace"> </span><span
                    class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">or</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">and</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">val-decl?</span><span class="hspace"> </span><span class="RktSym">decl1</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">val-decl?</span><span class="hspace"> </span><span class="RktSym">decl2</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">equiv-type?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">decl->type</span><span class="hspace"> </span><span class="RktSym">decl1</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">decl->type</span><span class="hspace"> </span><span class="RktSym">decl2</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">and</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">transparent-type-decl?</span><span class="hspace"> </span><span
                    class="RktSym">decl1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">transparent-type-decl?</span><span class="hspace"> </span><span
                    class="RktSym">decl2</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">equiv-type?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">decl->type</span><span class="hspace"> </span><span class="RktSym">decl1</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">decl->type</span><span class="hspace"> </span><span class="RktSym">decl2</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">and</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">transparent-type-decl?</span><span class="hspace"> </span><span
                    class="RktSym">decl1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">opaque-type-decl?</span><span class="hspace"> </span><span
                    class="RktSym">decl2</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">and</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">opaque-type-decl?</span><span class="hspace"> </span><span
                    class="RktSym">decl1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">opaque-type-decl?</span><span class="hspace"> </span><span
                    class="RktSym">decl2</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">equiv-type?</span></span> : <span
                    class="texMathInline">\mathit{Type} \times \mathit{Type} \times \mathit{Tenv} \to
                    \mathit{Bool}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">equiv-type?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">ty1</span><span
                    class="hspace"> </span><span class="RktSym">ty2</span><span class="hspace"> </span><span
                    class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">equal?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">expand-type</span><span class="hspace"> </span><span class="RktSym">ty1</span><span
                    class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">expand-type</span><span class="hspace"> </span><span class="RktSym">ty2</span><span
                    class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>OPAQUE-TYPES 的检查器，第 4 部分
            <a name="(idx._(gentag._1260))"></a>
            <a name="(idx._(gentag._1261))"></a>
            <a name="(idx._(gentag._1262))"></a><a name="(elem._fig-8..12)"></a>
          </p>
        </blockquote>
      </blockquote>
      <h4>8.3<tt> </tt><a name="(part._s8..3)"></a>模块过程</h4>
      <p><a name="(idx._(gentag._1263))"></a>
        <a name="(idx._(gentag._1264))"></a>
        <a name="(idx._(gentag._1265))"></a>
        <a name="(idx._(gentag._1266))"></a>
        OPAQUE-TYPES 中的程序有固定的依赖关系。模块 <span class="stt">m4</span> 可能依赖 <span class="stt">m3</span> 和 <span
          class="stt">m2</span>，
        <span class="stt">m2</span> 依赖 <span class="stt">m1</span>。有时，我们说依赖关系是<span class="emph">硬编码</span> (<span
          class="emph">hard-coded</span>) 的。通常，
        这种硬编码的依赖关系会导致糟糕的程序设计，因为这使模块难以复用。本节，我们给系统
        添加名为<span class="emph">模块过程</span> (<span class="emph">module procedure</span>)（有时又称<span
          class="emph">参数化模块</span> (<span class="emph">parameterized
          module</span>)）的组件，以便复用模块。我们称这种新语言为PROC-MODULES。
      </p>
      <h5>8.3.1<tt> </tt><a name="(part._s8..3..1)"></a>例子</h5>
      <p>再来看我们的三位开发者。查理想用爱丽丝模块的某些组件。但爱丽丝的模块使用了鲍伯模
        块提供的数据库，而查理想用另一数据库，由其他模块提供（戴安娜所写）。</p>
      <p>要实现这些，爱丽丝用模块过程重写她的代码。模块过程就像过程，但它处理的是模块，而
        非表达值。在模块层面上，接口就像类型。就像 CHECKED 中的过程类型指定参数和结果类
        型，模块过程的接口指定参数的接口和结果的接口。</p>
      <p>爱丽丝写出新的模块 <span class="stt">Alices-point-builder</span>，开头为</p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt">module Alices-point-builder</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">  </span><span class="stt">((database : [opaque
                  db-type</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">                </span><span class="stt">opaque
                  node-type</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">                </span><span class="stt">insert-node :
                  (node-type -></span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">                               </span><span
                  class="stt">(db-type -> db-type))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">                </span><span class="stt">...])</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">=> [opaque point</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">       </span><span class="stt">initial-point : (int ->
                  point)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">       </span><span class="stt">...])</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>这套接口说的是，<span class="stt">Alices-point-builder</span> 是一模块过程。它期望的参数是一个模块，
        该模块输出两个类型，<span class="stt">db-type</span> 和 <span class="stt">node-type</span>，一个过程，<span
          class="stt">insert-node</span>，
        可能还有其他一些值。给定这个模块，<span class="stt">Alices-point-builder</span> 应生成一个模块，生成
        的模块输出模糊类型 <span class="stt">point</span>，过程 <span class="stt">initial-point</span>，还可能有其他一些值。
        <span class="stt">Alices-point-builder</span> 的接口还指定了参数的局部名称；稍后我们将看到为何需要它。
      </p>
      <p>爱丽丝的新模块主体开头为</p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt">body</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">module-proc (m : [opaque
                  db-type</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">opaque
                  node-type</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">insert-node :
                  (node-type -></span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">                                  </span><span
                  class="stt">(db-type -> db-type))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">...])</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[type point = ...</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">initial-point = ... from m
                  take insert-node ...</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">...]</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>就像一般的过程表达式形如</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">proc (</span><span class="texMathInline">var</span><span class="stt"></span><span
                    class="hspace"> </span><span class="stt">: </span><span class="texMathInline">t</span><span
                    class="stt">) </span><span class="texMathInline">e</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>模块过程形如</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module-proc (</span><span class="texMathInline">m</span><span
                    class="stt"></span><span class="hspace"> </span><span class="stt">: [...]) [...]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>本例中，爱丽丝选择 <span class="stt">m</span> 作为模块过程中绑定变量的名字；它不必和接口中的局部名字
        相同。我们需要再写一遍参数的接口，因为模块接口的作用域不包含模块主体。可以免除这
        一限制（见<span class="EoplExerciseRef"></span>）。</p>
      <p>现在，爱丽丝把她的模块重写为</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module Alices-points</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque point</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">initial-point : (int ->
                    point)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">...]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">(Alices-point-builder
                    Bobs-db-module)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>查理的模块写成</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module Charlies-points</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque point</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">initial-point : (int ->
                    point)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">...]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">(Alices-point-builder
                    Dianas-db-module)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>模块 <span class="stt">Alices-points</span> 使用 <span class="stt">Bobs-db-module</span> 处理数据库。模块
        <span class="stt">Charlies-points</span> 使用 <span class="stt">Dianas-db-module</span> 处理数据库。这样组织可以复用
        <span class="stt">Alices-point-builder</span> 中的代码。这不仅避免了写两次同样的代码，而且，在代码需
        要变动时，可以只改一处，自动传播到 <span class="stt">Alices-point</span> 和 <span class="stt">Charlies-points</span> 中。
      </p>
      <p>另一个例子，考虑<span class="EoplExampleRef"></span> 和<span class="EoplExampleRef"></span>。在这两个例子中，
        我们用基本相同的代码写 <span class="stt">to-int</span>。在<span class="EoplExampleRef"></span> 中它是</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">letrec int to-int (x : from ints1 take t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">= if (z? x)</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">              </span><span class="stt">then 0</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">              </span><span class="stt">else -((to-int
                    (p x)), -1)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>在<span class="EoplExampleRef"></span> 中，<span class="stt">x</span> 的类型是 <span class="stt">from ints2 take
            t</span>。所以我们重写
          为参数化的模块，参数模块产生所需的整数。</p>
      </blockquote>
      <blockquote class="EoplExample">
        <p><a name="(elem._eg-8..14)"></a>声明</p>
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">module to-int-maker</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">((ints : [opaque t</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">            </span><span class="stt">zero : t</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">            </span><span class="stt">succ : (t ->
                      t)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">            </span><span class="stt">pred : (t ->
                      t)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">            </span><span class="stt">is-zero : (t ->
                      bool)])</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">=> [to-int : (from ints
                      take t -> int)])</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">module-proc (ints :
                      [opaque t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">               </span><span class="stt">zero :
                      t</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">               </span><span class="stt">succ : (t ->
                      t)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">               </span><span class="stt">pred : (t ->
                      t)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">               </span><span class="stt">is-zero : (t
                      -> bool)])</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">[to-int</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">     </span><span class="stt">= let z? = from ints
                      take is-zero</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">       </span><span class="stt">in let p = from ints
                      take pred</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">       </span><span class="stt">in letrec int to-int
                      (x : from ints take t)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">                      </span><span class="stt">= if
                      (z? x)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">                        </span><span class="stt">then
                      0</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">                        </span><span class="stt">else
                      -((to-int (p x)), -1)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">       </span><span class="stt">in to-int]</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>定义了一个模块过程。这套接口说的是，该模块取模块 <span class="stt">ints</span>，生成另一模块；
            <span class="stt">ints</span> 实现算术操作的接口，生成的模块输出过程 <span class="stt">to-int</span>，将 <span
              class="stt">ints</span> 中的
            类型 <span class="stt">t</span> 转换为整数。得出的过程 <span class="stt">to-int</span> 不能依赖算术操作的实现，因为我们
            根本不知道实现是什么！这段代码中，<span class="stt">ints</span> 声明了两次：一次在接口中，一次在主体
            中。像我们之前说的，这是因为接口声明的作用域只限于接口，不包含模块主体。
          </p>
        </blockquote>
      </blockquote>
      <p>我们再来看使用 <span class="stt">to-int</span> 的一些例子：</p>
      <blockquote class="EoplExample">
        <p>
        <div class="SIntrapara"><a name="(elem._eg-8..15)"></a>
        </div>
        <div class="SIntrapara">
          <blockquote class="SubFlow">
            <blockquote class="EoplCodeInset">
              <table cellspacing="0" cellpadding="0" class="SVerbatim">
                <tr>
                  <td>
                    <p><span class="stt">module to-int-maker </span><span class="emph">...同前...</span><span
                        class="stt"></span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">module ints1 </span><span class="emph">...同前...</span><span class="stt"></span>
                    </p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">module ints1-to-int</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface [to-int : (from
                        ints1 take t -> int)]</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">  </span><span class="stt">(to-int-maker
                        ints1)</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">let two1 = (from ints1 take succ</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">            </span><span class="stt">(from ints1
                        take succ</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">             </span><span class="stt">from ints1
                        take zero))</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">in (from ints1-to-int take to-int</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace">    </span><span class="stt">two1)</span></p>
                  </td>
                </tr>
              </table>
            </blockquote>
            <p>类型为 <span class="stt">int</span>，值为 2。因为我们首先定义了模块 <span class="stt">to-int-maker</span> 和 <span
                class="stt">ints1</span>。
              然后我们用 <span class="stt">ints1</span> 调用 <span class="stt">to-int-maker</span>，得到模块 <span
                class="stt">ints1-to-int</span>，它输出
              绑定 <span class="stt">from ints1-to-int take to-int</span>。</p>
          </blockquote>
        </div>
        </p>
      </blockquote>
      <p>下面这个例子两次使用 <span class="stt">to-int-maker</span>，处理两种不同的算术操作实现。</p>
      <blockquote class="EoplExample">
        <p>
        <div class="SIntrapara"><a name="(elem._eg-8..16)"></a>
        </div>
        <div class="SIntrapara">
          <blockquote class="SubFlow">
            <blockquote class="EoplCodeInset">
              <table cellspacing="0" cellpadding="0" class="SVerbatim">
                <tr>
                  <td>
                    <p><span class="stt">module to-int-maker </span><span class="emph">...同前...</span><span
                        class="stt"></span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">module ints1 </span><span class="emph">...同前...</span><span class="stt"></span>
                    </p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">module ints2 </span><span class="emph">...同前...</span><span class="stt"></span>
                    </p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">module ints1-to-int</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">interface [to-int : (from ints1 take t -> int)]</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">body (to-int-maker ints1)</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">module ints2-to-int</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">interface [to-int : (from ints2 take t -> int)]</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">body (to-int-maker ints2)</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">let s1 = from ints1 take succ</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">in let z1 = from ints1 take zero</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">in let to-ints1 = from ints1-to-int take to-int</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">in let s2 = from ints2 take succ</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">in let z2 = from ints2 take zero</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">in let to-ints2 = from ints2-to-int take to-int</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt"></span><span class="hspace"> </span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">in let two1 = (s1 (s1 z1))</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">in let two2 = (s2 (s2 z2))</span></p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <p><span class="stt">in -((to-ints1 two1), (to-ints2 two2))</span></p>
                  </td>
                </tr>
              </table>
            </blockquote>
            <p>类型为 <span class="stt">int</span>，值为 0。如果我们将 <span class="stt">(to-ints2 two2)</span> 替换为 <span
                class="stt">(to-ints2
                two1)</span>，则程序类型异常，因为 <span class="stt">to-ints2</span> 期望的参数类型是 <span class="stt">int2</span> 表示的算术
              操作，但值 <span class="stt">two1</span> 的类型是 <span class="stt">int1</span> 表示的算术操作。</p>
          </blockquote>
        </div>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..19)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><span class="EoplExampleRef"></span> 中，创建 <span class="stt">two1</span> 和 <span
            class="stt">two2</span> 的代码重复，因此可以抽象出
          来。完成模块定义</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module from-int-maker</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">((ints : [opaque t</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">zero : t</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">succ : (t ->
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">pred : (t ->
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">is-zero : (t ->
                    bool)])</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">=> [from-int : (int ->
                    from ints take t)])</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">...</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>用模块 <span class="stt">ints</span>表示整数表达值。用你的模块重做<span class="EoplExampleRef"></span> 中的计算。用
          大于 2 的参数测试。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..20)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._1267))"></a>
          完成模块定义</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module sum-prod-maker</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">((ints : [opaque t</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">zero : t</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">succ : (t ->
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">pred : (t ->
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">is-zero : (t ->
                    bool)])</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">=> [plus : (from ints take
                    t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                </span><span class="stt">-> (from ints
                    take t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                    </span><span class="stt">-> from
                    ints take t))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">        </span><span class="stt">times : (from ints
                    take t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                 </span><span class="stt">-> (from ints
                    take t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                     </span><span class="stt">-> from
                    ints take t))])</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[plus = ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">times = ...]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>定义一个模块过程，它取一算术操作的实现，生成用这种实现的求和和求积的过程。用
          <span class="stt">plus</span>中的 <span class="stt">plus</span> 定义，以及类似的 <span class="stt">times</span> 定义。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..21)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写一个模块过程，取算术操作的实现 <span class="stt">ints</span>，返回算术操作的另一种实现，其中，整数
          <span class="texMathInline">k</span> 以 <span class="stt">ints</span> 中的 <span class="texMathInline">2*k</span>
          表示。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..22)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>完成模块定义</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module equality-maker</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">((ints : [opaque t</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">zero : t</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">succ : (t ->
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">pred : (t ->
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">is-zero : (t ->
                    bool)])</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">=> [equal : (from ints
                    take t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                 </span><span class="stt">-> (from ints
                    take t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                     </span><span class="stt">->
                    bool))])</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">...</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>定义一个模块过程，它取一算术操作的实现，生成一过程，用这种实现做相等比较。
          <a name="(idx._(gentag._1268))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..23)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._1269))"></a>
          写出模块 <span class="stt">table-of</span>，它与<span class="EoplExerciseRef"></span> 中的 <span
            class="stt">table</span> 模块类似，只是
          将表的内容参数化，这样就能用</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">module mybool-tables</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">[opaque table</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">empty : table</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">add-to-table : (int
                    -></span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">(from
                    mybool take t -></span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                    </span><span class="stt">(table ->
                    table)))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">lookup-in-table : (int
                    -></span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                      </span><span class="stt">(table
                    -></span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                       </span><span class="stt">from
                    mybool take t))]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">(table-of mybool)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>定义包含 <span class="stt">from mybool take t</span> 类型值的表。
          <a name="(idx._(gentag._1270))"></a>
        </p>
      </blockquote>
      <h5>8.3.2<tt> </tt><a name="(part._s8..3..2)"></a>实现</h5>
      <h5><a name="(part._s8..3-syntax)"></a>语法</h5>
      <p><a name="(idx._(gentag._1271))"></a>
        给我们的语言添加模块过程就像添加过程一样。模块过程的接口很像 <span class="stt">proc</span> 的类型。</p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*} \mathit{Iface} &::= <span class="stt">((</span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> : </span><span
              class="Iidentity">\mathit{Iface}</span><span class="stt">)) => </span><span
              class="Iidentity">\mathit{Iface}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">proc-iface (param-name param-iface
              result-iface)</span>}\end{align*}</span></p>
      </blockquote>
      <p>虽然这套接口看起来像是普通的过程类型，它还是有两处区别。首先，它描述了模块值到模
        块值的函数，而非表达值到表达值的函数。其次，不像过程类型，它要给函数的输入命名。
        这是必须的，因为输出的接口可能依赖输入的值，就像 <span class="stt">to-int-maker</span> 的类型那样：</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">((ints : [opaque t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">zero : t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">succ : (t ->
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">pred : (t ->
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">is-zero : (t ->
                    bool)])</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">=> [to-int : (from ints take
                    t -> int)])</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p><span class="stt">to-int-maker</span> 取一模块 <span class="stt">ints</span>，生成一模块，其类型不仅依赖 <span
            class="stt">ints</span> 中的
          固定类型，也依赖 <span class="stt">ints</span> 本身。<a name="(elem._module-proc-eg)"></a>当我们
          像<span class="EoplExampleRef"></span> 那样用 <span class="stt">ints1</span> 调用 <span
            class="stt">to-int-maker</span> 时，得到的模块
          接口是</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">[to-int : (from ints1 take t -> int)]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>而当我们用 <span class="stt">ints2</span> 调用时，得到的是另一个接口</p>
        <p>
        <div class="SIntrapara">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">[to-int : (from ints2 take t -> int)]</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._1272))"></a></div>
        </p>
      </blockquote>
      <p>我们扩展 <span class="stt">expand-iface</span> 来处理这些新接口，并按已展开处理。这样行得通是因为参
        数接口和结果接口在需要时自会展开。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">expand-iface</span></span> : <span
                  class="texMathInline">\mathit{Sym} \times \mathit{Iface} \times \mathit{Tenv} \to
                  \mathit{Iface}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">expand-iface</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-name</span><span
                  class="hspace"> </span><span class="RktSym">iface</span><span class="hspace"> </span><span
                  class="RktSym">tenv</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">interface</span><span class="hspace"> </span><span
                  class="RktSym">iface</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">simple-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">decls</span><span class="RktPn">)</span><span class="hspace"> </span><span
                  class="emph">...同前...</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">proc-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">param-name</span><span class="hspace"> </span><span
                  class="RktSym">param-iface</span><span class="hspace"> </span><span
                  class="RktSym">result-iface</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktSym">iface</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._1273))"></a>
        <a name="(idx._(gentag._1274))"></a>
        我们需要新的模块主体来创建模块过程，引用模块过程的绑定变量，以及调用模块过程。
      </p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*}\mathit{ModuleBody} &::= <span class="stt">module-proc (</span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> : </span><span
              class="Iidentity">\mathit{Iface}</span><span class="stt">) </span><span
              class="Iidentity">\mathit{ModuleBody}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">proc-module-body (m-name m-type m-body)</span>} \\[-5pt]
            \mathit{ModuleBody} &::= \mathit{Identifier} \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">var-module-body (m-name)</span>} \\[-5pt]
            \mathit{ModuleBody} &::= <span class="stt">(</span><span class="Iidentity">\mathit{Identifier}</span><span
              class="stt"> </span><span class="Iidentity">\mathit{Identifier}</span><span class="stt">)</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">app-module-body (rator rand)</span>}\end{align*}</span></p>
      </blockquote>
      <h5><a name="(part._s8..3-interpreter)"></a>解释器</h5>
      <p><a name="(idx._(gentag._1275))"></a>
        首先，类似过程，我们新增一种模块。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                  class="hspace"> </span><span class="RktSym">typed-module</span><span class="hspace"> </span><span
                  class="RktSym">typed-module?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">simple-module</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">bindings</span><span
                  class="hspace"> </span><span class="RktSym">environment?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">proc-module</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">b-var</span><span
                  class="hspace"> </span><span class="RktSym">symbol?</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">body</span><span
                  class="hspace"> </span><span class="RktSym">module-body?</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">saved-env</span><span
                  class="hspace"> </span><span class="RktSym">environment?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>我们扩展 <span class="stt">value-of-module-body</span> 处理新的模块主体。代码与表达式中的变量引用和
        过程调用十分类似（<span class="EoplFigureRef"></span>）。
        <a name="(idx._(gentag._1276))"></a>
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">value-of-module-body</span></span> : <span
                    class="texMathInline">\mathit{ModuleBody} \times \mathit{Env} \to \mathit{TypedModule}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">value-of-module-body</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-body</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">module-body</span><span class="hspace"> </span><span
                    class="RktSym">m-body</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">defns-module-body</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">defns</span><span class="RktPn">)</span><span
                    class="hspace"> </span><span class="RktSym">...as</span><span class="hspace"> </span><span
                    class="RktSym">before...</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">var-module-body</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">m-name</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">lookup-module-name-in-env</span><span class="hspace"> </span><span
                    class="RktSym">m-name</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">proc-module-body</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">m-name</span><span class="hspace"> </span><span class="RktSym">m-type</span><span
                    class="hspace"> </span><span class="RktSym">m-body</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">proc-module</span><span class="hspace"> </span><span
                    class="RktSym">m-name</span><span class="hspace"> </span><span class="RktSym">m-body</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">app-module-body</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">rator</span><span class="hspace"> </span><span class="RktSym">rand</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">rator-val</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">lookup-module-name-in-env</span><span class="hspace"> </span><span
                    class="RktSym">rator</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">               </span><span class="RktPn">(</span><span
                    class="RktSym">rand-val</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                 </span><span class="RktPn">(</span><span
                    class="RktSym">lookup-module-name-in-env</span><span class="hspace"> </span><span
                    class="RktSym">rand</span><span class="hspace"> </span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">cases</span><span class="hspace"> </span><span
                    class="RktSym">typed-module</span><span class="hspace"> </span><span class="RktSym">rator-val</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">proc-module</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">m-name</span><span class="hspace"> </span><span class="RktSym">m-body</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">value-of-module-body</span><span class="hspace"> </span><span
                    class="RktSym">m-body</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">extend-env-with-module</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktSym">m-name</span><span
                    class="hspace"> </span><span class="RktSym">rand-val</span><span class="hspace"> </span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span class="RktSym">else</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">report-bad-module-app</span><span class="hspace"> </span><span
                    class="RktSym">rator-val</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <p>
        <div class="SIntrapara">
          <blockquote class="caption">
            <p><span class="stt">value-of-module-body</span><a name="(elem._fig-8..13)"></a></p>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._1277))"></a></div>
        </p>
      </blockquote>
      <h5><a name="(part._s8..3-checker)"></a>检查器</h5>
      <p>
      <div class="SIntrapara"><a name="(idx._(gentag._1278))"></a>
        <a name="(idx._(gentag._1279))"></a>
      </div>
      <div class="SIntrapara">
        <blockquote class="EoplFigure">
          <p>[!ht]<span class="texMathDisplay">\begin{array}{l}
              \small{\textrm{IFACE-M-VAR}} \\
              <span class="stt">(</span><span class="texMathInline">\rhd</span><span class="stt"> </span><span
                class="texMathInline">m</span><span class="stt"> </span><span class="texMathInline">tenv</span><span
                class="stt">)</span> = tenv<span class="stt">(</span><span class="texMathInline">m</span><span
                class="stt">)</span>
              \end{array}</span></p>
          <p><span class="texMathDisplay">\begin{array}{l}
              \small{\textrm{IFACE-M-PROC}} \\
              \infer{<span class="stt">(</span><span class="texMathInline">\rhd</span><span class="stt"> (m-proc
                (</span><span class="texMathInline">m</span><span class="stt">:</span><span
                class="texMathInline">i_1</span><span class="stt">) </span><span class="texMathInline">body</span><span
                class="stt">))</span> = <span class="stt">((</span><span class="texMathInline">m</span><span
                class="stt">:</span><span class="texMathInline">i_1</span><span class="stt">) => </span><span
                class="texMathInline">i^{\prime}_{1}</span><span class="stt">)</span>}
              {<span class="stt">(</span><span class="texMathInline">\rhd</span><span class="stt"> body [</span><span
                class="texMathInline">m</span><span class="stt">=</span><span class="texMathInline">i_1</span><span
                class="stt">]tenv)</span> = i^{\prime}}
              \end{array}</span></p>
          <p><span class="texMathDisplay">\begin{array}{l}
              \small{\textrm{IFACE-M-APP}} \\
              \infer{<span class="stt">(</span><span class="texMathInline">\rhd</span><span class="stt"> (</span><span
                class="texMathInline">m_1</span><span class="stt"> </span><span class="texMathInline">m_2</span><span
                class="stt">) tenv)</span> = <span class="stt">i((</span><span class="texMathInline">m</span><span
                class="stt">:</span><span class="texMathInline">i_1</span><span class="stt">) => </span><span
                class="texMathInline">i^{\prime}_{1}</span><span class="stt">)</span>}
              {\begin{array}{c}
              tenv(m_1) = <span class="stt">((</span><span class="texMathInline">m</span><span class="stt">:</span><span
                class="texMathInline">i_1</span><span class="stt">) => </span><span
                class="texMathInline">i^{\prime}_{1}</span><span class="stt">)</span> \quad tenv(<span
                class="texMathInline">m_2</span>) = <span class="texMathInline">i_2</span> \\
              i_2 <: i_1 \end{array}} \end{array}</span>
          </p>
          <blockquote class="caption">
            <p>新模块主体的判类规则<a name="(elem._fig-8..14)"></a></p>
          </blockquote>
        </blockquote>
      </div>
      </p>
      <p>我们可以给新的模块主体写出<a href="types.html#%28part._s7..2%29" data-pltdoc="x">赋予表达值类型</a>那样的规则。这些规则
        如<span class="EoplFigureRef"></span> 所示。为了能在一页纸内写下规则，我们用 <span class="stt">(</span><span
          class="texMathInline">\rhd</span><span class="stt">
        </span><span class="texMathInline">body</span><span class="stt"> </span><span
          class="texMathInline">tenv</span><span class="stt">) = </span><span class="texMathInline">i</span> 代替 <span
          class="stt">(interface-of </span><span class="texMathInline">body</span><span class="stt"> </span><span
          class="texMathInline">tenv</span><span class="stt">) = </span><span class="texMathInline">i</span>。</p>
      <p>正如预想的那样，模块变量的类型从类型环境中取得。就像 CHECKED 中的过程那样，
        <span class="stt">module-proc</span> 的类型根据参数类型和主体类型得到。
      </p>
      <p>模块过程的调用很像 CHECKED 中的过程调用，但有两个重要区别。</p>
      <p>首先，操作数的类型（规则 IFACE-M-APP 中的 <span class="texMathInline">i_2</span>）不必与参数类型 (<span
          class="texMathInline">i_1</span>) 相同。
        我们只要求 <span class="texMathInline">i_2 <: i_1</span>。这就够了，因为 <span class="texMathInline">i_2 <: i_1</span>
                意味着满足接口 <span class="texMathInline">i_2</span>
                的任意模块都满足接口 <span class="texMathInline">i_1</span>，也就能作为模块过程的参数。</p>
      <p>其次，在结果类型 <span class="texMathInline">t^{\prime}_{1}</span> 中，我们把 <span class="texMathInline">m</span> 代换为操作数
        <span class="texMathInline">m_2</span>。考虑
        <span class="stt">module-proc-eg</span>的例子。其中，我们用 <span class="stt">ints1</span> 和 <span
          class="stt">ints2</span> 调用模块过
        程 <span class="stt">to-int-maker</span>，其接口为
      </p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">((ints : [opaque t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">zero : t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">succ : (t ->
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">pred : (t ->
                    t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">is-zero : (t ->
                    bool)])</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">=> [to-int : (from ints take
                    t -> int)])</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>当我们用 <span class="stt">ints1</span> 调用 <span class="stt">to-int-maker</span>，代换而得的接口为</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">[to-int : (from ints1 take t -> int)]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>当我们用 <span class="stt">ints2</span> 调用 <span class="stt">to-int-maker</span>，代换而得的接口为</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">[to-int : (from ints2 take t -> int)]</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>正合期望。</p>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">interface-of</span></span> : <span
                    class="texMathInline">\mathit{ModuleBody} \times \mathit{Tenv} \to \mathit{Iface}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">interface-of</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-body</span><span
                    class="hspace"> </span><span class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">module-body</span><span class="hspace"> </span><span
                    class="RktSym">m-body</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">var-module-body</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">m-name</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">lookup-module-name-in-tenv</span><span class="hspace"> </span><span
                    class="RktSym">tenv</span><span class="hspace"> </span><span class="RktSym">m-name</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">defns-module-body</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">defns</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">simple-iface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">defns-to-decls</span><span class="hspace"> </span><span
                    class="RktSym">defns</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">app-module-body</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">rator-id</span><span class="hspace"> </span><span class="RktSym">rand-id</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">rator-iface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">lookup-module-name-in-tenv</span><span class="hspace"> </span><span
                    class="RktSym">tenv</span><span class="hspace"> </span><span class="RktSym">rator-id</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">               </span><span class="RktPn">(</span><span
                    class="RktSym">rand-iface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                 </span><span class="RktPn">(</span><span
                    class="RktSym">lookup-module-name-in-tenv</span><span class="hspace"> </span><span
                    class="RktSym">tenv</span><span class="hspace"> </span><span class="RktSym">rand-id</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">cases</span><span class="hspace"> </span><span class="RktSym">interface</span><span
                    class="hspace"> </span><span class="RktSym">rator-iface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">simple-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">decls</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">report-attempt-to-apply-simple-module</span><span class="hspace"> </span><span
                    class="RktSym">rator-id</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">proc-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">param-name</span><span class="hspace"> </span><span
                    class="RktSym">param-iface</span><span class="hspace"> </span><span
                    class="RktSym">result-iface</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym"><:-iface< /span><span class="hspace"> </span><span
                        class="RktSym">rand-iface</span><span class="hspace"> </span><span
                        class="RktSym">param-iface</span><span class="hspace"> </span><span
                        class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">rename-in-iface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktSym">result-iface</span><span
                    class="hspace"> </span><span class="RktSym">param-name</span><span class="hspace"> </span><span
                    class="RktSym">rand-id</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">report-bad-module-application-error</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktSym">param-iface</span><span
                    class="hspace"> </span><span class="RktSym">rand-iface</span><span class="hspace"> </span><span
                    class="RktSym">m-body</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">proc-module-body</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">rand-name</span><span class="hspace"> </span><span
                    class="RktSym">rand-iface</span><span class="hspace"> </span><span class="RktSym">m-body</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">body-iface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">interface-of</span><span class="hspace"> </span><span class="RktSym">m-body</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                    class="RktSym">extend-tenv-with-module</span><span class="hspace"> </span><span
                    class="RktSym">rand-name</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                    </span><span class="RktPn">(</span><span
                    class="RktSym">expand-iface</span><span class="hspace"> </span><span
                    class="RktSym">rand-name</span><span class="hspace"> </span><span
                    class="RktSym">rand-iface</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                    </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">proc-iface</span><span class="hspace"> </span><span
                    class="RktSym">rand-name</span><span class="hspace"> </span><span
                    class="RktSym">rand-iface</span><span class="hspace"> </span><span
                    class="RktSym">body-iface</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>PROC-MODULES的检查器，第1部分
            <a name="(idx._(gentag._1280))"></a>
            <a name="(idx._(gentag._1281))"></a>
            <a name="(idx._(gentag._1282))"></a><a name="(elem._fig-8..15)"></a>
          </p>
        </blockquote>
      </blockquote>
      <p>用这些规则，很容易写出 <span class="stt">interface-of</span> 的代码（<span class="EoplFigureRef"></span>）。当我们
        检查 <span class="stt">module-proc</span> 的主体时，我们把参数添加到类型环境中，就好像它是位于顶层的
        模块。这段代码用过程 <span class="stt">rename-in-iface</span> 对得到的接口进行代换。</p>
      <p>最后，我们扩展 <span class="stt"><:-iface< /span>，处理新的类型。用来比较 <span class="stt">proc-iface</span> 的规则为</p>
      <blockquote class="Small">
        <p><span class="texMathDisplay">\infer{<span class="stt">((</span><span class="texMathInline">m_1</span><span
              class="stt"> : </span><span class="texMathInline">i_1</span><span class="stt">) => </span><span
              class="texMathInline">i^{\prime}_{1}</span><span class="stt">)</span>
            <: <span class="stt">((
          </span><span class="texMathInline">m_2</span><span class="stt"> : </span><span
            class="texMathInline">i_2</span><span class="stt">) => </span><span
            class="texMathInline">i^{\prime}_{2}</span><span class="stt">)</span>}
          {i_2 <: i_1 & i^{\prime}_{1}<span class="stt">[</span><span class="texMathInline">m^{\prime}/m_{1}</span><span
              class="stt">]</span>
            <: i^{\prime}_{2}<span class="stt">[</span><span class="texMathInline">m^{\prime}/m_{2}</span><span
                class="stt">]</span> &
              m^{\prime} 不在 i^{\prime}_{1} 或 i^{\prime}_{2} 中}</span></p>
      </blockquote>
      <p>要使 <span class="stt">((</span><span class="texMathInline">m_1</span><span class="stt"> : </span><span
          class="texMathInline">i_1</span><span class="stt">) => </span><span
          class="texMathInline">i^{\prime}_{1}</span><span class="stt">)</span>，满足第一个接口的模块
        <span class="texMathInline">m_0</span> 也必须满足第二个接口。这就是说，接口为 <span class="texMathInline">i_2</span> 的任何模块都能作为参数，
        传给 <span class="texMathInline">m_0</span>，<span class="texMathInline">m_0</span> 产生的任何模块都满足 <span
          class="texMathInline">i^{\prime}_{2}</span>。
      </p>
      <p>为满足第一个要求，我们要求 <span class="texMathInline">i_2 <: i_1</span>。这保证了满足 <span class="texMathInline">i_2</span>
            的任何模块都能作
            为参数传给 <span class="texMathInline">m_0</span>。注意逆序：我们说参数类型的<span class="emph">子类型判定</span> (<span
              class="emph">subtyping</span>)
            是<span class="emph">逆变的</span> (<span class="emph">contravariant</span>)。
            <a name="(idx._(gentag._1283))"></a></p>
      <p>结果的类型呢？我们可以要求 <span class="texMathInline">i^{\prime}_{1} <: i^{\prime}_{2}</span>。不幸的是，这行
            不通。<span class="texMathInline">i^{\prime}_{1}</span> 中，可能出现模块变量 <span class="texMathInline">m_1</span>，<span
              class="texMathInline">i^{\prime}_{2}</span> 中，可
            能出现模块变量 <span class="texMathInline">m_2</span> 的实例。所以，要比较它们，我们得将 <span class="texMathInline">m_1</span> 和
            <span class="texMathInline">m_2</span> 重
            命名为新的模块变量 <span class="texMathInline">m^{\prime}</span>。一旦完成这一步，我们就能照常比较它们了。这就
            得出条件 <span class="texMathInline">i^{\prime}_{1}<span class="stt">[</span><span
                class="texMathInline">m^{\prime}/m_{1}</span><span class="stt">]</span>
              <: i^{\prime}_{2}<span class="stt">[
            </span><span class="texMathInline">m^{\prime}/m_{2}</span><span class="stt">]</span></span>。</p>
      <p>判断这种关系的代码较为直白（<span class="EoplFigureRef"></span>）。判断
        <span class="texMathInline">i^{\prime}_{1}<span class="stt">[</span><span
            class="texMathInline">m^{\prime}/m_{1}</span><span class="stt">]</span>
          <: i^{\prime}_{2}<span class="stt">[
        </span><span class="texMathInline">m^{\prime}/m_{2}</span><span class="stt">]</span></span> 时，我们扩展类型环境，给
        <span class="texMathInline">m^{\prime}</span> 添加绑定。由于 <span class="texMathInline">i_1</span> 的比 <span
          class="texMathInline">i_2</span> 小，我们将 <span class="texMathInline">m^{\prime}</span> 与
        它关联起来。我们调用 <span class="stt">extend-tenv-with-module</span> 比较结果的类型时，还要调用
        <span class="stt">expand-iface</span> 维持不变式。
      </p>
      <p><a name="(idx._(gentag._1284))"></a>
        现在，完成了。吃杯圣代吧，放些奶油<span class="emph">口</span>味、热浇汁<span class="emph">口</span>味、还有
        坚果<span class="emph">口</span>味的佐料。怎么组合不要紧，好吃就行！
        <a name="(idx._(gentag._1285))"></a>
        <a name="(idx._(gentag._1286))"></a>
        <a name="(idx._(gentag._1287))"></a>
        <a name="(idx._(gentag._1288))"></a>
        <a name="(idx._(gentag._1289))"></a>
        <a name="(idx._(gentag._1290))"></a>
        <a name="(idx._(gentag._1291))"></a>
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt"><:-iface< /span></span> : <span
                      class="texMathInline">\mathit{Iface} \times \mathit{Iface} \times \mathit{Tenv} \to
                      \mathit{Bool}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym"><:-iface< /span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">iface1</span><span
                    class="hspace"> </span><span class="RktSym">iface2</span><span class="hspace"> </span><span
                    class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">interface</span><span class="hspace"> </span><span
                    class="RktSym">iface1</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">simple-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">decls1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">cases</span><span class="hspace"> </span><span class="RktSym">interface</span><span
                    class="hspace"> </span><span class="RktSym">iface2</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">simple-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">decls2</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span class="RktSym"><:-decls<
                      /span><span class="hspace"> </span><span class="RktSym">decls1</span><span
                        class="hspace"> </span><span class="RktSym">decls2</span><span class="hspace"> </span><span
                        class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">proc-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">param-name2</span><span class="hspace"> </span><span
                    class="RktSym">param-iface2</span><span class="hspace"> </span><span
                    class="RktSym">result-iface2</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktVal">#f</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">proc-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">param-name1</span><span class="hspace"> </span><span
                    class="RktSym">param-iface1</span><span class="hspace"> </span><span
                    class="RktSym">result-iface1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">cases</span><span class="hspace"> </span><span class="RktSym">interface</span><span
                    class="hspace"> </span><span class="RktSym">iface2</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">simple-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">decls2</span><span class="RktPn">)</span><span class="hspace"> </span><span
                    class="RktVal">#f</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">proc-iface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">param-name2</span><span class="hspace"> </span><span
                    class="RktSym">param-iface2</span><span class="hspace"> </span><span
                    class="RktSym">result-iface2</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">new-name</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">fresh-module-name</span><span
                    class="hspace"> </span><span class="RktSym">param-name1</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">result-iface1</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                      </span><span class="RktPn">(</span><span
                    class="RktSym">rename-in-iface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                        </span><span class="RktSym">result-iface1</span><span
                    class="hspace"> </span><span class="RktSym">param-name1</span><span class="hspace"> </span><span
                    class="RktSym">new-name</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                     </span><span class="RktPn">(</span><span
                    class="RktSym">result-iface2</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                       </span><span class="RktPn">(</span><span
                    class="RktSym">rename-in-iface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                         </span><span class="RktSym">result-iface2</span><span
                    class="hspace"> </span><span class="RktSym">param-name2</span><span class="hspace"> </span><span
                    class="RktSym">new-name</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">and</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                    class="RktSym"><:-iface< /span><span class="hspace"> </span><span
                        class="RktSym">param-iface2</span><span class="hspace"> </span><span
                        class="RktSym">param-iface1</span><span class="hspace"> </span><span
                        class="RktSym">tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                    class="RktSym"><:-iface< /span><span class="hspace"> </span><span
                        class="RktSym">result-iface1</span><span class="hspace"> </span><span
                        class="RktSym">result-iface2</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                    </span><span class="RktPn">(</span><span
                    class="RktSym">extend-tenv-with-module</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                      </span><span class="RktSym">new-name</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                      </span><span class="RktPn">(</span><span
                    class="RktSym">expand-iface</span><span class="hspace"> </span><span
                    class="RktSym">new-name</span><span class="hspace"> </span><span
                    class="RktSym">param-iface1</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                      </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>PROC-MODULES 的检查器，第 2 部分
            <a name="(idx._(gentag._1292))"></a>
            <a name="(idx._(gentag._1293))"></a>
            <a name="(idx._(gentag._1294))"></a>
            <a name="(idx._(gentag._1295))"></a>
            <a name="(idx._(gentag._1296))"></a>
            <a name="(idx._(gentag._1297))"></a>
            <a name="(idx._(gentag._1298))"></a><a name="(elem._fig-8..16)"></a>
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..24)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>目前，调用模块只能通过标识符。要是我们想检查调用 <span class="stt">(m1 (m2 m3))</span>，类型规则有什
          么问题？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..25)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._1299))"></a>
          扩展 PROC-MODULES，像<span class="EoplExerciseRef"></span> 那样，允许模块取多个参数。
          <a name="(idx._(gentag._1300))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..26)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>扩展语言的模块主体，将模块调用的生成式改为</p>
        <p><span class="Iidentity">\begin{align*}\mathit{ModuleBody} &::= <span class="stt">(</span><span
              class="Iidentity">\mathit{ModuleBody}</span><span class="stt"> </span><span
              class="Iidentity">\mathit{ModuleBody}</span><span class="stt">)</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">app-module-body (rator rand)</span>}\end{align*}</span></p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex8..27)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>在
          PROC-MODULES 中，我们总要一遍又一遍写这种接口</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">[opaque t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">zero : t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">succ : (t -> t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">pred : (t -> t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">is-zero : (t -> bool)]</span>
                </p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>给程序添加语法，支持命名接口，这样我们就能写</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">interface int-interface = [opaque t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                           </span><span
                    class="stt">zero : t</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                           </span><span
                    class="stt">succ : (t -> t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                           </span><span
                    class="stt">pred : (t -> t)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                           </span><span
                    class="stt">is-zero : (t -> bool)]</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">module make-to-int</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">interface</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">((ints :
                    int-interface)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">=> [to-int : from ints
                    take t -> int])</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">body</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">...</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <div class="navsetbottom"><span class="navleft">
          <div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);"
              title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
        </span><span class="navright">  <a href="types.html" title="backward to " 7 类型"" data-pltdoc="x">← prev</a>  <a
            href="index.html" title="up to " 编程语言要素"" data-pltdoc="x">up</a>  <a href="oac.html" title="forward to " 9
            对象和类"" data-pltdoc="x">next →</a></span> </div>
    </div>
  </div>
  <div id="contextindicator"> </div>
</body>

</html>