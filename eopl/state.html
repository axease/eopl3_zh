<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=0.8" />
  <title>4 状态</title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default" />
  <link rel="stylesheet" type="text/css" href="racket.css" title="default" />
  <script type="text/javascript" src="scribble-common.js"></script>
  <script src="katex/katex.min.js"></script>
  <script src="onload.js"></script>

</head>

<body id="scribble-racket-lang-org">
  <div class="tocset">
    <div class="tocview">
      <div class="tocviewlist tocviewlisttopspace">
        <div class="tocviewtitle">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle"
                  onclick="TocviewToggle(this," tocview_0");">▼</a></td>
              <td></td>
              <td><a href="index.html" class="tocviewlink" data-pltdoc="x">编程语言要素</a></td>
            </tr>
          </table>
        </div>
        <div class="tocviewsublisttop" style="display: block;" id="tocview_0">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td align="right"></td>
              <td><a href="fw-trans.html" class="tocviewlink" data-pltdoc="x">译者的话</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="glo.html" class="tocviewlink" data-pltdoc="x">译名表</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="fw.html" class="tocviewlink" data-pltdoc="x">序</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="pf.html" class="tocviewlink" data-pltdoc="x">前言</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="awk.html" class="tocviewlink" data-pltdoc="x">致谢</a></td>
            </tr>
            <tr>
              <td align="right">1 </td>
              <td><a href="isd.html" class="tocviewlink" data-pltdoc="x">归纳式数据集</a></td>
            </tr>
            <tr>
              <td align="right">2 </td>
              <td><a href="da.html" class="tocviewlink" data-pltdoc="x">数据抽象</a></td>
            </tr>
            <tr>
              <td align="right">3 </td>
              <td><a href="expr.html" class="tocviewlink" data-pltdoc="x">表达式</a></td>
            </tr>
            <tr>
              <td align="right">4 </td>
              <td><a href="" class="tocviewselflink" data-pltdoc="x">状态</a></td>
            </tr>
            <tr>
              <td align="right">5 </td>
              <td><a href="cpi.html" class="tocviewlink" data-pltdoc="x">传递续文的解释器</a></td>
            </tr>
            <tr>
              <td align="right">6 </td>
              <td><a href="cps.html" class="tocviewlink" data-pltdoc="x">续文传递风格</a></td>
            </tr>
            <tr>
              <td align="right">7 </td>
              <td><a href="types.html" class="tocviewlink" data-pltdoc="x">类型</a></td>
            </tr>
            <tr>
              <td align="right">8 </td>
              <td><a href="modules.html" class="tocviewlink" data-pltdoc="x">模块</a></td>
            </tr>
            <tr>
              <td align="right">9 </td>
              <td><a href="oac.html" class="tocviewlink" data-pltdoc="x">对象和类</a></td>
            </tr>
            <tr>
              <td align="right">10 </td>
              <td><a href="further-reading.html" class="tocviewlink" data-pltdoc="x">扩展阅读</a></td>
            </tr>
            <tr>
              <td align="right">11 </td>
              <td><a href="sllgen-parsing-system.html" class="tocviewlink" data-pltdoc="x">SLLGEN解析系统</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="bib.html" class="tocviewlink" data-pltdoc="x">参考书目</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="indices.html" class="tocviewlink" data-pltdoc="x">索引</a></td>
            </tr>
          </table>
        </div>
      </div>
      <div class="tocviewlist">
        <table cellspacing="0" cellpadding="0">
          <tr>
            <td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle"
                onclick="TocviewToggle(this," tocview_1");">►</a></td>
            <td>4 </td>
            <td><a href="" class="tocviewselflink" data-pltdoc="x">状态</a></td>
          </tr>
        </table>
        <div class="tocviewsublistbottom" style="display: none;" id="tocview_1">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td align="right">4.1 </td>
              <td><a href="#%28part._s4..1%29" class="tocviewlink" data-pltdoc="x">计算的效果</a></td>
            </tr>
            <tr>
              <td align="right">4.2 </td>
              <td><a href="#%28part._s4..2%29" class="tocviewlink" data-pltdoc="x">EXPLICIT-<wbr></wbr>REFS：显式引用语言</a>
              </td>
            </tr>
            <tr>
              <td align="right">4.3 </td>
              <td><a href="#%28part._s4..3%29" class="tocviewlink" data-pltdoc="x">IMPLICIT-<wbr></wbr>REFS：隐式引用语言</a>
              </td>
            </tr>
            <tr>
              <td align="right">4.4 </td>
              <td><a href="#%28part._s4..4%29" class="tocviewlink" data-pltdoc="x">MUTABLE-<wbr></wbr>PAIRS：可变序对语言</a>
              </td>
            </tr>
            <tr>
              <td align="right">4.5 </td>
              <td><a href="#%28part._s4..5%29" class="tocviewlink" data-pltdoc="x">传参变体</a></td>
            </tr>
          </table>
        </div>
      </div>
    </div>
    <div class="tocsub">
      <div class="tocsubtitle">On this page:</div>
      <table class="tocsublist" cellspacing="0">
        <tr>
          <td><span class="tocsublinknumber">4.1<tt> </tt></span><a href="#%28part._s4..1%29" class="tocsubseclink"
              data-pltdoc="x">计算的效果</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.2<tt> </tt></span><a href="#%28part._s4..2%29" class="tocsubseclink"
              data-pltdoc="x">EXPLICIT-<wbr></wbr>REFS：显式引用语言</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.2.1<tt> </tt></span><a href="#%28part._s4..2..1%29" class="tocsubseclink"
              data-pltdoc="x">存储器传递规范</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.2.2<tt> </tt></span><a href="#%28part._s4..2..2%29" class="tocsubseclink"
              data-pltdoc="x">定义显式引用操作</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.2.3<tt> </tt></span><a href="#%28part._s4..2..3%29" class="tocsubseclink"
              data-pltdoc="x">实现</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.3<tt> </tt></span><a href="#%28part._s4..3%29" class="tocsubseclink"
              data-pltdoc="x">IMPLICIT-<wbr></wbr>REFS：隐式引用语言</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.3.1<tt> </tt></span><a href="#%28part._s4..3..1%29" class="tocsubseclink"
              data-pltdoc="x">规范</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.3.2<tt> </tt></span><a href="#%28part._s4..3..2%29" class="tocsubseclink"
              data-pltdoc="x">实现</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.4<tt> </tt></span><a href="#%28part._s4..4%29" class="tocsubseclink"
              data-pltdoc="x">MUTABLE-<wbr></wbr>PAIRS：可变序对语言</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.4.1<tt> </tt></span><a href="#%28part._s4..4..1%29" class="tocsubseclink"
              data-pltdoc="x">实现</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.4.2<tt> </tt></span><a href="#%28part._s4..4..2%29" class="tocsubseclink"
              data-pltdoc="x">可变序对的另一种表示</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.5<tt> </tt></span><a href="#%28part._s4..5%29" class="tocsubseclink"
              data-pltdoc="x">传参变体</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.5.1<tt> </tt></span><a href="#%28part._s4..5..1%29" class="tocsubseclink"
              data-pltdoc="x">按指调用</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">4.5.2<tt> </tt></span><a href="#%28part._s4..5..2%29" class="tocsubseclink"
              data-pltdoc="x">懒求值：按名调用和按需调用</a></td>
        </tr>
      </table>
    </div>
  </div>
  <div class="maincolumn">
    <div class="main">
      <div class="navsettop"><span class="navleft">
          <div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);"
              title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
        </span><span class="navright">  <a href="expr.html" title="backward to " 3 表达式"" data-pltdoc="x">← prev</a>  <a
            href="index.html" title="up to " 编程语言要素"" data-pltdoc="x">up</a>  <a href="cpi.html" title="forward to " 5
            传递续文的解释器"" data-pltdoc="x">next →</a></span> </div>
      <h3>4<tt> </tt><a name="(part._state)"></a>状态</h3>
      <h4>4.1<tt> </tt><a name="(part._s4..1)"></a>计算的效果</h4>
      <p><a name="(idx._(gentag._581))"></a>
        <a name="(idx._(gentag._582))"></a>
        到目前为止，我们只考虑了计算产生的<span class="emph">值</span> (<span class="emph">value</span>)，但是计算也
        有<span class="emph">效果</span> (<span class="emph">effect</span>)：它可以读取，打印，修改内存或者文件系统的状态。在现实世
        界中，我们<span class="emph">总是</span>对效果很感兴趣：如果一次计算不显示答案，那对我们完全没用！
      </p>
      <p>产生值和产生效果有何区别？效果是<span class="emph">全局性</span> (<span class="emph">global</span>) 的，整个计算都能看到。效
        果<span class="emph">感染</span>整个计算（故意用双关语）。</p>
      <p><a name="(idx._(gentag._583))"></a>
        <a name="(idx._(gentag._584))"></a>
        我们主要关心一种效果：给内存中的位置赋值。赋值与绑定有何区别？我们已经知道，绑定
        是局部的，但<a name="(idx._(gentag._585))"></a>变量赋值有可能是全局的。那是在本不相关的几
        部分计算之间<span class="emph">共享</span> (<span class="emph">share</span>) <a name="(idx._(gentag._586))"></a>
        值。如果两个过程知道内存中的同一位置，它们就能共享信息。如果把信息留在已知位置，
        同一个过程就能在当前调用和后续调用之间共享信息。
      </p>
      <p><a name="(idx._(gentag._587))"></a>
        <a name="(idx._(gentag._588))"></a>
        我们把内存建模为从<span class="emph">位置</span> (<span class="emph">location</span>) 到值集合的的有限映射，称值集合
        为<span class="emph">可存储值</span> (<span class="emph">storable values</span>)。出于历史原因，我们称之为<span class="emph">存
          储器</span> (<span class="emph">store</span>)。通常，一种语言中的可存储值与表达值相同，但不总是这样。这个选择是语言设计
        的一部分。<a name="(idx._(gentag._589))"></a>
      </p>
      <p>代表内存位置的数据结构叫做<span class="emph">引用</span> (<span class="emph">reference</span>)。位置是内存中可用来存值的地方，
        引用是指向那个地方的数据结构。位置和引用的区别可以这样类比：位置就像文件，引用就
        像一个URL。URL指向一个文件，文件包含一些数据。类似地，引用指代一个位置，位置包含
        一些数据。</p>
      <p><a name="(idx._(gentag._590))"></a>
        引用有时候又叫<span class="emph">左值</span> (<span class="emph">L-values</span>)。这名字反映了这种数据结构与赋值语句左边变
        量的联系。类似地，表达值，比如赋值语句右边表达式的值，叫做<span class="emph">右值</span> (<span class="emph">R-values</span>)。
        <a name="(idx._(gentag._591))"></a>
      </p>
      <p>我们考虑两种带有存储器的语言设计。这些设计叫做<span class="emph">显式引
          用</span> (<span class="emph">explicit reference</span>) 和<span class="emph">隐式引用</span> (<span
          class="emph">implicit reference</span>)。
        <a name="(idx._(gentag._592))"></a>
      </p>
      <h4>4.2<tt> </tt><a name="(part._s4..2)"></a>EXPLICIT-REFS：显式引用语言</h4>
      <p><a name="(idx._(gentag._593))"></a>
        <a name="(idx._(gentag._594))"></a>
        在这种设计中，我们添加引用，作为另一种表达值。那么，我们有：
      </p>
      <blockquote class="SubFlow">
        <p><span class="Iidentity">\begin{align*}\mathit{ExpVal} &= \mathit{Int} + \mathit{Bool} + \mathit{Proc} +
            \mathit{Ref(ExpVal)} \\
            \mathit{DenVal} &= \mathit{ExpVal}\end{align*}</span></p>
        <p>这里，<span class="texMathInline">\mathit{Ref(ExpVal)}</span>表示包含表达值的位置引用集合。</p>
      </blockquote>
      <p>我们沿用语言中的绑定数据结构，但是添加三个新操作，用来创建和使用引用。</p>
      <ul>
        <li>
          <p><span class="stt">newref</span>，分配新的位置，返回其引用。
            <a name="(idx._(gentag._595))"></a>
          </p>
        </li>
        <li>
          <p><span class="stt">deref</span>，<span class="emph">解引用</span> (<span class="emph">deference</span>)
            ：返回引用指向位置处的内容。
            <a name="(idx._(gentag._596))"></a>
          </p>
        </li>
        <li>
          <p><span class="stt">setref</span>，改变引用指向位置处的内容。
            <a name="(idx._(gentag._597))"></a>
          </p>
        </li>
      </ul>
      <p>我们把得到的语言称作 EXPLICIT-REFS。让我们用这些结构写几个程序。</p>
      <p>下面是两个过程 <span class="stt">even</span> 和 <span class="stt">odd</span>。它们取一参数，但是忽略它，并根据位置
        <span class="stt">x</span> 处的内容是偶数还是奇数返回 1 或 0。它们不是通过直接传递数据来通信，而是改
        变共享变量的内容。<a name="(idx._(gentag._598))"></a><a name="(idx._(gentag._599))"></a>
      </p>
      <p>这个程序判断 13 是否为奇数，并返回 1。过程 <span class="stt">even</span> 和 <span class="stt">odd</span> 不引用它们的实
        参，而是查看绑定到 <span class="stt">x</span> 的位置中的内容。</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let x = newref (0)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in letrec even(dummy)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">           </span><span class="stt">= if zero?
                    (deref(x))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">             </span><span class="stt">then 1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">             </span><span class="stt">else begin</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">setref(x,
                    -(deref(x), 1));</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">(odd
                    888)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                  </span><span class="stt">end</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">odd(dummy)</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">           </span><span class="stt">= if zero?
                    (deref(x))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">             </span><span class="stt">then 0</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">             </span><span class="stt">else begin</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">setref(x,
                    -(deref(x), 1));</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">(even
                    888)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                  </span><span class="stt">end</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in begin setref(x,13); (odd
                    888) end</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>这个程序使用多声明的 <span class="stt">letrec</span>（<span class="EoplExerciseRef"></span>）和 <span
            class="stt">begin</span> 表达式
          （<span class="EoplExerciseRef"></span>）。<span class="stt">begin</span> 表达式按顺序求每个子表达式的值，并返
          回最后一个表达式的值。
          <a name="(idx._(gentag._600))"></a>
        </p>
      </blockquote>
      <p>为了同我们的单参数语言保持一致，我们给 <span class="stt">even</span> 和 <span class="stt">odd</span> 传一个无用参数；如
        果我们的过程支持任意数量的参数（<span class="EoplExerciseRef"></span>），这些过程的参数就可以去
        掉。</p>
      <p>当两个过程需要分享很多量时，这种通信方式很方便；只需给某些随调用而改变的量赋值。
        同样地，一个过程可能通过一长串调用间接调用另一过程。二者可以通过一个共享变量直接
        交换数据，居间的过程不需要知道它。因此，以共享变量通信可作为一种隐藏信息的方式。</p>
      <p><a name="(idx._(gentag._601))"></a>
        <a name="(idx._(gentag._602))"></a>
        赋值的另一用途是通过私有变量创建隐藏状态。例如：
      </p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><a name="(elem._g-counter)"></a><span class="stt">let g = let counter = newref(0)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">        </span><span class="stt">in proc (dummy)</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">            </span><span class="stt">begin</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">             </span><span class="stt">setref(counter,
                  -(deref(counter), -1));</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">             </span><span
                  class="stt">deref(counter)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">            </span><span class="stt">end</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">in let a = (g 11)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in let b = (g 11)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">      </span><span class="stt">in -(a,b)</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>这里，过程 <span class="stt">g</span> 保留了一个私有变量，用来存储 <span class="stt">g</span> 被调用的次数。因此，第一次
        调用 <span class="stt">g</span> 返回 1，第二次返回 2，整个程序的值为 -1。</p>
      <p><a name="(idx._(gentag._603))"></a>
        下图是 <span class="stt">g</span> 绑定时所在的环境。可以认为，这是在 <span class="stt">g</span> 的不同调用之间共享信息。
        Scheme 过程 <span class="stt">gensym</span> 用这种技术创建唯一符号。</p>
      <blockquote class="EoplFigure*">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCentered">
            <p><img src="g-bound.svg" alt="g绑定时的环境" width="418.95pt" height="415.53pt" /></p>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._604))"></a>
          <a name="(idx._(gentag._605))"></a>
        </div>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..1)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>这个程序如果写成下面这样会怎样？</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let g = proc (dummy)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">let counter =
                    newref(0)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">in begin</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">             </span><span class="stt">setref(counter,
                    -(deref(counter), -1));</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">             </span><span
                    class="stt">deref(counter)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">end</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in let a = (g 11)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in let b = (g 11)</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">      </span><span class="stt">in -(a,b)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>在EXPLICIT-REFS中，我们可以存储任何表达值。引用也是表达值。这意味着我们可以在一
        个位置存储引用。考虑下面的程序：<a name="(idx._(gentag._606))"></a></p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt">let x = newref(newref(0))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">in begin</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">    </span><span class="stt">setref(deref(x), 11);</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">    </span><span class="stt">deref(deref(x))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">end</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>这段程序分配了一个新位置，内容为 0。然后，它将 <span class="stt">x</span> 绑定到一个位置，其内容为指
        向第一个位置的引用。因此，<span class="stt">deref(x)</span> 的值是第一个位置的引用。那么程序求
        <span class="stt">setref</span> 的值时，会修改第一个位置，整个程序返回 11。
      </p>
      <h5>4.2.1<tt> </tt><a name="(part._s4..2..1)"></a>存储器传递规范</h5>
      <p><a name="(idx._(gentag._607))"></a>
        在我们的语言中，任何表达式都可以有效果。要定义这些效果，我们需要描述每次求值使用
        什么样的存储器，以及求值如何修改存储器。</p>
      <p>在规范中，我们用 <span class="texMathInline">\sigma</span> 表示任一存储器，用 <span
          class="texMathInline">\text{[}l=v\text{]}\sigma</span> 表
        示另一存储器，除了将位置 <span class="texMathInline">l</span> 映射到 <span class="texMathInline">v</span>外，它与 <span
          class="texMathInline">\sigma</span> 相同。有时，涉及
        <span class="texMathInline">\sigma</span> 的某个具体值时，我们称之为存储器的<span class="emph">状态</span> (<span
          class="emph">state</span>)。
      </p>
      <p>
      <div class="SIntrapara">我们使用<span class="emph">存储器传递规范</span> (<span class="emph">store-passing
          specifications</span>)。在存储器传递规范
        中，存储器作为显式参数传递给 <span class="stt">value-of</span>，并作为 <span class="stt">value-of</span> 的结果返回。那
        么我们可以写：<a name="(idx._(gentag._608))"></a>
        <span class="texMathDisplay"><span class="stt">(value-of </span><span class="texMathInline">exp_1</span><span
            class="stt"> </span><span class="texMathInline">\rho</span><span class="stt"> </span><span
            class="texMathInline">\sigma_0</span><span class="stt">)</span> = <span class="stt">(</span><span
            class="texMathInline">val_1</span><span class="stt">,</span><span class="texMathInline">\sigma_1</span><span
            class="stt">)</span></span>
      </div>
      <div class="SIntrapara">
        <blockquote class="SubFlow">
          <p>它断言在环境为 <span class="texMathInline">\rho</span>，存储器状态为 <span class="texMathInline">\sigma_0</span> 时，表达式
            <span class="texMathInline">exp_1</span> 的返回值
            为 <span class="texMathInline">val_1</span>，并且可能把存储器修改为另一状态 <span class="texMathInline">\sigma_1</span>。</p>
        </blockquote>
      </div>
      </p>
      <p>
      <div class="SIntrapara">这样我们就能写出 <span class="stt">const-exp</span> 之类的无效果操作：
        <span class="texMathDisplay"><span class="stt">(value-of (const-exp </span><span
            class="texMathInline">n</span><span class="stt">) </span><span class="texMathInline">\rho</span><span
            class="stt"> </span><span class="texMathInline">\sigma</span><span class="stt">)</span> = <span
            class="stt">(</span><span class="texMathInline">n</span><span class="stt">,</span><span
            class="texMathInline">\sigma</span><span class="stt">)</span></span>
      </div>
      <div class="SIntrapara">
        <blockquote class="SubFlow">
          <p>以此表明求表达式的值不会修改存储器。</p>
        </blockquote>
      </div>
      </p>
      <p>
      <div class="SIntrapara"><span class="stt">diff-exp</span> 的规范展示了如何定义有顺序的行为。
        <span class="texMathDisplay">\infer{<span class="stt">(value-of (diff-exp </span><span
            class="texMathInline">exp_1</span><span class="stt"> </span><span class="texMathInline">exp_2</span><span
            class="stt">) </span><span class="texMathInline">\rho</span><span class="stt"> </span><span
            class="texMathInline">\sigma_0</span><span class="stt">)</span> =
          <span class="stt">(</span><span class="texMathInline">\lceil\lfloor val_1 \rfloor - \lfloor val_2
            \rfloor\rceil</span><span class="stt">,</span><span class="texMathInline">\sigma_2</span><span
            class="stt">)</span>}
          {\begin{alignedat}{-1}
          <span class="stt">(value-of (diff-exp </span><span class="texMathInline">exp_1</span><span class="stt">)
          </span><span class="texMathInline">\rho</span><span class="stt"> </span><span
            class="texMathInline">\sigma_0</span><span class="stt">)</span> &= <span class="stt">(</span><span
            class="texMathInline">val_1</span><span class="stt">,</span><span class="texMathInline">\sigma_1</span><span
            class="stt">)</span> \\
          <span class="stt">(value-of (diff-exp </span><span class="texMathInline">exp_2</span><span class="stt">)
          </span><span class="texMathInline">\rho</span><span class="stt"> </span><span
            class="texMathInline">\sigma_1</span><span class="stt">)</span> &= <span class="stt">(</span><span
            class="texMathInline">val_2</span><span class="stt">,</span><span class="texMathInline">\sigma_2</span><span
            class="stt">)</span>
          \end{alignedat}}</span>
      </div>
      <div class="SIntrapara">
        <blockquote class="SubFlow">
          <p>这里，我们从状态为 <span class="texMathInline">\sigma_0</span> 的存储器开始，首先求 <span class="texMathInline">exp_1</span>
            的值。<span class="texMathInline">exp_1</span>
            返回值为 <span class="texMathInline">val_1</span>，但它可能有效果，把存储器状态修改为 <span
              class="texMathInline">\sigma_1</span>。然后我们从
            <span class="texMathInline">exp_1</span> 修改过的存储器——也就是 <span class="texMathInline">\sigma_1</span>——开始，求
            <span class="texMathInline">exp_2</span> 的值。
            <span class="texMathInline">exp_2</span> 同样返回一个值 <span class="texMathInline">val_2</span>，并把存储器状态修改为 <span
              class="texMathInline">\sigma_2</span>。之后，整
            个表达式返回 <span class="texMathInline">val_1 - val2</span>，对存储器不再有任何效果，所以存储器状态留在
            <span class="texMathInline">\sigma_2</span>。
          </p>
        </blockquote>
      </div>
      </p>
      <p>再来试试条件表达式。
        <span class="texMathDisplay">\infer{\begin{alignedat}{-1}
          &<span class="hspace"> </span><span class="stt">(value-of (if-exp </span><span
            class="texMathInline">exp_1</span><span class="stt"> </span><span class="texMathInline">exp_2</span><span
            class="stt"> </span><span class="texMathInline">exp_3</span><span class="stt">) </span><span
            class="texMathInline">\rho</span><span class="stt"> </span><span class="texMathInline">\sigma_0</span><span
            class="stt">) </span> \\
          &\hphantom{xx}= \begin{cases}
          <span class="stt">(value-of </span><span class="texMathInline">exp_2</span><span class="stt"> </span><span
            class="texMathInline">\rho</span><span class="stt"> </span><span class="texMathInline">\sigma_1</span><span
            class="stt">)</span> & 若 <span class="stt">(expval->bool </span><span
            class="texMathInline">val_1</span><span class="stt">)</span> = <span class="stt">#t</span> \\
          <span class="stt">(value-of </span><span class="texMathInline">exp_3</span><span class="stt"> </span><span
            class="texMathInline">\rho</span><span class="stt"> </span><span class="texMathInline">\sigma_1</span><span
            class="stt">)</span> & 若 <span class="stt">(expval->bool </span><span
            class="texMathInline">val_1</span><span class="stt">)</span> = <span class="stt">#f</span> \hphantom{x}
          \end{cases}
          \end{alignedat}}
          {<span class="stt">(value-of </span><span class="texMathInline">exp_1</span><span class="stt"> </span><span
            class="texMathInline">\rho</span><span class="stt"> </span><span class="texMathInline">\sigma_0</span><span
            class="stt">)</span> = <span class="stt">(</span><span class="texMathInline">val_1</span><span
            class="stt">,</span><span class="texMathInline">\sigma_1</span><span class="stt">)</span>}</span>
      </p>
      <p>一个 <span class="stt">if-exp</span> 从状态 <span class="texMathInline">\sigma_0</span> 开始，求条件表达式 <span
          class="texMathInline">exp_1</span> 的值，返回值
        <span class="texMathInline">val_1</span>，将存储器状态修改为 <span class="texMathInline">\sigma_1</span>。整个表达式的结果可能是 <span
          class="texMathInline">exp_2</span> 或
        <span class="texMathInline">exp_3</span> 的结果，二者都在当前环境 <span class="texMathInline">\rho</span> 和 <span
          class="texMathInline">exp_1</span> 留下的存储器状态
        <span class="texMathInline">\sigma_1</span> 中求值。
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..2)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写出 <span class="stt">zero?-exp</span> 的规范。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..3)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写出 <span class="stt">call-exp</span> 的规范。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..4)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._609))"></a>
          写出 <span class="stt">begin</span> 表达式的规范。
          <span class="texMathDisplay">\mathit{Expression} ::= <span class="stt">begin </span><span
              class="texMathInline">\mathit{Expression}</span><span class="stt"> </span><span
              class="texMathInline">\{}<span class="stt">; </span><span
                class="texMathInline">\mathit{Expression}</span><span class="texMathInline">\</span>^{*}</span><span
              class="stt"> end</span></span>
        </p>
        <p><span class="stt">begin</span> 表达式包含一个或多个分号分隔的子表达式，按顺序求这些子表达的值，并返
          回最后一个的结果。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..5)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._610))"></a>
          写出 <span class="stt">list</span>（<span class="EoplExerciseRef"></span>）的规范。</p>
      </blockquote>
      <h5>4.2.2<tt> </tt><a name="(part._s4..2..2)"></a>定义显式引用操作</h5>
      <p><a name="(idx._(gentag._611))"></a>
        在 EXPLICIT-REFS 中，我们必须定义三个操作：<span class="stt">newref</span>、<span class="stt">deref</span> 和
        <span class="stt">setref</span>。它们的语法为：
      </p>
      <p><span class="Iidentity">\begin{align*}\mathit{Expression} &::= <span class="stt">newref (</span><span
            class="Iidentity">\mathit{Expression}</span><span class="stt">)</span> \\[-3pt]
          &\mathrel{\phantom{::=}} \fbox{<span class="stt">newref-exp (exp1)</span>} \\[5pt]
          \mathit{Expression} &::= <span class="stt">deref (</span><span
            class="Iidentity">\mathit{Expression}</span><span class="stt">)</span> \\[-3pt]
          &\mathrel{\phantom{::=}} \fbox{<span class="stt">deref-exp (exp1)</span>} \\[5pt]
          \mathit{Expression} &::= <span class="stt">setref (</span><span
            class="Iidentity">\mathit{Expression}</span><span class="stt"> , </span><span
            class="Iidentity">\mathit{Expression}</span><span class="stt">)</span> \\[-3pt]
          &\mathrel{\phantom{::=}} \fbox{<span class="stt">setref-exp (exp1 exp2)</span>}\end{align*}</span></p>
      <p>这些操作的行为定义如下。
        <span class="texMathDisplay">\infer{<span class="stt">(value-of (newref-exp </span><span
            class="texMathInline">exp</span><span class="stt">) </span><span class="texMathInline">\rho</span><span
            class="stt"> </span><span class="texMathInline">\sigma_0</span><span class="stt">) =</span><span
            class="stt">
          </span><span class="stt">((ref-val </span><span class="texMathInline">l</span><span
            class="stt">),[</span><span class="texMathInline">l</span><span class="stt">=</span><span
            class="texMathInline">val</span><span class="stt">]</span><span class="texMathInline">\sigma_1</span><span
            class="stt">)</span>}
          {<span class="stt">(value-of </span><span class="texMathInline">exp</span><span class="stt"> </span><span
            class="texMathInline">\rho</span><span class="stt"> </span><span class="texMathInline">\sigma_0</span><span
            class="stt">)</span> = <span class="stt">(</span><span class="texMathInline">val</span><span
            class="stt">,</span><span class="texMathInline">\sigma_1</span><span class="stt">)</span> \quad l \notin
          \text{dom}(\sigma_1)}</span>
      </p>
      <p>这条规则是说：<span class="stt">newref-exp</span> 求出操作数的值，得到一个存储器，然后分配一个新位置
        <span class="texMathInline">l</span>，将参数值 <span class="texMathInline">val</span> 放到这一位置，以此来扩展那个存储器。然后它返回新位置
        <span class="texMathInline">l</span> 的引用。这意味着 <span class="texMathInline">l</span> 不在 <span
          class="texMathInline">\sigma_1</span> 的定义域内。
        <a name="(idx._(gentag._612))"></a>
        <span class="texMathDisplay">\infer{<span class="stt">(value-of (deref-exp </span><span
            class="texMathInline">exp</span><span class="stt">) </span><span class="texMathInline">\rho</span><span
            class="stt"> </span><span class="texMathInline">\sigma_0</span><span class="stt">) =</span><span
            class="stt">
          </span><span class="stt">(</span><span class="texMathInline">\sigma_1(l)</span><span class="stt">,</span><span
            class="texMathInline">\sigma_1</span><span class="stt">)</span>}
          {<span class="stt">(value-of </span><span class="texMathInline">exp</span><span class="stt"> </span><span
            class="texMathInline">\rho</span><span class="stt"> </span><span class="texMathInline">\sigma_0</span><span
            class="stt">)</span> = <span class="stt">(</span><span class="texMathInline">val</span><span
            class="stt">,</span><span class="texMathInline">\sigma_1</span><span class="stt">)</span>}</span>
      </p>
      <p>这条规则是说：<span class="stt">deref-exp</span> 求出操作数的值，然后把存储器状态改为 <span class="texMathInline">\sigma_1</span>。
        参数的值应是位置 <span class="texMathInline">l</span> 的引用。然后 <span class="stt">deref-exp</span> 返回 <span
          class="texMathInline">\sigma_1</span> 中 <span class="texMathInline">l</span> 处
        的内容，不再更改存储器。
        <span class="texMathDisplay">\infer{<span class="stt">(value-of (setref-exp </span><span
            class="texMathInline">exp_1</span><span class="stt"> </span><span class="texMathInline">exp_2</span><span
            class="stt">) </span><span class="texMathInline">\rho</span><span class="stt"> </span><span
            class="texMathInline">\sigma_0</span><span class="stt">) =</span><span class="stt">
          </span><span class="stt">(</span><span class="texMathInline">\lceil 23 \rceil</span><span
            class="stt">,[</span><span class="texMathInline">l</span><span class="stt">=</span><span
            class="texMathInline">val</span><span class="stt">]</span><span class="texMathInline">\sigma_2</span><span
            class="stt">)</span>}
          {\begin{gathered}
          <span class="stt">(value-of </span><span class="texMathInline">exp_1</span><span class="stt"> </span><span
            class="texMathInline">\rho</span><span class="stt"> </span><span class="texMathInline">\sigma_0</span><span
            class="stt">)</span> = <span class="stt">(</span><span class="texMathInline">l</span><span
            class="stt">,</span><span class="texMathInline">\sigma_1</span><span class="stt">)</span> \\
          <span class="stt">(value-of </span><span class="texMathInline">exp_2</span><span class="stt"> </span><span
            class="texMathInline">\rho</span><span class="stt"> </span><span class="texMathInline">\sigma_1</span><span
            class="stt">)</span> = <span class="stt">(</span><span class="texMathInline">val</span><span
            class="stt">,</span><span class="texMathInline">\sigma_2</span><span class="stt">)</span>
          \end{gathered}}</span>
      </p>
      <p><a name="(idx._(gentag._613))"></a>
        这条规则是说：<span class="stt">setref-exp</span> 从左到右求操作数的值。第一个操作数的值必须是某个位
        置 <span class="texMathInline">l</span> 的引用；然后 <span class="stt">setref-exp</span> 把第二个参数的值 <span
          class="texMathInline">val</span> 放到位置 <span class="texMathInline">l</span> 处，
        以此更新存储器。<span class="stt">setref-exp</span> 应该返回什么呢？它可以返回任何值。为了强调这一选
        择的随意性，我们让它返回 23。因为我们对 <span class="stt">setref-exp</span> 的返回值不感兴趣，我们说
        这个表达式的执行<span class="emph">求效果</span> (<span class="emph">for effect</span>) 而不求值。
        <a name="(idx._(gentag._614))"></a>
        <a name="(idx._(gentag._615))"></a>
        <a name="(idx._(gentag._616))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..6)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>修改上面的规则，让 <span class="stt">setref-exp</span> 返回右边表达式的值。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..7)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>修改上面的规则，让 <span class="stt">setref-exp</span> 返回位置的原内容。
          <a name="(idx._(gentag._617))"></a>
        </p>
      </blockquote>
      <h5>4.2.3<tt> </tt><a name="(part._s4..2..3)"></a>实现</h5>
      <p><a name="(idx._(gentag._618))"></a>
        迄今为止，我们使用的规范语言可以轻松描述有效果计算的期望行为，但是它没有体现存储
        器的一个要点：引用最终指向现实世界的内存中某一真实的位置。因为我们只有一个现实世
        界，我们的程序只能记录存储器的一个状态 <span class="texMathInline">\sigma</span>。</p>
      <p>在我们的实现中，我们利用这一事实，用 Scheme 中的存储器建模存储器。这样，我们就能
        用 Scheme 中的效果建模效果。</p>
      <p>我们用一个 Scheme 值表示存储器状态，但是我们不像规范建议的那样直接传递和返回它，
        相反，我们在一个全局变量中记录状态，实现代码中的所有过程都能访问它。这很像示例程
        序 <span class="stt">even/odd</span> 使用共享位置，而不是直接传递参数。使用单一全局变量时，我们也几
        乎不需要理解 Scheme 中的效果。</p>
      <p>我们还是要选择如何用 Scheme 值建模存储器。我们选择的可能是最简单的模型：以表达值
        列表作为存储器，以代表列表位置的数字表示引用。分配新引用就是给列表末尾添加新值；
        更新存储器则建模为按需复制列表的一大部分。代码如<span class="EoplFigureRef"></span> 和
        <span class="stt">fig-4.2</span> 所示。
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">empty-store</span></span> : <span
                    class="texMathInline">() \to \mathit{Sto}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">empty-store</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">)</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span class="emph"><span style="font-weight: bold">用法</span> : Scheme 变量，包含存储器当前的状态。初始值无意义。</span>
                </td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">the-store</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">uninitialized</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">get-store</span></span> : <span
                    class="texMathInline">() \to \mathit{Sto}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">get-store</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">)</span><span
                    class="hspace"> </span><span class="RktSym">the-store</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">initialize-store!</span></span> : <span
                    class="texMathInline">() \to \mathit{Unspecified}</span></td>
              </tr>
              <tr>
                <td><span class="emph"><span style="font-weight: bold">用法</span> : <span
                      class="stt">(initialize-store!)</span> 将存储器设为空。</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">initialize-store!</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">set!</span><span
                    class="hspace"> </span><span class="RktSym">the-store</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">empty-store</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">reference?</span></span> : <span
                    class="texMathInline">\mathit{SchemeVal} \to \mathit{Bool}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">reference?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">v</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">integer?</span><span class="hspace"> </span><span class="RktSym">v</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">newref</span></span> : <span
                    class="texMathInline">\mathit{ExpVal} \to \mathit{Ref}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">newref</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">val</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">next-ref</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">length</span><span class="hspace"> </span><span class="RktSym">the-store</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">set!</span><span
                    class="hspace"> </span><span class="RktSym">the-store</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">append</span><span class="hspace"> </span><span
                    class="RktSym">the-store</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">list</span><span class="hspace"> </span><span class="RktSym">val</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktSym">next-ref</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">deref</span></span> : <span
                    class="texMathInline">\mathit{Ref} \to \mathit{ExpVal}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">deref</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">ref</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">list-ref</span><span class="hspace"> </span><span
                    class="RktSym">the-store</span><span class="hspace"> </span><span class="RktSym">ref</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>拙劣的存储器模型<a name="(elem._fig-4..1)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">setref!</span></span> : <span
                    class="texMathInline">\mathit{Ref} \times \mathit{ExpVal} \to \mathit{Unspecified}</span></td>
              </tr>
              <tr>
                <td><span class="emph"><span style="font-weight: bold">用法</span> : 除了把位置 <span class="stt">ref</span>
                    的值设为 <span class="stt">val</span>，<span class="stt">the-store</span> 与原状态相同。</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">setref!</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">ref</span><span
                    class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">set!</span><span
                    class="hspace"> </span><span class="RktSym">the-store</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">letrec</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">setref-inner</span></td>
              </tr>
              <tr>
                <td><span class="hspace">           </span><span class="emph"><span style="font-weight: bold">用法</span>
                    : 返回一列表，除了位置 ref1 处</span></td>
              </tr>
              <tr>
                <td><span class="hspace">           </span><span class="emph">值为 val，与 store1 相同。</span></td>
              </tr>
              <tr>
                <td><span class="hspace">           </span><span class="RktPn">(</span><span
                    class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">store1</span><span class="hspace"> </span><span class="RktSym">ref1</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">             </span><span class="RktPn">(</span><span
                    class="RktSym">cond</span></td>
              </tr>
              <tr>
                <td><span class="hspace">               </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">null?</span><span class="hspace"> </span><span
                    class="RktSym">store1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                 </span><span class="RktPn">(</span><span
                    class="RktSym">report-invalid-reference</span><span class="hspace"> </span><span
                    class="RktSym">ref</span><span class="hspace"> </span><span class="RktSym">the-store</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">               </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">zero?</span><span class="hspace"> </span><span
                    class="RktSym">ref1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                 </span><span class="RktPn">(</span><span
                    class="RktSym">cons</span><span class="hspace"> </span><span class="RktSym">val</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">cdr</span><span
                    class="hspace"> </span><span class="RktSym">store1</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">               </span><span class="RktPn">(</span><span
                    class="RktSym">else</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                 </span><span class="RktPn">(</span><span
                    class="RktSym">cons</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                   </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">store1</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                   </span><span class="RktPn">(</span><span
                    class="RktSym">setref-inner</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                     </span><span class="RktPn">(</span><span
                    class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">store1</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym"><span class="nobreak">-</span></span><span class="hspace"> </span><span
                    class="RktSym">ref1</span><span class="hspace"> </span><span class="RktVal">1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">setref-inner</span><span class="hspace"> </span><span
                    class="RktSym">the-store</span><span class="hspace"> </span><span class="RktSym">ref</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>拙劣的存储器模型，续<a name="(elem._fig-4..2)"></a></p>
        </blockquote>
      </blockquote>
      <p>这种表示极其低效。一般的内存操作大致在常数时间内完成，但是采用我们的表示，这些操
        作所需的时间与存储器大小成正比。当然，真正实现起来不会这么做，但这足以达到我们的
        目的。</p>
      <p>我们给表达值数据类型新增一种变体 <span class="stt">ref-val</span>，然后修改 <span class="stt">value-of-program</span>，
        在每次求值之前初始化存储器。</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">value-of-program</span></span> : <span
                    class="texMathInline">\mathit{Program} \to \mathit{SchemeVal}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">value-of-program</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">pgm</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">initialize-store!</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">program</span><span class="hspace"> </span><span
                    class="RktSym">pgm</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">a-program</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">exp1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">value-of</span><span class="hspace"> </span><span class="RktSym">exp1</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">init-env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>现在，我们可以写出 <span class="stt">value-of</span> 中与 <span class="stt">newref</span>、<span class="stt">deref</span>
          和 <span class="stt">setref</span> 相
          关的语句。这些语句如<span class="EoplFigureRef"></span> 所示。</p>
      </blockquote>
      <p>我们可以给该系统添加一些<a name="(elem._trace-instrument)"></a>辅助过程，把环境、过程和存
        储器转换为更易读的形式，也可以改善系统，在代码中的关键位置打印消息。我们还使用过
        程把环境、过程和存储器转换为更易读的形式。得出的日志详细描述了系统的动作。典型例
        子如<span class="EoplFigureRef"></span> 和 <span class="stt">fig-4.5</span> 所示。此外，这一跟踪日志还表明，
        差值表达式的参数按从左到右的顺序求值。
        <a name="(idx._(gentag._619))"></a>
        <a name="(idx._(gentag._620))"></a>
        <a name="(idx._(gentag._621))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..8)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>指出我们实现的存储器中，到底是哪些操作花费了线性时间而非常数时间。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..9)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>用 Scheme 向量表示存储器，从而实现常数时间操作。用这种表示会失去什么？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..10)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._622))"></a>
          实现<span class="EoplExerciseRef"></span> 中定义的 <span class="stt">begin</span> 表达式。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..11)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._623))"></a>
          实现<span class="EoplExerciseRef"></span> 中的 <span class="stt">list</span>。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..12)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._624))"></a>
          像解释器中展示的，我们对存储器的理解基于 Scheme 效果的含义。具体地说，我们得知道
          在 Scheme 程序中这些效果<span class="emph">何时</span>产生。我们可以写出更贴合规范的解释器，从而避
          免这种依赖。在这一解释器中，<span class="stt">value-of</span> 同时返回值和存储器，就像规范中那样。这
          一解释器的片段如<span class="EoplFigureRef"></span> 所示。我们称之为<span class="emph">传递存储器的解释器</span> (<span
            class="emph">store-passing
            interpreter</span>)。补全这个解释器，处理整个 EXPLICIT-REFS 语言。</p>
        <p>过程可能修改存储器时，不仅返回通常的值，还要返回一个新存储器。它们包含在名为
          <span class="stt">answer</span> 的数据类型之中。完成这个 <span class="stt">value-of</span> 的定义。
          <a name="(idx._(gentag._625))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..13)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._626))"></a>
          扩展前一道练习中的解释器，支持多参数过程。
          <a name="(idx._(gentag._627))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">newref-exp</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exp1</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">v1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">value-of</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">   </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">ref-val</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">newref</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">v1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"> </span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">deref-exp</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exp1</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">v1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">value-of</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">   </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ref1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">expval->ref</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">v1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">     </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">deref</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">ref1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"> </span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">setref-exp</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exp1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">exp2</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ref</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">expval->ref</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">value-of</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">exp1</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">env</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">   </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">val2</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">value-of</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp2</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">     </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">begin</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">       </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">setref!</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">ref</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">val2</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">       </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">num-val</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktVal">23</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p><span class="stt">value-of</span> 的显式引用操作语句
            <a name="(idx._(gentag._628))"></a><a name="(elem._fig-4..3)"></a>
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">> (run "</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">let x = newref(22)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">in let f = proc (z) let zz = newref(-(z,deref(x)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">                    </span><span class="stt">in
                  deref(zz)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in -((f 66), (f 55))")</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let x</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 0</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let x 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((x #(struct:ref-val 0))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(i #(struct:num-val 1))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(v #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(x #(struct:num-val
                  10)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 22)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let f</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let f 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((f</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">  </span><span class="stt">(procedure</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">z</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">...</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">((x #(struct:ref-val
                  0))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">    </span><span class="stt">(i #(struct:num-val
                  1))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">    </span><span class="stt">(v #(struct:num-val
                  5))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">    </span><span class="stt">(x #(struct:num-val
                  10)))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(x #(struct:ref-val 0))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(i #(struct:num-val 1))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(v #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(x #(struct:num-val
                  10)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 22)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 proc z 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((z #(struct:num-val 66))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(x #(struct:ref-val 0))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(i #(struct:num-val 1))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(v #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(x #(struct:num-val
                  10)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 22)))</span></p>
            </td>
          </tr>
        </table>
        <blockquote class="caption">
          <p>EXPLICIT-REFS的求值跟踪日志<a name="(elem._fig-4..4)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let zz</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 1</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let zz 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((zz #(struct:ref-val 1))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(z #(struct:num-val 66))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(x #(struct:ref-val 0))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(i #(struct:num-val 1))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(v #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(x #(struct:num-val
                  10)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 22)) (1 #(struct:num-val 44)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 proc z 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((z #(struct:num-val 55))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(x #(struct:ref-val 0))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(i #(struct:num-val 1))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(v #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(x #(struct:num-val
                  10)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 22)) (1 #(struct:num-val 44)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let zz</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 2</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let zz 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((zz #(struct:ref-val 2))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(z #(struct:num-val 55))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(x #(struct:ref-val 0))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(i #(struct:num-val 1))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(v #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(x #(struct:num-val
                  10)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 22))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(1 #(struct:num-val 44))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(2 #(struct:num-val
                  33)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">#(struct:num-val 11)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">></span></p>
            </td>
          </tr>
        </table>
        <blockquote class="caption">
          <p>EXPLICIT-REFS的求值跟踪日志，续<a name="(elem._fig-4..5)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                    class="hspace"> </span><span class="RktSym">answer</span><span class="hspace"> </span><span
                    class="RktSym">answer?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">an-answer</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">val</span><span
                    class="hspace"> </span><span class="RktSym">exp-val?</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">store</span><span
                    class="hspace"> </span><span class="RktSym">store?</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">value-of</span></span> : <span
                    class="texMathInline">\mathit{Exp} \times \mathit{Env} \times \mathit{Sto} \to
                    \mathit{ExpVal}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">value-of</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">exp</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="hspace"> </span><span
                    class="RktSym">store</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">expression</span><span class="hspace"> </span><span
                    class="RktSym">exp</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">const-exp</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">num</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">an-answer</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">num-val</span><span class="hspace"> </span><span class="RktSym">num</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">store</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">var-exp</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">var</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">an-answer</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">apply-store</span><span class="hspace"> </span><span class="RktSym">store</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">apply-env</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="hspace"> </span><span
                    class="RktSym">var</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktSym">store</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">if-exp</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">exp1</span><span class="hspace"> </span><span class="RktSym">exp2</span><span
                    class="hspace"> </span><span class="RktSym">exp3</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">cases</span><span class="hspace"> </span><span class="RktSym">answer</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">value-of</span><span
                    class="hspace"> </span><span class="RktSym">exp1</span><span class="hspace"> </span><span
                    class="RktSym">env</span><span class="hspace"> </span><span class="RktSym">store</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">an-answer</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">val</span><span class="hspace"> </span><span class="RktSym">new-store</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">expval->bool</span><span class="hspace"> </span><span class="RktSym">val</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">value-of</span><span class="hspace"> </span><span class="RktSym">exp2</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="hspace"> </span><span
                    class="RktSym">new-store</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">value-of</span><span class="hspace"> </span><span class="RktSym">exp3</span><span
                    class="hspace"> </span><span class="RktSym">env</span><span class="hspace"> </span><span
                    class="RktSym">new-store</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">deref-exp</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">exp1</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">cases</span><span class="hspace"> </span><span class="RktSym">answer</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">value-of</span><span
                    class="hspace"> </span><span class="RktSym">exp1</span><span class="hspace"> </span><span
                    class="RktSym">env</span><span class="hspace"> </span><span class="RktSym">store</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">an-answer</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">v1</span><span class="hspace"> </span><span class="RktSym">new-store</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">ref1</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">expval->ref</span><span class="hspace"> </span><span
                    class="RktSym">v1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">an-answer</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">deref</span><span class="hspace"> </span><span class="RktSym">ref1</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">new-store</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktSym">...</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p><span class="EoplExerciseRef"></span>，传递存储器的解释器<a name="(elem._fig-4..6)"></a></p>
        </blockquote>
      </blockquote>
      <h4>4.3<tt> </tt><a name="(part._s4..3)"></a>IMPLICIT-REFS：隐式引用语言</h4>
      <p><a name="(idx._(gentag._629))"></a>
        <a name="(idx._(gentag._630))"></a>
        <a name="(idx._(gentag._631))"></a>
        显式引用设计清晰描述了内存的分配、解引用和变更，因为显而易见，这些操作都在程序员
        的代码之中。
      </p>
      <p>大多数编程语言都用共同的方式处理分配、解引用和变更，并把它们打包为语言的一部分。
        这样，由于这些操作存在于语言内部，程序员不需要担心何时执行它们。
        <a name="(idx._(gentag._632))"></a>
      </p>
      <p>在这种设计中，每个变量都表示一个引用。指代值是包含表达值的位置的引用。引用不再是
        表达值，只能作为变量绑定。<a name="(idx._(gentag._633))"></a></p>
      <blockquote class="SubFlow">
        <p><span class="Iidentity">\begin{align*}\mathit{ExpVal} &= \mathit{Int} + \mathit{Bool} + \mathit{Proc} \\
            \mathit{DenVal} &= \mathit{Ref(ExpVal)}\end{align*}</span></p>
        <p>每次绑定操作都会分配一个位置：在每个过程调用处，在 <span class="stt">let</span> 和 <span class="stt">letrec</span> 中。</p>
      </blockquote>
      <p>当变量出现在表达式中，我们首先在环境中查找标识符，找到绑定的位置，然后在存储器中
        找出那个位置的值。因此对 <span class="stt">var-exp</span>，我们有个“二级”系统。</p>
      <p>一个位置的内容可用 <span class="stt">set</span> 表达式修改，语法为：</p>
      <p><span class="Iidentity">\begin{align*}\mathit{Expression} &::= <span class="stt">set </span><span
            class="Iidentity">\mathit{Identifier}</span><span class="stt"> = </span><span
            class="Iidentity">\mathit{Expression}</span> \\[-3pt]
          &\mathrel{\phantom{::=}} \fbox{<span class="stt">assign-exp (var exp1)</span>}\end{align*}</span></p>
      <p>这里的 <span class="texMathInline">\mathit{Identifier}</span> 不是表达式的一部分，所以无法解引用。在这种设计中，
        我们说变量是<span class="emph">可变的</span> (<span class="emph">mutable</span>)，意为可以修改。<a
          name="(idx._(gentag._634))"></a></p>
      <p><a name="(idx._(gentag._635))"></a>
        这种设计叫做<span class="emph">按值调用</span> (<span class="emph">call-by-value</span>)，或<span class="emph">隐式
          引用</span> (<span class="emph">implicit reference</span>)。大多数编程语言，包括 Scheme，都采纳这一设计的某种变体。</p>
      <p><span class="EoplFigureRef"></span> 是这种设计的两个示例程序。因为引用不再是表达值，我们不能
        像<a href="#%28part._s4..2%29" data-pltdoc="x">EXPLICIT-REFS：显式引用语言</a>中的例子那样做链式引用。</p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">let x = 0</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in letrec even(dummy)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">           </span><span class="stt">= if
                      zero?(x)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">             </span><span class="stt">then 1</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">             </span><span class="stt">else
                      begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">set x =
                      -(x,1);</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">(odd
                      888)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">                  </span><span class="stt">end</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">          </span><span class="stt">odd(dummy)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">           </span><span class="stt">= if
                      zero?(x)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">             </span><span class="stt">then 0</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">             </span><span class="stt">else
                      begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">set x =
                      -(x,1);</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">(even
                      888)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">                  </span><span class="stt">end</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in begin set x = 13; (odd
                      -888) end</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let g = let count = 0</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">        </span><span class="stt">in proc
                      (dummy)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">            </span><span class="stt">begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">             </span><span class="stt">set count =
                      -(count,-1);</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">             </span><span class="stt">count</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">            </span><span class="stt">end</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in let a = (g 11)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in let b = (g 11)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">      </span><span class="stt">in -(a,b)</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>IMPLICIT-REFS中的 <span class="stt">odd</span> 和 <span class="stt">even</span><a name="(elem._fig-4..7)"></a>
          </p>
        </blockquote>
      </blockquote>
      <h5>4.3.1<tt> </tt><a name="(part._s4..3..1)"></a>规范</h5>
      <p><a name="(idx._(gentag._636))"></a>
        我们可以轻松写出解引用和 <span class="stt">set</span> 的规则。现在，环境总是把变量绑定到位置，所以当
        变量作为表达式时，我们需要将其解引用：
        <span class="texMathDisplay"><span class="stt">(value-of (var-exp </span><span
            class="texMathInline">var</span><span class="stt">) </span><span class="texMathInline">\rho</span><span
            class="stt"> </span><span class="texMathInline">\sigma</span><span class="stt">)</span> = <span
            class="stt">(</span><span class="texMathInline">\sigma(\rho(var))</span><span class="stt">,</span><span
            class="texMathInline">\sigma</span><span class="stt">)</span></span>
      </p>
      <p>赋值就像我们预想的那样：我们在环境中查找式子左侧的标识符，获取一个位置，在环境中
        求右边表达式的值，修改指定位置的内容。就像 <span class="stt">setref</span>，<span class="stt">set</span> 表达式的返回值
        任意。我们让它返回表达值 27。
        <span class="texMathDisplay">\infer{<span class="stt">(value-of (assign-exp </span><span
            class="texMathInline">var</span><span class="stt"> </span><span class="texMathInline">exp_1</span><span
            class="stt">) </span><span class="texMathInline">\rho</span><span class="stt"> </span><span
            class="texMathInline">\sigma_0</span><span class="stt">) =</span><span class="stt">
          </span><span class="stt">(</span><span class="texMathInline">\lceil 27 \rceil</span><span
            class="stt">,[</span><span class="texMathInline">\rho(var)</span><span class="stt">=</span><span
            class="texMathInline">val_1</span><span class="stt">]</span><span class="texMathInline">\sigma_1</span><span
            class="stt">)</span>}
          {<span class="stt">(value-of </span><span class="texMathInline">exp_1</span><span class="stt"> </span><span
            class="texMathInline">\rho</span><span class="stt"> </span><span class="texMathInline">\sigma_0</span><span
            class="stt">)</span> = <span class="stt">(</span><span class="texMathInline">val_1</span><span
            class="stt">,</span><span class="texMathInline">\sigma_1</span><span class="stt">)</span>}</span>
      </p>
      <p><a name="(idx._(gentag._637))"></a>
        我们还要重写过程调用和 <span class="stt">let</span> 规则，体现出对存储器的修改。对过程调用，规则变成：
        <a name="(idx._(gentag._638))"></a>
        <a name="(idx._(gentag._639))"></a>
      </p>
      <blockquote class="SubFlow">
        <blockquote class="EoplEquationInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">(apply-procedure (procedure </span><span class="texMathInline">var</span><span
                    class="stt"></span><span class="hspace"> </span><span class="stt"></span><span
                    class="texMathInline">body</span><span class="stt"></span><span class="hspace"> </span><span
                    class="stt"></span><span class="texMathInline">\rho</span><span class="stt">) </span><span
                    class="texMathInline">val</span><span class="stt"></span><span class="hspace"> </span><span
                    class="stt"></span><span class="texMathInline">\sigma</span><span class="stt">)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">= (value-of </span><span class="texMathInline">body</span><span
                    class="stt"></span><span class="hspace"> </span><span class="stt">[</span><span
                    class="texMathInline">var=l</span><span class="stt">]</span><span
                    class="texMathInline">\rho</span><span class="stt"></span><span class="hspace"> </span><span
                    class="stt">[</span><span class="texMathInline">l=val</span><span class="stt">]</span><span
                    class="texMathInline">\sigma</span><span class="stt">)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>其中，<span class="texMathInline">l</span> 是不在 <span class="texMathInline">\sigma</span> 定义域中的某一位置。
          <a name="(idx._(gentag._640))"></a>
        </p>
      </blockquote>
      <p><a name="(idx._(gentag._641))"></a>
        <a name="(idx._(gentag._642))"></a>
        <span class="stt">(let-exp </span><span class="texMathInline">var</span><span class="stt"> </span><span
          class="texMathInline">exp_1</span><span class="stt"> </span><span class="texMathInline">body</span><span
          class="stt">)</span> 的规则类似。我们首先求右边 <span class="texMathInline">exp_1</span>
        的值，然后将该值放入一个新位置，将变量 <span class="texMathInline">var</span> 绑定到这个位置，在得到的环境中求
        <span class="stt">let</span> 主体的值，作为整个表达式的值。
        <a name="(idx._(gentag._643))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..14)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写出 <span class="stt">let</span> 的规则。</p>
      </blockquote>
      <h5>4.3.2<tt> </tt><a name="(part._s4..3..2)"></a>实现</h5>
      <p>现在我们着手修改解释器。在 <span class="stt">value-of</span> 中，我们取出每个 <span class="stt">var-exp</span> 的值，就像
        规则描述的那样：</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">var-exp</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">var</span><span class="RktPn">)</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">deref</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">apply-env</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">env</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">var</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p><span class="stt">assign-exp</span> 的代码也显而易见：</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">assign-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">var</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">exp1</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">begin</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">setref!</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">apply-env</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">var</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">value-of</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">exp1</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">env</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">num-val</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">27</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <p>创建引用呢？新的位置应在每一新绑定处创建。这门语言中只有四个地方创建新绑定：初始
        环境中、<span class="stt">let</span> 中、过程调用以及 <span class="stt">letrec</span> 中。</p>
      <p>在初始环境中，我们直接分配新位置。</p>
      <p><a name="(idx._(gentag._644))"></a>
        <a name="(idx._(gentag._645))"></a>
        对 <span class="stt">let</span>，我们修改 <span class="stt">value-of</span> 中相应的行，分配包含值的新位置，并把变量绑定
        到指向该位置的引用。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">let-exp</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">var</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp1</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">body</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">val1</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">value-of</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp1</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">value-of</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">body</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">extend-env</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">var</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">newref</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">val1</span><span class="RktPn">)</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">env</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._646))"></a>
        <a name="(idx._(gentag._647))"></a>
        <a name="(idx._(gentag._648))"></a>
        对过程调用，我们同样修改 <span class="stt">apply-procedure</span>，调用 <span class="stt">newref</span>。
      </p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">apply-procedure</span></span> : <span
                    class="texMathInline">\mathit{Proc} \times \mathit{ExpVal} \to \mathit{ExpVal}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">apply-procedure</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">proc1</span><span
                    class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">proc</span><span class="hspace"> </span><span
                    class="RktSym">proc1</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">procedure</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">var</span><span class="hspace"> </span><span class="RktSym">body</span><span
                    class="hspace"> </span><span class="RktSym">saved-env</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">value-of</span><span class="hspace"> </span><span class="RktSym">body</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">extend-env</span><span class="hspace"> </span><span class="RktSym">var</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">newref</span><span
                    class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span><span
                    class="hspace"> </span><span class="RktSym">saved-env</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._649))"></a>
          <a name="(idx._(gentag._650))"></a>
          <a name="(idx._(gentag._651))"></a>
        </div>
        </p>
      </blockquote>
      <p><a name="(idx._(gentag._652))"></a>
        <a name="(idx._(gentag._653))"></a>
        最后，要处理 <span class="stt">letrec</span>，我们替换 <span class="stt">apply-env</span> 中的 <span
          class="stt">extend-env-rec</span> 从句，
        令其返回一个引用，指向包含适当闭包的位置。由于我们使用多声明的
        <span class="stt">letrec</span>（<span class="EoplExerciseRef"></span>），<span class="stt">extend-env-rec</span>
        取一个过程名列表，一个
        绑定变量列表，一个过程主体列表，以及已保存的环境。过程 <span class="stt">location</span> 取一变量，
        一个变量列表。若变量存在于列表中，<span class="stt">location</span> 返回变量在列表中的位置；若不存在，
        返回 <span class="stt">#f</span>。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">extend-env-rec</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p-names</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">b-vars</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">p-bodies</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">saved-env</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">n</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">location</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">search-var</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">p-names</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">n</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">newref</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">        </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">proc-val</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">          </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">procedure</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">            </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">list-ref</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">b-vars</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">n</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">            </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">list-ref</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">p-bodies</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">n</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">            </span><span class="RktMeta"></span><span class="RktSym">env</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">apply-env</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">saved-env</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">search-var</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p><span class="EoplFigureRef"></span> 用<a href="#%28elem._trace-instrument%29" data-pltdoc="x">前面</a>介绍的辅助组件，展示了
        IMPLICIT-REFS 求值的简单例子。
        <a name="(idx._(gentag._654))"></a>
        <a name="(idx._(gentag._655))"></a>
      </p>
      <blockquote class="EoplFigure">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">> (run "</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">let f = proc (x) proc (y)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">         </span><span class="stt">begin</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">          </span><span class="stt">set x =
                  -(x,-1);</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">          </span><span class="stt">-(x,y)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">         </span><span class="stt">end</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">in ((f 44) 33)")</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 0</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 1</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 2</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let f</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 3</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let f 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((f 3) (i 0) (v 1) (x 2))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 1))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(1 #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(2 #(struct:num-val 10))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(3 (procedure x ... ((i 0) (v
                  1) (x 2)))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 4</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 proc x 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((x 4) (i 0) (v 1) (x 2))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 1))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(1 #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(2 #(struct:num-val 10))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(3 (procedure x ... ((i 0) (v
                  1) (x 2))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(4 #(struct:num-val
                  44)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 5</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 proc y 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((y 5) (x 4) (i 0) (v 1) (x 2))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 1))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(1 #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(2 #(struct:num-val 10))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(3 (procedure x ... ((i 0) (v
                  1) (x 2))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(4 #(struct:num-val 44))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(5 #(struct:num-val
                  33)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">#(struct:num-val 12)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">></span></p>
            </td>
          </tr>
        </table>
        <blockquote class="caption">
          <p>IMPLICIT-REFS的简单求值<a name="(elem._fig-4..8)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..15)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>在<span class="EoplFigureRef"></span> 中，环境中的变量为什么绑定到一般的整数，而不
          是<span class="EoplFigureRef"></span> 中那样的表达值？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..16)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._656))"></a>
          <a name="(idx._(gentag._657))"></a>
          既然变量是可变的，我们可以靠赋值产生递归过程。例如：
        </p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">letrec times4(x) = if zero?(x)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">then
                    0</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">else
                    -((times4 -(x,1)), -4)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in (times4 3)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>可以替换为：</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let times4 = 0</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in begin</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">set times4 = proc
                    (x)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">if
                    zero?(x)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">then
                    0</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span class="stt">else
                    -((times4 -(x,1)), -4);</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">(times4 3);</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">end</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>手动跟踪这个程序，验证这种翻译可行。
          <a name="(idx._(gentag._658))"></a>
          <a name="(idx._(gentag._659))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..17)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._660))"></a>
          写出规则并实现多参数过程和声明多变量的 <span class="stt">let</span>。
          <a name="(idx._(gentag._661))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..18)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._662))"></a>
          写出规则并实现声明多过程的 <span class="stt">letrec</span> 表达式。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..19)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._663))"></a>
          修改声明多过程的 <span class="stt">letrec</span> 实现，让每个闭包只生成一次，并且只分配一个位置。本
          题类似<span class="EoplExerciseRef"></span>。
          <a name="(idx._(gentag._664))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..20)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._665))"></a>
          在本节的语言中，就像在 Scheme 中一样，所有变量都是可变的。另一种设计是同时允许可
          变和不可变的变量绑定：
          <span class="Iidentity">\begin{align*}\mathit{ExpVal} &= \mathit{Int} + \mathit{Bool} + \mathit{Proc} \\
            \mathit{DenVal} &= \mathit{Ref(ExpVal)} + \mathit{ExpVal}\end{align*}</span>
          只有变量绑定可变时，才能赋值。当指代值是引用时，解引用自动进行。
        </p>
        <p>修改本节的语言，让 <span class="stt">let</span> 像之前那样引入不可变变量，可变变量则由
          <span class="stt">letmutable</span> 表达式引入，语法为：
          <span class="texMathDisplay">\mathit{Expression} ::= <span class="stt">letmutable </span><span
              class="texMathInline">\mathit{Identifier}</span><span class="stt"> = </span><span
              class="texMathInline">\mathit{Expression}</span><span class="stt"> in </span><span
              class="texMathInline">\mathit{Expression}</span></span>
          <a name="(idx._(gentag._666))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..21)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._667))"></a>
          <a name="(idx._(gentag._668))"></a>
          <a name="(idx._(gentag._669))"></a>
          <a name="(idx._(gentag._670))"></a>
          <a name="(idx._(gentag._671))"></a>
          <a name="(idx._(gentag._672))"></a>
          之前，我们建议两个相去很远的过程通过赋值交换信息，避免居间的过程知晓，从而使程序
          更加模块化。这样的赋值常常应该是临时的，只在执行函数调用时生效。向语言
          添加<span class="emph">动态赋值</span> (<span class="emph">dynamic assignment</span>)（又称<span
            class="emph">流式绑定</span> (<span class="emph">fluid binding</span>)）
          组件，完成这一操作。生成式为：
          <a name="(idx._(gentag._673))"></a>
        </p>
        <p><span class="Iidentity">\begin{align*}\mathit{Expression} &::= <span class="stt">setdynamic </span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> = </span><span
              class="Iidentity">\mathit{Expression}</span><span class="stt"> during </span><span
              class="Iidentity">\mathit{Expression}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">setdynamic-exp (var exp1 body)</span>}\end{align*}</span>
        </p>
        <p><span class="stt">setdynamic</span> 表达式的效果是把<span class="texMathInline">exp_1</span> 的值临时赋给 <span
            class="texMathInline">var</span>，求 <span class="texMathInline">body</span> 的值，
          重新给 <span class="texMathInline">var</span> 赋其原值，然后返回 <span class="texMathInline">body</span> 的值。变量 <span
            class="texMathInline">var</span> 必需已绑定。例如，
          在下列表达式中：</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let x = 11</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in let p = proc (y) -(y,x)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in -(setdynamic x = 17
                    during (p 22),</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">        </span><span class="stt">(p 13))</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p><span class="texMathInline">x</span> 是过程 <span class="stt">p</span> 中的自由变量，在调用 <span class="stt">(p
            22)</span> 中值为 17，在调用 <span class="stt">(p
            13)</span> 中重设为 11，所以表达式的值为 <span class="texMathInline">5-2=3</span>。
          <a name="(idx._(gentag._674))"></a>
          <a name="(idx._(gentag._675))"></a>
          <a name="(idx._(gentag._676))"></a>
          <a name="(idx._(gentag._677))"></a>
          <a name="(idx._(gentag._678))"></a>
          <a name="(idx._(gentag._679))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..22)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._680))"></a>
          迄今为止，我们的语言都是<span class="emph">面向表达式</span> (<span class="emph">expression-oriented</span>)的：我们感兴趣的
          主要是表达式这种句法类别和它们的值。扩展语言，建模简单
          的<span class="emph">面向语句</span> (<span class="emph">statement-oriented</span>) 的语言，其规范概述如下。一定要<span
            class="emph">遵循
            语法</span>，分别写出过程来处理程序、语句和表达式。</p>
        <blockquote class="Hangindent">
          <p><span style="font-weight: bold">值</span><span class="hspace"> </span>同 IMPLICIT-REFS。</p>
        </blockquote>
        <blockquote class="Hangindent">
          <p><span style="font-weight: bold">语法</span><span class="hspace"> </span>使用下列语法：</p>
          <blockquote class="SubFlow">
            <p><span class="Iidentity">\begin{align*} \mathit{Program} &::= \mathit{Statement} \\[-3pt]
                \mathit{Statement} &::= <span class="Iidentity">\mathit{Identifier}</span><span class="stt"> =
                </span><span class="Iidentity">\mathit{Expression}</span> \\[-3pt]
                &::= <span class="stt">print </span><span class="Iidentity">\mathit{Expression}</span> \\[-3pt]
                &::= \{\{\mathit{Statement}^{*(;)}\}\} \\[-3pt]
                &::= <span class="stt">if </span><span class="Iidentity">\mathit{Expression}</span><span class="stt">
                </span><span class="Iidentity">\mathit{Statement}</span><span class="stt"> </span><span
                  class="Iidentity">\mathit{Statement}</span> \\[-3pt]
                &::= <span class="stt">while </span><span class="Iidentity">\mathit{Expression}</span><span class="stt">
                </span><span class="Iidentity">\mathit{Statement}</span> \\[-3pt]
                &::= <span class="stt">var </span><span class="Iidentity">\{\mathit{Identifier}\}^{*(;)}</span><span
                  class="stt"> ; </span><span class="Iidentity">\mathit{Statement}</span> \\[-3pt]\end{align*}</span>
            </p>
          </blockquote>
          <p>非终结符 <span class="texMathInline">\mathit{Expression}</span> 指的是 IMPLICIT-REFS 语言中的表达式，可能稍有扩
            展。</p>
        </blockquote>
        <blockquote class="Hangindent">
          <p><span style="font-weight: bold">语义</span><span class="hspace"> </span>程序是一个语句。语句不返回值，而是修改和打印存储器。</p>
          <p>赋值语句仍按通常的方式执行。打印语句求出实参的值，打印结果。<span class="stt">if</span> 语句仍按通常
            的方式执行。块语句定义见 <span class="texMathInline">\mathit{Statement}</span> 中的最后一个生成式。它把每个声明
            变量绑定到一个未初始化的引用，然后执行块主体。这些绑定的作用域是块主体。</p>
          <p>用如下断言写出语句的规范：
            <span class="texMathDisplay"><span class="stt">(result-of </span><span
                class="texMathInline">stmt</span><span class="stt"> </span><span class="texMathInline">\rho</span><span
                class="stt"> </span><span class="texMathInline">\sigma_0</span><span class="stt">)</span> =
              \sigma_0</span>
          </p>
        </blockquote>
        <blockquote class="Hangindent">
          <p><span style="font-weight: bold">例子</span><span class="hspace"> </span>这里是一些例子。</p>
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">(run "var x,y; {x = 3; y = 4; print +(x,y)}") % 例1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">7</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">(run "var x,y,z; {x = 3;</span><span
                    class="hspace">                      </span><span class="stt">% 例2</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                  </span><span class="stt">y =
                    4;</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                  </span><span class="stt">z =
                    0;</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                  </span><span class="stt">while
                    not(zero?(x))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                    </span><span class="stt">{z =
                    +(z,y); x = -(x,1)};</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                  </span><span class="stt">print
                    z}")</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">12</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">(run "var x; {x = 3;</span><span
                    class="hspace">                          </span><span class="stt">% 例3</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">              </span><span class="stt">print x;</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">              </span><span class="stt">var x; {x = 4;
                    print x};</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">              </span><span class="stt">print
                    x}")</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">3</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">4</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">3</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">(run "var f,x; {f = proc(x,y) *(x,y);</span><span
                    class="hspace">         </span><span class="stt">% 例4</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                </span><span class="stt">x = 3;</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                </span><span class="stt">print (f 4
                    x)}")</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">12</span></p>
              </td>
            </tr>
          </table>
          <p>例 3 解释了块语句的作用域。</p>
          <p>例 4 解释了语句和表达式的交互。过程值创建并存储于变量 <span class="stt">f</span>。最后一行用实参 4
            和 <span class="stt">x</span> 调用这个过程；因为 <span class="stt">x</span> 绑定到一个引用，解引用得 3。</p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..23)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._681))"></a>
          给<span class="EoplExerciseRef"></span> 中的语言添加 <span class="stt">read</span> 语句，形如 <span class="stt">read
          </span><span class="texMathInline">var</span>。这
          一语句从输入读取一个非负数，存入指定的变量中。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..24)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._682))"></a>
          <span class="stt">do-while</span> 语句类似 <span class="stt">while</span>，但是条件判断在其主体<span
            class="emph">之后</span>执行。
          给<span class="EoplExerciseRef"></span> 中的语言添加 <span class="stt">do-while</span> 语句。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..25)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>扩展<span class="EoplExerciseRef"></span> 语言中的块语句，允许初始化变量。在你的解答中，变量的作
          用域是否包含同一个块语句中后续声明的变量？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..26)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._683))"></a>
          <a name="(idx._(gentag._684))"></a>
          扩展前一道练习中的解答，允许同一块语句中声明的过程互递归。考虑给语言增加限制，块
          中的过程声明要在变量声明之后。
          <a name="(idx._(gentag._685))"></a>
          <a name="(idx._(gentag._686))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..27)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._687))"></a>
          扩展前一道练习中的解答，增加<span class="emph">子程序</span> (<span class="emph">subroutine</span>)。我们把子程序当过程用，
          但是它不返回值，且其主体为语句而非表达式。然后增加子程序调用，作为一种新语句。扩
          展块的语法，允许同时声明过程和子程序。这将如何影响指代值和表达值？如果在子程序调
          用中使用过程会怎样？反过来呢？
          <a name="(idx._(gentag._688))"></a>
        </p>
      </blockquote>
      <h4>4.4<tt> </tt><a name="(part._s4..4)"></a>MUTABLE-PAIRS：可变序对语言</h4>
      <p><a name="(idx._(gentag._689))"></a>
        在<span class="EoplExerciseRef"></span> 中，我们给语言添加了列表，但它们是不可变的：不像 Scheme
        中，有 <span class="stt">set-car!</span> 和 <span class="stt">set-cdr!</span> 处理它们。</p>
      <p>现在，我们给 IMPLICIT-REFS 添加可变序对。序对是表达值，具有如下操作：</p>
      <p><span class="Iidentity">\begin{align*}<span style="font-weight: bold"><span class="stt">make-pair</span></span>
          &: \mathit{Expval} \times \mathit{Expval} \to \mathit{MutPair} \\
          <span style="font-weight: bold"><span class="stt">left</span></span> &: \mathit{MutPair} \to \mathit{Expval}
          \\
          <span style="font-weight: bold"><span class="stt">right</span></span> &: \mathit{MutPair} \to \mathit{Expval}
          \\
          <span style="font-weight: bold"><span class="stt">setleft</span></span> &: \mathit{MutPair} \times
          \mathit{Expval} \to \mathit{Unspecified} \\
          <span style="font-weight: bold"><span class="stt">setright</span></span> &: \mathit{MutPair} \times
          \mathit{Expval} \to \mathit{Unspecified}\end{align*}</span></p>
      <p>序对包含两个位置，二者可以分别赋值。由此得出语言值的<span class="emph">定
          义域方程</span> (<span class="emph">domain equations</span>)：</p>
      <p><span class="Iidentity">\begin{align*}\mathit{ExpVal} &= \mathit{Int} + \mathit{Bool} + \mathit{Proc} +
          \mathit{MutPair} \\
          \mathit{DenVal} &= \mathit{Ref(ExpVal)} \\
          \mathit{MutPair} &= \mathit{Ref(ExpVal)} \times \mathit{Ref(ExpVal)}\end{align*}</span></p>
      <p>我们把这种语言叫做 MUTABLE-PAIRS。
        <a name="(idx._(gentag._690))"></a>
      </p>
      <h5>4.4.1<tt> </tt><a name="(part._s4..4..1)"></a>实现</h5>
      <p><a name="(idx._(gentag._691))"></a>
        我们可以直接用前例中的 <span class="stt">reference</span> 数据类型实现可变序对。
        代码如<span class="EoplFigureRef"></span> 所示。</p>
      <p>完成图中的代码，给语言添加这些就很直接了。如<span class="EoplFigureRef"></span> 所示，我们给表
        达值数据类型新增一种变体 <span class="stt">mutpair-val</span>，给 <span class="stt">value-of</span> 新增 5 行代码。我们
        让 <span class="stt">setleft</span> 返回任意值 82，让 <span class="stt">setright</span> 返回 83。
        用<a href="#%28elem._trace-instrument%29" data-pltdoc="x">前述</a>辅助组件得到的示例跟踪日志
        如<span class="EoplFigureRef"></span> 所示。</p>
      <blockquote class="EoplFigure">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                  class="hspace"> </span><span class="RktSym">mutpair</span><span class="hspace"> </span><span
                  class="RktSym">mutpair?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">a-pair</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">left-loc</span><span
                  class="hspace"> </span><span class="RktSym">reference?</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">right-loc</span><span
                  class="hspace"> </span><span class="RktSym">reference?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">make-pair</span></span> : <span
                  class="texMathInline">\mathit{ExpVal} \times \mathit{ExpVal} \to \mathit{MutPair}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">make-pair</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">val1</span><span
                  class="hspace"> </span><span class="RktSym">val2</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">a-pair</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">newref</span><span
                  class="hspace"> </span><span class="RktSym">val1</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">newref</span><span
                  class="hspace"> </span><span class="RktSym">val2</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">left</span></span> : <span
                  class="texMathInline">\mathit{MutPair} \to \mathit{ExpVal}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">left</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">p</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">mutpair</span><span class="hspace"> </span><span
                  class="RktSym">p</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">a-pair</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">left-loc</span><span
                  class="hspace"> </span><span class="RktSym">right-loc</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">deref</span><span
                  class="hspace"> </span><span class="RktSym">left-loc</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">right</span></span> : <span
                  class="texMathInline">\mathit{MutPair} \to \mathit{ExpVal}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">right</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">p</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">mutpair</span><span class="hspace"> </span><span
                  class="RktSym">p</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">a-pair</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">left-loc</span><span
                  class="hspace"> </span><span class="RktSym">right-loc</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">deref</span><span
                  class="hspace"> </span><span class="RktSym">right-loc</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">setleft</span></span> : <span
                  class="texMathInline">\mathit{MutPair} \times \mathit{ExpVal} \to \mathit{Unspecified}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">setleft</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">p</span><span
                  class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">mutpair</span><span class="hspace"> </span><span
                  class="RktSym">p</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">a-pair</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">left-loc</span><span
                  class="hspace"> </span><span class="RktSym">right-loc</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">setref!</span><span class="hspace"> </span><span class="RktSym">left-loc</span><span
                  class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">setright</span></span> : <span
                  class="texMathInline">\mathit{MutPair} \times \mathit{ExpVal} \to \mathit{Unspecified}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">setright</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">p</span><span
                  class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">mutpair</span><span class="hspace"> </span><span
                  class="RktSym">p</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">a-pair</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">left-loc</span><span
                  class="hspace"> </span><span class="RktSym">right-loc</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">setref!</span><span class="hspace"> </span><span class="RktSym">right-loc</span><span
                  class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
        <blockquote class="caption">
          <p>可变序对的拙劣实现<a name="(elem._fig-4..9)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">newpair-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exp1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">exp2</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">val1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">value-of</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">val2</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">value-of</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">exp2</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">env</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">mutpair-val</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">make-pair</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">val1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">val2</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"> </span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">left-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exp1</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">val1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">value-of</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">p1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">expval->mutpair</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">val1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">left</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">p1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"> </span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">right-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exp1</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">val1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">value-of</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">p1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">expval->mutpair</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">val1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">right</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">p1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"> </span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">setleft-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exp1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">exp2</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">val1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">value-of</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">val2</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">value-of</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">exp2</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">env</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">p</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">expval->mutpair</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">val1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">begin</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">setleft</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">p</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">val2</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">num-val</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktVal">82</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"> </span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">setright-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exp1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">exp2</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">val1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">value-of</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">val2</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">value-of</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">exp2</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">env</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">p</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">expval->mutpair</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">val1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">begin</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">setright</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">p</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">val2</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">num-val</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktVal">83</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <p>
        <div class="SIntrapara">
          <blockquote class="caption">
            <p>给解释器添加可变序对模块<a name="(elem._fig-4..10)"></a></p>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._692))"></a></div>
        </p>
      </blockquote>
      <h5>4.4.2<tt> </tt><a name="(part._s4..4..2)"></a>可变序对的另一种表示</h5>
      <p>把可变序对表示为两个引用没有利用与 <span class="stt">MutPair</span> 相关的已知信息。序对中的两个位置
        虽然能够各自赋值，但它们不是独立分配的。我们知道它们会一起分配：如果序对的左侧是
        一个位置，那么右侧是下一个位置。所以我们还可以用左侧的引用表示序对。
        代码如<span class="EoplFigureRef"></span> 所示，不需再做其他修改。</p>
      <blockquote class="EoplFigure">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">> (run "let glo = pair(11,22)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">in let f = proc (loc)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">            </span><span class="stt">let d1 =
                  setright(loc, left(loc))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">            </span><span class="stt">in let d2 =
                  setleft(glo, 99)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">               </span><span class="stt">in
                  -(left(loc),right(loc))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in (f glo)")</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">;; 为 init-env 分配单元</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 0</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 1</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 2</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let glo</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">;; 为序对分配单元</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 3</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 4</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">;; 为 glo 分配单元</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 5</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let glo 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((glo 5) (i 0) (v 1) (x 2))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 1))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(1 #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(2 #(struct:num-val 10))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(3 #(struct:num-val 11))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(4 #(struct:num-val 22))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(5 #(struct:mutpair-val
                  #(struct:a-pair 3 4))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let f</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">;; 为 f 分配单元</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 6</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let f 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((f 6) (glo 5) (i 0) (v 1) (x 2))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 1))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(1 #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(2 #(struct:num-val 10))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(3 #(struct:num-val 11))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(4 #(struct:num-val 22))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(5 #(struct:mutpair-val
                  #(struct:a-pair 3 4)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(6 (procedure loc ... ((glo 5)
                  (i 0) (v 1) (x 2)))))</span></p>
            </td>
          </tr>
        </table>
        <blockquote class="caption">
          <p>MUTABLE-PAIRS求值的跟踪日志<a name="(elem._fig-4..11)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">;; 为 loc 分配单元</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 7</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 proc loc 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((loc 7) (glo 5) (i 0) (v 1) (x 2))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 1))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(1 #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(2 #(struct:num-val 10))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(3 #(struct:num-val 11))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(4 #(struct:num-val 22))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(5 #(struct:mutpair-val
                  #(struct:a-pair 3 4)))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(6 (procedure loc ... ((glo 5)
                  (i 0) (v 1) (x 2))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(7 #(struct:mutpair-val
                  #(struct:a-pair 3 4))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">#(struct:num-val 88)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">></span></p>
            </td>
          </tr>
        </table>
        <blockquote class="caption">
          <p>MUTABLE-PAIRS求值的跟踪日志，续<a name="(elem._fig-4..12)"></a></p>
        </blockquote>
      </blockquote>
      <p>与之类似，堆中的任何聚合对象都可以用其第一个位置的指针表示。但是，如果不提供区域
        的长度信息，指针本身无法指明一片内存区域（见<span class="EoplExerciseRef"></span>）。缺乏长度信
        息是经典安全问题的一大来源，比如写数组越界。</p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">mutpair?</span></span> : <span
                    class="texMathInline">\mathit{SchemeVal} \to \mathit{Bool}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">mutpair?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">v</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">reference?</span><span class="hspace"> </span><span class="RktSym">v</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">make-pair</span></span> : <span
                    class="texMathInline">\mathit{ExpVal} \times \mathit{ExpVal} \to \mathit{MutPair}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">make-pair</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">val1</span><span
                    class="hspace"> </span><span class="RktSym">val2</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">ref1</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">newref</span><span class="hspace"> </span><span class="RktSym">val1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">ref2</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">newref</span><span class="hspace"> </span><span class="RktSym">val2</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktSym">ref1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">left</span></span> : <span
                    class="texMathInline">\mathit{MutPair} \to \mathit{ExpVal}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">right</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">p</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">deref</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">+</span><span
                    class="hspace"> </span><span class="RktVal">1</span><span class="hspace"> </span><span
                    class="RktSym">p</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">right</span></span> : <span
                    class="texMathInline">\mathit{MutPair} \to \mathit{ExpVal}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">left</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">p</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">deref</span><span
                    class="hspace"> </span><span class="RktSym">p</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">setleft</span></span> : <span
                    class="texMathInline">\mathit{MutPair} \times \mathit{ExpVal} \to \mathit{Unspecified}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">setright</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">p</span><span
                    class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">setref!</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">+</span><span
                    class="hspace"> </span><span class="RktVal">1</span><span class="hspace"> </span><span
                    class="RktSym">p</span><span class="RktPn">)</span><span class="hspace"> </span><span
                    class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace"> </span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold"><span class="stt">setright</span></span> : <span
                    class="texMathInline">\mathit{MutPair} \times \mathit{ExpVal} \to \mathit{Unspecified}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">setright</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">p</span><span
                    class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">setref!</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">+</span><span
                    class="hspace"> </span><span class="RktVal">1</span><span class="hspace"> </span><span
                    class="RktSym">p</span><span class="RktPn">)</span><span class="hspace"> </span><span
                    class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>可变序对的另一种表示
            <a name="(idx._(gentag._693))"></a><a name="(elem._fig-4..13)"></a>
          </p>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._694))"></a></p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..28)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写出五个可变序对操作的推理规则规范。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..29)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._695))"></a>
          给语言添加数组。添加新操作符 <span class="stt">newarray</span>、<span class="stt">arrayref</span> 和 <span
            class="stt">arrayset</span>，用它
          们来创建、解引用和更新数组。这需要：</p>
        <p><span class="Iidentity">\begin{align*}\mathit{ArrVal} &= \mathit{(Ref(ExpVal))} \\
            \mathit{ExpVal} &= \mathit{Int} + \mathit{Bool} + \mathit{Proc} + \mathit{ArrVal} \\
            \mathit{DenVal} &= \mathit{Ref(ExpVal)}\end{align*}</span></p>
        <p>由于数组中的位置是连续的，用上述第二种表示。下面程序的结果是什么？</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let a = newarray(2,-99)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">p = proc (x)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">         </span><span class="stt">let v =
                    arrayref(x,1)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">         </span><span class="stt">in
                    arrayset(x,1,-(v,-1))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in begin arrayset(a,1,0); (p a); (p a); arrayref(a,1) end</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>这里 <span class="stt">newarray(2,-99)</span> 要创建长度为 2 的数组，数组中的每个位置都包含 -99。
          <span class="stt">begin</span> 表达式定义同<span class="EoplExerciseRef"></span>。令数组索引从 0 开始，所以长度为 2
          的数组索引为 0 和 1。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..30)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._696))"></a>
          给<span class="EoplExerciseRef"></span> 的语言添加过程 <span class="stt">arraylength</span>，返回数组的长度。你的过
          程运行时间应为常数。<span class="stt">arrayref</span> 和 <span class="stt">arrayset</span> 一定要查验索引，确保索引值在
          数组长度之内。</p>
      </blockquote>
      <h4>4.5<tt> </tt><a name="(part._s4..5)"></a>传参变体</h4>
      <p>当过程主体执行时，其形参绑定到一个指代值。那个值从哪儿来？它一定是过程调用传入实
        参的值。我们已见过两种传参方式：</p>
      <ul>
        <li>
          <p>自然传参，指代值与实参的表达值相同（<span class="stt">pass-by-value</span>）。</p>
        </li>
        <li>
          <p>按值调用，指代值是一个引用，指向一个位置，该位置包含实参的表达值
            （<a href="#%28part._s4..3%29" data-pltdoc="x">IMPLICIT-REFS：隐式引用语言</a>）。这是最常用的传参方式。
            <a name="(idx._(gentag._697))"></a>
          </p>
        </li>
      </ul>
      <p>本节探讨其他一些传参机制。</p>
      <h5>4.5.1<tt> </tt><a name="(part._s4..5..1)"></a>按指调用</h5>
      <p><a name="(idx._(gentag._698))"></a>
        <a name="(idx._(gentag._699))"></a>
        考虑下面的表达式：
      </p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let p = proc (x) set x = 4</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in let a = 3</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in begin (p a); a
                    end</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>按值调用时，绑定到 <span class="stt">x</span> 的指代值是一个引用，它包含的初始值与绑定到 <span class="stt">a</span> 的引
          用相同，但这些引用互不相干。所以赋值给 <span class="stt">x</span> 不会影响引用 <span class="stt">a</span> 的内容，整个表
          达式的值是 3。</p>
      </blockquote>
      <p>按值调用时，当过程给某个参数赋新值，调用者无法获悉。当然，如果传给调用者的参数像
        <a href="#%28part._s4..4%29" data-pltdoc="x">MUTABLE-PAIRS：可变序对语言</a>那样包含可变序对，那么调用者能看到 <span
          class="stt">setleft</span> 和 <span class="stt">setright</span> 的
        效果，但看不到 <span class="stt">set</span> 的效果。
      </p>
      <p>虽然这样隔离调用者和被调者常合所愿，但有些时候，给过程传递一个位置，并让过程给这
        个位置赋值也不无好处。要这样做，可以给过程传递一个引用，该引用指向调用者变量的位
        置，而不是变量的内容。这种传参机制叫做<span class="emph">按指调用</span> (<span class="emph">call-by-reference</span>)。如果
        操作数正是变量引用，那就传递变量位置的引用。然后，过程的形参绑定到这个位置。如果
        操作数是其他类型的表达式，那么形参绑定到一个新位置，该位置包含操作数的值，就像按
        值调用一样。在上例中使用按指调用，把 4 赋给 <span class="stt">x</span> 等效于把 4 赋给 <span class="stt">a</span>，所以
        整个表达式返回 4，而不是 3。</p>
      <p>按指调用过程，且实参为变量时，传递的不是按值调用中变量所在位置的内容，而是那个变
        量的<span class="emph">位置</span>。例如，考虑：</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let p = proc (x) set x = 44</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in let g = proc (y) (f y)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in let z = 55</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">      </span><span class="stt">in begin (g z); z
                    end</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>调用过程 <span class="stt">g</span> 时，<span class="stt">y</span> 绑定到 <span class="stt">z</span>
          的位置，而不是那个位置的内容。类似地，
          调用 <span class="stt">f</span> 时，<span class="stt">x</span> 绑定到同一个位置。所以，<span class="stt">x</span>、<span
            class="stt">y</span> 和 <span class="stt">z</span> 都绑定到
          同一位置，<span class="stt">set x = 44</span> 的效果是把那个位置的内容设为 44。因此，整个表达式的值
          是 44。执行这个表达式的跟踪日志如<span class="EoplFigureRef"></span> 和 <span class="stt">fig-4.15</span> 所
          示。在本例中，<span class="stt">x</span>、<span class="stt">y</span> 和 <span class="stt">z</span> 最终都绑定到位置 5。</p>
      </blockquote>
      <p>按指调用的常见用法是返回多个值。过程以通常方式返回一个值，并给按指传递的参数赋其
        他值。另一种例子，对换变量的值：</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let swap = proc (x) proc (y)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">let temp =
                    x</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">in begin</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                </span><span class="stt">set x =
                    y;</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                </span><span class="stt">set y =
                    temp</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">               </span><span class="stt">end</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in let a = 33</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in let b = 44</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">      </span><span class="stt">in begin</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">((swap a) b);</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">-(a,b)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">         </span><span class="stt">end</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>采用按指调用，这会对换 <span class="stt">a</span> 和 <span class="stt">b</span> 的值，所以它返回 11。但如果用已有的按值
          调用解释器执行这个程序，它会返回 -11，因为在对换过程的内部赋值对变量 <span class="stt">a</span> 和
          <span class="stt">b</span> 毫无影响。
        </p>
      </blockquote>
      <p>就像在按值调用中一样，在按指调用中，变量仍然指代表达值的引用：</p>
      <p><span class="Iidentity">\begin{align*}\mathit{ExpVal} &= \mathit{Int} + \mathit{Bool} + \mathit{Proc} \\
          \mathit{DenVal} &= \mathit{Ref(ExpVal)}\end{align*}</span></p>
      <p>唯一需要改变的是新位置的分配。按值调用中，求每个操作数的值都要分配新位置；按指调
        用中，只在求<span class="emph">非变量</span>操作数的值时才分配新位置。</p>
      <p>这很容易实现。函数 <span class="stt">apply-procedure</span> 必需修改，因为不是每个过程调用都要分配新
        位置。那份责任必须上移至 <span class="stt">value-of</span> 中的 <span class="stt">call-exp</span> ，因为它才具有做出判断
        所需的信息。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">apply-procedure</span></span> : <span
                  class="texMathInline">\mathit{Proc} \times \mathit{ExpVal} \to \mathit{ExpVal}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">apply-procedure</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">proc1</span><span
                  class="hspace"> </span><span class="RktSym">val</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">proc</span><span class="hspace"> </span><span
                  class="RktSym">proc1</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">procedure</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">var</span><span class="hspace"> </span><span class="RktSym">body</span><span
                  class="hspace"> </span><span class="RktSym">saved-env</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">value-of</span><span class="hspace"> </span><span class="RktSym">body</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">extend-env</span><span class="hspace"> </span><span class="RktSym">var</span><span
                  class="hspace"> </span><span class="RktSym">val</span><span class="hspace"> </span><span
                  class="RktSym">saved-env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>然后我们修改 <span class="stt">value-of</span> 中的 <span class="stt">call-exp</span>，引入新函数 <span
          class="stt">value-of-operand</span>
        来做必要的判断。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">call-exp</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">rator</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">rand</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">proc</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">expval->proc</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">value-of</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">rator</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">env</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">       </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">arg</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">value-of-operand</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">rand</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">   </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">apply-procedure</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">proc</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">arg</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>过程 <span class="stt">value-of-operand</span> 检查操作数是否为变量。如果是，则返回那个变量指代的引
        用，然后传给过程 <span class="stt">apply-procedure</span>；否则，它求出操作数的值，在新位置放入那个
        值，并返回指向该位置的引用。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">value-of-operand</span></span> : <span
                  class="texMathInline">\mathit{Exp} \times \mathit{Env} \to \mathit{Ref}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">value-of-operand</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">exp</span><span
                  class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">expression</span><span class="hspace"> </span><span
                  class="RktSym">exp</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">var-exp</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">var</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">apply-env</span><span class="hspace"> </span><span class="RktSym">env</span><span
                  class="hspace"> </span><span class="RktSym">var</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">else</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">newref</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">value-of</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                  class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>我们也可以按照同样的方式修改 <span class="stt">let</span>，但我们不这样做，因此语言中仍然保留按值调
        用的功能。</p>
      <p>多个按指调用参数可以指向同一个位置，如下面的程序所示。</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let b = 3</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in let p = proc (x) proc(y)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">begin</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">             </span><span class="stt">set x = 4;</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">             </span><span class="stt">y</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">            </span><span class="stt">end</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in ((p b) b)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>它的值为 4，因为 <span class="stt">x</span> 和 <span class="stt">y</span> 指向同一个位置，即 <span class="stt">b</span>
          的绑定。这种现象叫
          做<a name="(idx._(gentag._700))"></a><span class="emph">变量别名</span> (<span class="emph">variable
            aliasing</span>)。这里的 <span class="stt">x</span> 和
          <a name="(idx._(gentag._701))"></a>
          <span class="stt">y</span> 是同一个位置的别名（名字）。通常，我们在给一个变量赋值时并不想改变另一个
          变量的值，所以别名会导致程序难以理解。
        </p>
      </blockquote>
      <blockquote class="EoplFigure">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">> (run "</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">let f = proc (x) set x = 44</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">in let g = proc (y) (f y)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in let z = 55</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">      </span><span class="stt">in begin</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">          </span><span class="stt">(g z);</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">          </span><span class="stt">z</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">         </span><span class="stt">end")</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 0</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 1</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 2</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let f</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 3</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let f 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((f 3) (i 0) (v 1) (x 2))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 1))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(1 #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(2 #(struct:num-val 10))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(3 (procedure x ... ((i 0) (v
                  1) (x 2)))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let g</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 4</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let g 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((g 4) (f 3) (i 0) (v 1) (x 2))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 1))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">(1 #(struct:num-val 5))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">(2 #(struct:num-val 10))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">(3 (procedure x ... ((i 0) (v 1) (x 2))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">(4 (procedure y ... ((f 3) (i 0) (v 1) (x 2)))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let z</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">newref: 分配位置 5</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">进入 let z 主体，环境 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((z 5) (g 4) (f 3) (i 0) (v 1) (x 2))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">存储器 =</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt">((0 #(struct:num-val 1))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(1 #(struct:num-val 5))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(2 #(struct:num-val 10))</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(3 (procedure x ... ((i 0) (v
                  1) (x 2))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(4 (procedure y ... ((f 3) (i
                  0) (v 1) (x 2))))</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(5 #(struct:num-val
                  55)))</span></p>
            </td>
          </tr>
        </table>
        <blockquote class="caption">
          <p>CALL-BY-REFERENCE 的简单求值<a name="(elem._fig-4..14)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">进入 proc y 主体，环境 =</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">((y 5) (f 3) (i 0) (v 1) (x 2))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">存储器 =</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">((0 #(struct:num-val 1))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(1 #(struct:num-val
                    5))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(2 #(struct:num-val
                    10))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(3 (procedure x ... ((i 0) (v
                    1) (x 2))))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(4 (procedure y ... ((f 3) (i
                    0) (v 1) (x 2))))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(5 #(struct:num-val
                    55)))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">进入 proc x 主体，环境 =</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">((x 5) (i 0) (v 1) (x 2))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">存储器 =</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">((0 #(struct:num-val 1))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(1 #(struct:num-val
                    5))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(2 #(struct:num-val
                    10))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(3 (procedure x ... ((i 0) (v
                    1) (x 2))))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(4 (procedure y ... ((f 3) (i
                    0) (v 1) (x 2))))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(5 #(struct:num-val
                    55)))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">#(struct:num-val 44)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">></span></p>
              </td>
            </tr>
          </table>
        </div>
        </p>
        <blockquote class="caption">
          <p>CALL-BY-REFERENCE 的简单求值，续<a name="(elem._fig-4..15)"></a></p>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._702))"></a>
        <a name="(idx._(gentag._703))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..31)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写出 CALL-BY-REFERENCE 的推理规则规范。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..32)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>扩展语言 CALL-BY-REFERENCE，支持多参数过程。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..33)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>扩展语言
          CALL-BY-REFERENCE，也令其支持按值调用的过程。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..34)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>给语言添加按指调用的 <span class="stt">let</span>，名为 <span class="stt">letref</span>。写出规范并实现。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..35)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>在按值调用框架下，我们仍能享受按指调用的便利。扩展语言 IMPLICIT-REF，添加新表达
          式：</p>
        <p><span class="Iidentity">\begin{align*}\mathit{Expression} &::= <span class="stt">ref </span><span
              class="Iidentity">\mathit{Identifier}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">ref-exp (var)</span>}\end{align*}</span></p>
        <p>这与语言 EXPLICIT-REF 不同。因为引用只能从变量获得。这就使我们能用按值调用语言写
          出类似 <span class="stt">swap</span> 的程序。下面表达式的值是什么？</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let a = 3</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">b = 4</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in let swap = proc (x) proc (y)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">               </span><span class="stt">let temp =
                    deref(x)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">               </span><span class="stt">in begin</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span
                    class="stt">setref(x,deref(y));</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                   </span><span
                    class="stt">setref(y,temp)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                  </span><span class="stt">end</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in begin ((swap ref a) ref
                    b); -(a,b) end</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>此处使用支持多声明的 <span class="stt">let</span>（<span class="EoplExerciseRef"></span>）。这种语言的表达值和指代值
          是什么？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..36)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._704))"></a>
          大多数语言支持数组，在按指调用中，数组引用通常以类似变量引用的方式处理。如果操作
          数是数组引用，那就不给被调过程传递它的内容，而是传递引用指向的位置。比如，需要调
          用对换过程的常见情形是交换数组元素，传递数组引用就能用上对换过程。给按指调用语言
          添加<span class="EoplExerciseRef"></span> 中的数组操作符，扩展 <span class="stt">value-of-operand</span>，处理这种情
          况，使下例中的过程调用能够如愿执行：</p>
        <blockquote class="SCentered">
          <p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">swap</span><span
              class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
              class="RktPn">(</span><span class="RktSym">arrayref</span><span class="RktMeta"></span><span
              class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">a</span><span
              class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
              class="RktSym">i</span><span class="RktPn">)</span><span class="RktPn">)</span><span
              class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
              class="RktPn">(</span><span class="RktSym">arrayref</span><span class="RktMeta"></span><span
              class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">a</span><span
              class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
              class="RktSym">j</span><span class="RktPn">)</span><span class="RktPn">)</span><span
              class="RktMeta"></span></p>
        </blockquote>
        <p>要是下面这样呢？</p>
        <blockquote class="SCentered">
          <p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">swap</span><span
              class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
              class="RktPn">(</span><span class="RktSym">arrayref</span><span class="RktMeta"></span><span
              class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">a</span><span
              class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
              class="RktPn">(</span><span class="RktSym">arrayref</span><span class="RktMeta"></span><span
              class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">a</span><span
              class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
              class="RktSym">i</span><span class="RktPn">)</span><span class="RktPn">)</span><span
              class="RktPn">)</span><span class="RktMeta"></span><span class="hspace"> </span><span
              class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">arrayref</span><span
              class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
              class="RktSym">a</span><span class="RktMeta"></span><span class="hspace"> </span><span
              class="RktMeta"></span><span class="RktSym">j</span><span class="RktPn">)</span><span
              class="RktPn">)</span><span class="RktMeta"></span></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..37)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._705))"></a>
          <span class="emph">按值和结果调用</span> (<span class="emph">call-by-value-result</span>) 是按指调用的一种变体。在按值和结果
          调用中，实参必需是变量。传递参数时，形参绑定到新的引用，初值为实参的值，就像按值
          调用一样。然后过程主体照常执行。但过程主体返回时，新引用处的值复制到实参指代的引
          用中。因为这样可以改进内存分配，所以可能比按指调用更高效。实现按值和结果调用，写
          出一个过程，使之在按指调用与按值和结果调用中产生不同的答案。
          <a name="(idx._(gentag._706))"></a>
        </p>
      </blockquote>
      <h5>4.5.2<tt> </tt><a name="(part._s4..5..2)"></a>懒求值：按名调用和按需调用</h5>
      <p><a name="(idx._(gentag._707))"></a>
        <a name="(idx._(gentag._708))"></a>
        <a name="(idx._(gentag._709))"></a>
        迄今为止，我们讨论的所有参数传递机制都是<span class="emph">即时</span> (<span class="emph">eager</span>)的：它们总是找出每个
        操作数的值。现在我们来看另一种截然不同的传参机制，名叫<span class="emph">懒求值</span> (<span class="emph">lazy
          evaluation</span>)。在懒求值中，操作数的值直到过程主体需要时才会求取。如果过程
        主体从未引用相关参数，就不需求操作数的值。
      </p>
      <p>这可能使程序免于永不终止。例如，考虑：</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">letrec infinite-loop (x) = infinite-loop(-(x,-1))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in let f = proc (z) 11</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in (f (infinite-loop
                    0))</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>这里的 <span class="stt">infinite-loop</span> 是一个过程，调用时永不终止。<span class="stt">f</span> 是一个过程，调用时
          不引用它的参数，总返回 11。我们考虑过的任何一种传参机制都无法使这个程序终止。但
          在懒求值中，这个程序将返回 11，因为操作数 <span class="stt">(infinite-loop 0)</span> 没有求值。</p>
      </blockquote>
      <p>现在，我们使用懒求值修改我们的语言。在懒求值中，如无必要，我们不求操作数表达式的
        值。因此，我们将过程的绑定变量与未求值的操作数关联起来。当过程主体需要绑定变量的
        值时，我们先求对应操作数的值。有时，我们把不求操作数的值而传给过程
        叫做<span class="emph">冻结</span> (<span class="emph">frozen</span>)，把过程求操作数的值叫做<span class="emph">解冻</span> (<span
          class="emph">thawed</span>)。
        <a name="(idx._(gentag._710))"></a>
        <a name="(idx._(gentag._711))"></a>
      </p>
      <p><a name="(idx._(gentag._712))"></a>
        当然，我们还要加入过程求值时的环境。要这样，我们引入一种新的数据类型，
        <span class="emph">值箱</span> (<span class="emph">thunk</span>)。值箱包含一个表达式、一个环境。
      </p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                    class="hspace"> </span><span class="RktSym">thunk</span><span class="hspace"> </span><span
                    class="RktSym">thunk?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">a-thunk</span></td>
              </tr>
              <tr>
                <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">exp1</span><span
                    class="hspace"> </span><span class="RktSym">expression?</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">   </span><span class="RktPn">(</span><span class="RktSym">env</span><span
                    class="hspace"> </span><span class="RktSym">environment?</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>当过程需要使用绑定变量的值时，会求相应值箱的值。</p>
      </blockquote>
      <p>我们面对的情况稍稍复杂一些，因为我们需要同时容纳懒求值、计算效果和即时求值
        （<span class="stt">let</span> 需要）。因此，我们把指代值定为内存位置的引用，位置包含表达值或者值箱。</p>
      <p><span class="Iidentity">\begin{align*}\mathit{DenVal} &= \mathit{Ref(ExpVal + Thunk)} \\
          \mathit{ExpVal} &= \mathit{Int} + \mathit{Bool} + \mathit{Proc}\end{align*}</span></p>
      <p>我们的位置分配策略与按指调用类似：如果操作数是变量，那么我们传递指代的引用；否则，
        我们给未求值的参数在新位置放一个值箱，传递该位置的引用。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">value-of-operand</span></span> : <span
                  class="texMathInline">\mathit{Exp} \times \mathit{Env} \to \mathit{Ref}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">value-of-operand</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">exp</span><span
                  class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">expression</span><span class="hspace"> </span><span
                  class="RktSym">exp</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">var-exp</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">var</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">apply-env</span><span class="hspace"> </span><span class="RktSym">env</span><span
                  class="hspace"> </span><span class="RktSym">var</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">else</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">newref</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">a-thunk</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                  class="hspace"> </span><span class="RktSym">env</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>求 <span class="stt">var-exp</span> 的值时，我们首先找到变量绑定的位置。如果该位置是一个表达值，那么
        返回这个值，作为 <span class="stt">var-exp</span> 的值。如果它包含一个值箱，那么我们求取并返回值箱的
        值。这叫做<span class="emph">按名调用</span> (<span class="emph">call by name</span>)。
        <a name="(idx._(gentag._713))"></a>
        <a name="(idx._(gentag._714))"></a>
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">var-exp</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">var</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ref1</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">apply-env</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">env</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">var</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">w</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">deref</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">ref1</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">expval?</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">val</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">        </span><span
                  class="RktMeta"></span><span class="RktSym">val</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">        </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">value-of-thunk</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>过程 <span class="stt">value-of-thunk</span> 定义如下：</p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">value-of-thunk</span></span> : <span
                    class="texMathInline">\mathit{Thunk} \to \mathit{ExpVal}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">value-of-thunk</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">th</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">thunk</span><span class="hspace"> </span><span
                    class="RktSym">th</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">a-thunk</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">exp1</span><span class="hspace"> </span><span class="RktSym">saved-env</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">value-of</span><span class="hspace"> </span><span class="RktSym">exp1</span><span
                    class="hspace"> </span><span class="RktSym">saved-env</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._715))"></a></div>
        </p>
      </blockquote>
      <p>或者，一旦发现值箱的值，我们可以把表达值放到同一个位置，这样就不需要再次求值箱的
        值。这种方式叫做<span class="emph">按需调用</span> (<span class="emph">call by need</span>)。
        <a name="(idx._(gentag._716))"></a>
        <a name="(idx._(gentag._717))"></a>
      </p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">var-exp</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">var</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">ref1</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">apply-env</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">env</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">var</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">w</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">deref</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">ref1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">if</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">expval?</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">w</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktSym">w</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">val1</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">value-of-thunk</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">w</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">          </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">begin</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">            </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">setref!</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">ref1</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">val1</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">            </span><span class="RktMeta"></span><span class="RktSym">val1</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>这里用到了名为<span class="emph">助记法</span> (<span class="emph">memoization</span>) 的通用策略。
          <a name="(idx._(gentag._718))"></a>
          <a name="(idx._(gentag._719))"></a>
        </p>
      </blockquote>
      <p>各种形式的懒求值引人之处在于，即使没有效果，通过它也能以相当简单的方式思考程序。
        把过程调用替换为过程的主体，把过程主体内对每个形参的引用替换为对应的操作数，就能
        建模过程调用。这种求值策略是 lambda 演算的基础，在 lambda 演算中，它叫做
        <span class="emph"><span class="texMathInline">\beta</span>-推导</span> (<span class="emph"><span
            class="texMathInline">\beta</span>-reduction</span>)。
        <a name="(idx._(gentag._720))"></a>
        <a name="(idx._(gentag._721))"></a>
      </p>
      <p>不幸的是，按名调用和按需调用使求值顺序难以确定，而这对理解有效果的程序至关重要。
        但没有效果时，这不成问题。所以懒求值盛行于函数式编程语言（没有计算效果的那些），
        在别处却杳无踪影。
        <a name="(idx._(gentag._722))"></a>
        <a name="(idx._(gentag._723))"></a>
        <a name="(idx._(gentag._724))"></a>
        <a name="(idx._(gentag._725))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..38)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>下面的例子展示了<span class="EoplExerciseRef"></span> 在按需调用中的变体。<span
            class="EoplExerciseRef"></span>
          中的原始程序在按需调用中可行吗？如果下面的程序在按值调用中运行呢？为什么？</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let makerec = proc (f)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">               </span><span class="stt">let d = proc
                    (x) (f (x x))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">               </span><span class="stt">in (f (d
                    d))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in let maketimes4 = proc (f)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                     </span><span class="stt">proc
                    (x)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                      </span><span class="stt">if
                    zero?(x)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                      </span><span class="stt">then
                    0</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                      </span><span class="stt">else
                    -((f -(x,1)), -4)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">in let times4 = (makerec
                    maketimes4)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">      </span><span class="stt">in (times4 3)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..39)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>没有计算效果的话，按名调用和按需调用总是给出同样的答案。设计一个例子，让按名调用
          和按需调用给出不同的答案。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..40)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>修改 <span class="stt">value-of-operand</span>，避免为常量和过程生成值箱。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..41)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写出按名调用和按需调用的推理规则规范。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex4..42)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>给按需调用解释器添加懒求值的 <span class="stt">let</span>。</p>
      </blockquote>
      <div class="navsetbottom"><span class="navleft">
          <div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);"
              title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
        </span><span class="navright">  <a href="expr.html" title="backward to " 3 表达式"" data-pltdoc="x">← prev</a>  <a
            href="index.html" title="up to " 编程语言要素"" data-pltdoc="x">up</a>  <a href="cpi.html" title="forward to " 5
            传递续文的解释器"" data-pltdoc="x">next →</a></span> </div>
    </div>
  </div>
  <div id="contextindicator"> </div>
</body>

</html>