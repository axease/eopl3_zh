<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=0.8" />
  <title>1 归纳式数据集</title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default" />
  <link rel="stylesheet" type="text/css" href="racket.css" title="default" />
  <link rel="stylesheet" type="text/css" href="tip.css" title="default" />
  <link rel="stylesheet" type="text/css" href="scribble-style.css" title="default" />
  <script type="text/javascript" src="scribble-common.js"></script>
  <script src="katex/katex.min.js"></script>
  <script src="onload.js"></script>

</head>

<body id="scribble-racket-lang-org">
  <div class="tocset">
    <div class="tocview">
      <div class="tocviewlist tocviewlisttopspace">
        <div class="tocviewtitle">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle"
                  onclick="TocviewToggle(this,"tocview_0");">▼</a></td>
              <td></td>
              <td><a href="index.html" class="tocviewlink"
                  data-pltdoc="x">编程语言要素</a></td>
            </tr>
          </table>
        </div>
        <div class="tocviewsublisttop" style="display: block;" id="tocview_0">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td align="right"></td>
              <td><a href="fw-trans.html" class="tocviewlink" data-pltdoc="x">译者的话</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="glo.html" class="tocviewlink" data-pltdoc="x">译名表</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="fw.html" class="tocviewlink" data-pltdoc="x">序</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="pf.html" class="tocviewlink" data-pltdoc="x">前言</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="awk.html" class="tocviewlink" data-pltdoc="x">致谢</a></td>
            </tr>
            <tr>
              <td align="right">1 </td>
              <td><a href="" class="tocviewselflink"
                  data-pltdoc="x">归纳式数据集</a></td>
            </tr>
            <tr>
              <td align="right">2 </td>
              <td><a href="da.html" class="tocviewlink" data-pltdoc="x">数据抽象</a></td>
            </tr>
            <tr>
              <td align="right">3 </td>
              <td><a href="expr.html" class="tocviewlink" data-pltdoc="x">表达式</a></td>
            </tr>
            <tr>
              <td align="right">4 </td>
              <td><a href="state.html" class="tocviewlink" data-pltdoc="x">状态</a></td>
            </tr>
            <tr>
              <td align="right">5 </td>
              <td><a href="cpi.html" class="tocviewlink"
                  data-pltdoc="x">传递续文的解释器</a></td>
            </tr>
            <tr>
              <td align="right">6 </td>
              <td><a href="cps.html" class="tocviewlink"
                  data-pltdoc="x">续文传递风格</a></td>
            </tr>
            <tr>
              <td align="right">7 </td>
              <td><a href="types.html" class="tocviewlink" data-pltdoc="x">类型</a></td>
            </tr>
            <tr>
              <td align="right">8 </td>
              <td><a href="modules.html" class="tocviewlink" data-pltdoc="x">模块</a></td>
            </tr>
            <tr>
              <td align="right">9 </td>
              <td><a href="oac.html" class="tocviewlink" data-pltdoc="x">对象和类</a></td>
            </tr>
            <tr>
              <td align="right">10 </td>
              <td><a href="further-reading.html" class="tocviewlink"
                  data-pltdoc="x">扩展阅读</a></td>
            </tr>
            <tr>
              <td align="right">11 </td>
              <td><a href="sllgen-parsing-system.html" class="tocviewlink"
                  data-pltdoc="x">SLLGEN解析系统</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="bib.html" class="tocviewlink" data-pltdoc="x">参考书目</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="indices.html" class="tocviewlink" data-pltdoc="x">索引</a></td>
            </tr>
          </table>
        </div>
      </div>
      <div class="tocviewlist">
        <table cellspacing="0" cellpadding="0">
          <tr>
            <td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle"
                onclick="TocviewToggle(this,"tocview_1");">►</a></td>
            <td>1 </td>
            <td><a href="" class="tocviewselflink" data-pltdoc="x">归纳式数据集</a>
            </td>
          </tr>
        </table>
        <div class="tocviewsublistbottom" style="display: none;" id="tocview_1">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td align="right">1.1 </td>
              <td><a href="#%28part._s1..1%29" class="tocviewlink"
                  data-pltdoc="x">递推定义的数据</a></td>
            </tr>
            <tr>
              <td align="right">1.2 </td>
              <td><a href="#%28part._s1..2%29" class="tocviewlink"
                  data-pltdoc="x">推导递归程序</a></td>
            </tr>
            <tr>
              <td align="right">1.3 </td>
              <td><a href="#%28part._s1..3%29" class="tocviewlink"
                  data-pltdoc="x">辅助过程和上下文参数</a>
              </td>
            </tr>
            <tr>
              <td align="right">1.4 </td>
              <td><a href="#%28part._s1..4%29" class="tocviewlink" data-pltdoc="x">练习</a></td>
            </tr>
          </table>
        </div>
      </div>
    </div>
    <div class="tocsub">
      <div class="tocsubtitle">On this page:</div>
      <table class="tocsublist" cellspacing="0">
        <tr>
          <td><span class="tocsublinknumber">1.1<tt> </tt></span><a href="#%28part._s1..1%29" class="tocsubseclink"
              data-pltdoc="x">递推定义的数据</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">1.1.1<tt> </tt></span><a href="#%28part._s1..1..1%29"
              class="tocsubseclink" data-pltdoc="x">归纳定义法</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">1.1.2<tt> </tt></span><a href="#%28part._s1..1..2%29"
              class="tocsubseclink" data-pltdoc="x">语法定义法</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">1.1.3<tt> </tt></span><a href="#%28part._s1..1..3%29"
              class="tocsubseclink" data-pltdoc="x">归纳证明法</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">1.2<tt> </tt></span><a href="#%28part._s1..2%29" class="tocsubseclink"
              data-pltdoc="x">推导递归程序</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">1.2.1<tt> </tt></span><a href="#%28part._s1..2..1%29"
              class="tocsubseclink" data-pltdoc="x"><span class="stt">list-<wbr></wbr>length</span></a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">1.2.2<tt> </tt></span><a href="#%28part._s1..2..2%29"
              class="tocsubseclink" data-pltdoc="x"><span class="stt">nth-<wbr></wbr>element</span></a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">1.2.3<tt> </tt></span><a href="#%28part._s1..2..3%29"
              class="tocsubseclink" data-pltdoc="x"><span class="stt">remove-<wbr></wbr>first</span></a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">1.2.4<tt> </tt></span><a href="#%28part._s1..2..4%29"
              class="tocsubseclink" data-pltdoc="x"><span class="stt">occurs-<wbr></wbr>free?</span></a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">1.2.5<tt> </tt></span><a href="#%28part._s1..2..5%29"
              class="tocsubseclink" data-pltdoc="x"><span class="stt">subst</span></a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">1.3<tt> </tt></span><a href="#%28part._s1..3%29" class="tocsubseclink"
              data-pltdoc="x">辅助过程和上下文参数</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">1.4<tt> </tt></span><a href="#%28part._s1..4%29" class="tocsubseclink"
              data-pltdoc="x">练习</a></td>
        </tr>
      </table>
    </div>
  </div>
  <div class="maincolumn">
    <div class="main">
      <div class="navsettop"><span class="navleft">
          <div class="nosearchform"></div>  <span class="tocsettoggle">  <a
              href="javascript:void(0);" title="show/hide table of contents"
              onclick="TocsetToggle();">contents</a></span>
        </span><span class="navright">  <a href="awk.html" title="backward to "致谢""
            data-pltdoc="x">← prev</a>  <a href="index.html" title="up to "编程语言要素""
            data-pltdoc="x">up</a>  <a href="da.html" title="forward to "2 数据抽象""
            data-pltdoc="x">next →</a></span> </div>
      <p class="SPretitle"><span class="mainmatter"></span></p>
      <h3>1<tt> </tt><a name="(part._isd)"></a>归纳式数据集</h3>
      <p>
        解释器与检查器一类的程序是编程语言处理器的核心，本章介绍写这些用到的基本编程工具。
      </p>
      <p>
        因为编程语言的语法通常为嵌套或者树状结构，递归将是我们的主要技巧。
        <a href="#%28part._s1..1%29"
          data-pltdoc="x">递推定义的数据</a>和<a
          href="#%28part._s1..2%29"
          data-pltdoc="x">推导递归程序</a>介绍归纳定义数据结构的方法，并展示如何用这类定义指导
        递归程序的编写。<a href="#%28part._s1..3%29"
          data-pltdoc="x">辅助过程和上下文参数</a>展示如何将这些技巧推广到更为复杂的程序。本章以大量
        练习作结。这些练习是本章的核心。欲掌握本书余下部分依赖的递归编程技巧，得自它们的
        经验不可或缺。
      </p>
      <h4>1.1<tt> </tt><a name="(part._s1..1)"></a>递推定义的数据</h4>
      <p><a name="(idx._(gentag._8))"></a>
        编写过程代码时，必须明确知道什么样的值能作为过程的参数，什么样的值是过程的合法返
        回值。这些值的集合通常很复杂。本节介绍定义值集合的形式化技术。
      </p>
      <h5>1.1.1<tt> </tt><a name="(part._s1..1..1)"></a>归纳定义法</h5>
      <p><a name="(idx._(gentag._9))"></a>
        归纳定义法是定义值集合的有效方法。为解释这一方法，我们用它来描述自然数
        <span class="texMathInline">N =
          {0,1,2,...}</span> 的某一子集 <span class="texMathInline">S</span>。</p>
      <blockquote class="EoplDefinition">
        <p>
        <div class="SIntrapara"><a name="(elem._d1..1..1)"></a><span class="hspace"> </span><a
            name="(idx._(gentag._10))"></a>
          自然数 <span class="texMathInline">n</span> 属于 <span
            class="texMathInline">S</span>，当且仅当：
        </div>
        <div class="SIntrapara">
          <ol>
            <li>
              <p><span class="texMathInline">n = 0</span>，或</p>
            </li>
            <li>
              <p><span class="texMathInline">n - 3 \in S</span></p>
            </li>
          </ol>
        </div>
        </p>
      </blockquote>
      <p>
        来看看如何用这一定义判断哪些自然数属于
        <span class="texMathInline">S</span>。已知 <span class="texMathInline">0 \in
          S</span>，因此 <span class="texMathInline">3 \in S</span>，
        因为 <span class="texMathInline">(3 - 3) = 0</span>，且 <span class="texMathInline">0
          \in S</span>。同样地，<span class="texMathInline">6 \in
          S</span>，因为 <span class="texMathInline">(6 - 3) = 3</span>，
        且 <span class="texMathInline">3 \in
          S</span>。依此类推，可得结论：所有
        <span class="texMathInline">3</span> 的整数倍都属于 <span
          class="texMathInline">S</span>。</p>
      <p>其他自然数呢？<span class="texMathInline">1 \in S</span>
        吗？已知 <span class="texMathInline">1 \ne
          0</span>，所以条件一不满足。此外，<span
          class="texMathInline">(1 -
          3) = -2</span>，不是自然数，故不是 <span
          class="texMathInline">S</span>
        的元素，因此条件二不满足。因为
        <span class="texMathInline">1</span> 不满足任
        一条件，所以 <span class="texMathInline">1 \notin
          S</span>。同样地，<span class="texMathInline">2 \notin S</span>。<span
          class="texMathInline">4</span>呢？仅当 <span class="texMathInline">1 \in S</span>
        时 <span class="texMathInline">4 \in S</span>。但 <span class="texMathInline">1 \notin
          S</span>，所以 <span class="texMathInline">4 \notin
          S</span>。同理可得，如果 <span class="texMathInline">n</span>
        是
        自然数且不是 <span class="texMathInline">3</span>
        的整数倍，则 <span class="texMathInline">n \notin S</span>。</p>
      <p>据此推论，可得 <span class="texMathInline">S</span> 是 <span
          class="texMathInline">3</span>
        的整数倍自然数集合。</p>
      <p>
        可以用该定义编写一个函数，判断一个自然数
        <span class="texMathInline">n</span> 是否属于 <span
          class="texMathInline">S</span>。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><a name="(idx._(gentag._11))"></a></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">in-S?</span></span> : <span
                  class="texMathInline">\mathit{N} \to \mathit{Bool}</span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold">用法</span> : <span class="stt">(in-S? n) = #t 若 n
                  属于 S，否则 #f</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">in-S?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">n</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">zero?</span><span class="hspace"> </span><span class="RktSym">n</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">#t</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktPn">(</span><span class="RktSym">if</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">>=</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span
                  class="hspace"> </span><span class="RktSym">n</span><span class="hspace"> </span><span
                  class="RktVal">3</span><span class="RktPn">)</span><span class="hspace"> </span><span
                  class="RktVal">0</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span
                  class="hspace">            </span><span
                  class="RktPn">(</span><span class="RktSym">in-S?</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span
                  class="hspace"> </span><span class="RktSym">n</span><span class="hspace"> </span><span
                  class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span
                  class="hspace">            </span><span
                  class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>
        这里根据定义，我们用Scheme编写了一个递归过程。符号
        <span class="RktSym">in-S?</span><span class="stt"> </span><span class="RktSym">:</span><span class="stt">
        </span><span class="texMathInline">\mathit{N} \to \mathit{Bool}</span>
        是一条注释，称为该函数
        <a name="(idx._(gentag._12))"></a>
        的<span class="emph">合约</span> (<span
          class="emph">contract</span>)。它表示 <span class="RktSym">in-S?</span>
        应为一过程，取一自然数，产生一
        布尔值。这样的注释对阅读和编写代码很有帮助。
      </p>
      <p>要判断是否 <span class="texMathInline">n \in
          S</span>，先判断是否 <span class="texMathInline">n =
          0</span>。如果是，那么答案为真。否则，判断是
        否 <span class="texMathInline">n - 3 \in
          S</span>。欲知此，首先判断是否 <span
          class="texMathInline">(n - 3) \geqslant
          0</span>。如果是，那么可
        以用我们的过程判断它是否属于
        <span class="texMathInline">S</span>。如果不是，那么 <span
          class="texMathInline">n</span> 不可能属于 <span
          class="texMathInline">S</span>。</p>
      <p><span class="texMathInline">S</span> 又能够定义为：</p>
      <blockquote class="EoplDefinition">
        <p><a name="(elem._d1..1..2)"></a><span class="hspace"> </span>集合 <span
            class="texMathInline">S</span> 为 <span class="texMathInline">N</span>
          所包含的集合中，满足如下两条性质的最小集合：<a
            name="(idx._(gentag._13))"></a></p>
        <ol>
          <li>
            <p><span class="texMathInline">0 \in S</span>，且</p>
          </li>
          <li>
            <p>若 <span class="texMathInline">n \in S</span>，则 <span class="texMathInline">n + 3 \in
                S</span>。</p>
          </li>
        </ol>
      </blockquote>
      <p>
        “最小集合”是指该集合满足性质
        1 和 2，并且是其他任何
        满足性质 1 和 2
        的集合的子集。易知只能有一个这样的集合：如果
        <span class="texMathInline">S_1</span> 和 <span class="texMathInline">S_2</span>
        都满足性质 1 和
        2，并且都为最小，那么 <span
          class="texMathInline">S_1 \subseteq S_2</span>（因为 <span class="texMathInline">S_1</span>
        最小）
        且 <span class="texMathInline">S_2 \subseteq S_1</span>（因为 <span
          class="texMathInline">S_2</span> 最小），因此 <span
          class="texMathInline">S_1 = S_2</span>。之所以需要这
        一额外条件，是因为否则的话将有许多集合满足其他两个条件（见<span
          class="EoplExerciseRef"></span>）。</p>
      <p>该定义还能表示为：</p>
      <p><span class="texMathDisplay">\infer{0 \in S}{}</span></p>
      <p><span class="texMathDisplay">\infer{(n + 3) \in S}{n \in S}</span></p>
      <p><a name="(idx._(gentag._14))"></a>
        这只是前一定义的简便表示。每个条目称为一条<span
          class="emph">推理规则</span> (<span class="emph">rule of inference</span>)，
        或称<span class="emph">规则</span> (<span
          class="emph">rule</span>)；水平线读作“若-则”。线上部分
        称作<span class="emph">假设</span> (<span
          class="emph">hypothesis</span>)或者<a name="(idx._(gentag._15))"></a><span
          class="emph">前件</span> (<span class="emph">antecedent</span>)；
        <a name="(idx._(gentag._16))"></a>
        <a name="(idx._(gentag._17))"></a>
        <a name="(idx._(gentag._18))"></a>
        线下部分称作<span class="emph">结论</span> (<span
          class="emph">conclusion</span>) 或者<span class="emph">后件</span> (<span
          class="emph">consequent</span>)。罗列两个或
        更多假设时，它们以隐含的“与”连接（见<span
          class="EoplDefinitionRef"></span>）。
        不含假设的规则称作<a name="(idx._(gentag._19))"></a><span
          class="emph">公理</span> (<span
          class="emph">axiom</span>)。写公理时通常不加水平
        线，如：
      </p>
      <p><span class="texMathDisplay">0 \in S</span></p>
      <p>该规则意为，自然数 <span class="texMathInline">n</span>
        属于 <span
          class="texMathInline">S</span>，当且仅当能用有限次推理规则，从公理推得陈述
        “<span class="texMathInline">n \in
          S</span>”。这一解释自然使 <span
          class="texMathInline">S</span> 成为闭合于该规则
        的最小集合。</p>
      <p><a name="(idx._(gentag._20))"></a>
        <a name="(idx._(gentag._21))"></a>
        这些定义意思相同。我们把版本一称作<span
          class="emph">自顶向下</span> (<span class="emph">top-down</span>)
        的定义，版本二
        称作<span class="emph">自底向上</span> (<span class="emph">bottom-up</span>)
        的定义，版本三称作<span
          class="emph">推理规则</span>定义。
        <a name="(idx._(gentag._22))"></a>
      </p>
      <p>再来看几个运用这些的例子。</p>
      <p>
      <div class="SIntrapara"><a name="(idx._(gentag._23))"></a>
      </div>
      <div class="SIntrapara">
        <blockquote class="EoplDefinition">
          <p>
          <div class="SIntrapara"><a name="(elem._d1..1..3)"></a><span
              class="EoplDefinitionTitle">整数列表，自顶向下</span>Scheme列表是整数列表，当且仅当：
          </div>
          <div class="SIntrapara">
            <ol>
              <li>
                <p>列表为空，或</p>
              </li>
              <li>
                <p>
                  列表为序对，首项为整数，余项为整数列表。
                </p>
              </li>
            </ol>
          </div>
          </p>
        </blockquote>
      </div>
      </p>
      <p>我们用 <span class="texMathInline">\mathit{Int}</span>
        表示所有整数的集合，用 <span
          class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>
        表示所有整数列表的集合。</p>
      <blockquote class="EoplDefinition">
        <p><a name="(elem._d1..1..4)"></a><span
            class="EoplDefinitionTitle">整数列表，自底向上</span>集合<span
            class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>是满足如下两条性质的最小Scheme列表集合：
        </p>
        <ol>
          <li>
            <p><span class="texMathInline">\textnormal{<span class="stt">()</span>} \in <span
                  class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span></span>，或</p>
          </li>
          <li>
            <p>若 <span class="texMathInline">n \in \mathit{Int}</span> 且 <span class="texMathInline">l \in
                <span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span></span>，则
              <span class="texMathInline">\textnormal{\texttt{(}}n\phantom{x}.\phantom{x}l\textnormal{\texttt{)}} \in
                <span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span></span>。
            </p>
          </li>
        </ol>
      </blockquote>
      <p><a name="(idx._(gentag._24))"></a>
        这里，我们用中缀“<span
          class="stt">.</span>”代表 Scheme 中 <span class="stt">cons</span> 操
        作的结果。式子 <span class="stt">(</span><span
          class="texMathInline">n</span><span class="stt"> . </span><span class="texMathInline">l</span><span
          class="stt">)</span> 代表 Scheme 序对的首项为 <span
          class="texMathInline">n</span>，余项为 <span class="texMathInline">l</span>。
      </p>
      <blockquote class="EoplDefinition">
        <p>
        <div class="SIntrapara"><a name="(elem._d1..1..5)"></a><span
            class="EoplDefinitionTitle">整数列表，推理规则</span>
        </div>
        <div class="SIntrapara">
          <blockquote class="NormalFont">
            <p><a name="(idx._(gentag._25))"></a>
              <span class="texMathDisplay">\infer{<span class="stt">()</span> \in <span
                  class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>}{}</span>
            </p>
            <p><span class="texMathDisplay">\infer{<span class="stt">(</span><span class="texMathInline">n</span><span
                  class="stt"> . </span><span class="texMathInline">l</span><span class="stt">)</span> \in <span
                  class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>}{n \in \mathit{Int} & l \in
                <span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>}</span></p>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._26))"></a></div>
        </p>
      </blockquote>
      <p>
        这三个定义等价。来看看如何用它们生成一些
        <span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span> 的元素。</p>
      <ol>
        <li>
          <p>由<span class="EoplDefinitionRef"></span> 的性质 1 或<span
              class="EoplDefinitionRef"></span> 的规则 1，
            <span class="stt">()</span> 是整数列表。
          </p>
        </li>
        <li>
          <p>由<span class="EoplDefinitionRef"></span> 的性质 2，<span class="stt">(14 .
              ())</span> 是整数列表。因为
            <span class="stt">14</span> 是整数，<span class="stt">()</span>
            是整数列表。写成 <span
              class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>
            规则二的形式，
            就是
          </p>
          <p><span class="texMathDisplay">\infer{<span class="stt">(14 . ())</span> \in <span
                class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>} {<span class="stt">14</span> \in
              \mathit{Int}
              & <span class="stt">()</span> \in <span
                class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>}</span></p>
        </li>
        <li>
          <p>由<span class="EoplDefinitionRef"></span> 的性质 2，<span class="stt">(3 .
              (14 . ()))</span> 是整数列表。因为
            <span class="stt">3</span> 是整数，<span class="stt">(14 . ())</span>
            是整数列表。仍写成<span
              class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span> 规则二的
            形式，是
          </p>
          <p><span class="texMathDisplay">\infer{<span class="stt">(3 . (14 . ()))</span> \in <span
                class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>} {<span class="stt">3</span> \in
              \mathit{Int} & <span class="stt">(14 . ())</span> \in <span
                class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>}</span></p>
        </li>
        <li>
          <p>由<span class="EoplDefinitionRef"></span> 的性质 2，<span class="stt">(-7 .
              (3 . (14 . ())))</span> 是整数列
            表。因为 <span class="stt">-7</span> 是整数，<span
              class="stt">(3 . (14 . ()))</span>
            是整数列表。再次写成
            <span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>
            规则二的形式，是
          </p>
          <p><span class="texMathDisplay">\infer{\hphantom{\texttt{x}}<span class="stt">(-7 . (3 . (14 . ())))</span>
              \in <span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>\hphantom{\texttt{x}}}
              {<span class="stt">-7</span> \in \mathit{Int} & <span class="stt">(3 . (14 . ()))</span>\in <span
                class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>}</span></p>
        </li>
        <li>
          <p>
            不按照这种方式得到的都不是整数列表。
          </p>
        </li>
      </ol>
      <p>
        改句点表示法为列表表示法，可知
        <span class="stt">()</span>、 <span class="stt">(14)</span>、 <span class="stt">(3 14)</span>
        以及 <span class="stt">(-7 3
          14)</span> 都是 <span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>
        的元素。</p>
      <p>还可以结合各条规则来证明 <span
          class="texMathInline"><span class="stt">(-7 . (3 . (14 . ())))</span> \in <span
            class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span></span>，
        以见出整个推理过程。下面的树状图叫做<a
          name="(elem._deriv-tree)"></a><span class="emph">推导</span> (<span
          class="emph">derivation</span>)
        或<span class="emph">推理树</span> (<span class="emph">deduction tree</span>)。
        <a name="(idx._(gentag._27))"></a>
        <a name="(idx._(gentag._28))"></a>
      </p>
      <p><span class="texMathDisplay">\infer{\hphantom{\texttt{xx}}<span class="stt">(-7 . (3 . (14 . ())))</span> \in
          <span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>\hphantom{\texttt{xx}}}
          {<span class="stt">-7</span> \in \mathit{Int} \hphantom{\texttt{x}} &
          \infer{\hphantom{\texttt{x}}<span class="stt">(3 . (14 . ()))</span> \in <span
            class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>\hphantom{\texttt{x}}}
          {<span class="stt">3</span> \in \mathit{Int} &
          \infer{<span class="stt">(14 . ())</span> \in <span
            class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>}
          {<span class="stt">14</span> \in \mathit{Int} & <span class="stt">()</span> \in <span
            class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>}}
          }</span>
        <a name="(idx._(gentag._29))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..1)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写出下列集合的归纳定义。以三种方式（自顶向下，自底向上，推理规则）写出每个定
          义，并用你的规则推导出各集合的一些元素。
        </p>
        <ol>
          <li>
            <p><span class="Iidentity">$\{ 3n + 2 \mid n \in N \}$</span></p>
          </li>
          <li>
            <p><span class="Iidentity">$\{ 2n + 3m + 1 \mid n, m \in N \}$</span></p>
          </li>
          <li>
            <p><span class="Iidentity">$\{ (n, 2n + 1) \mid n \in N \}$</span></p>
          </li>
          <li>
            <p><span class="Iidentity">$\{ (n, n^2) \mid n \in N
                \}$</span>。不要在你的规则中使用平方。提示：想一想
              方程 <span class="Iidentity">$ (n + 1) ^ 2 = n ^ 2 + 2n + 1$</span>。</p>
          </li>
        </ol>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..2)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>下面的几对规则分别定义了什么集合？给出解释。
        </p>
        <ol>
          <li>
            <p><span class="Iidentity">$(0, 1) \in S \qquad \infer{(n + 1, k + 7) \in S}{(n, k) \in S}$</span></p>
          </li>
          <li>
            <p><span class="Iidentity">$(0, 1) \in S \qquad \infer{(n + 1, 2k) \in S}{(n, k) \in S}$</span></p>
          </li>
          <li>
            <p><span class="Iidentity">$(0, 0, 1) \in S \qquad \infer{(n + 1, j, i + j) \in S}{(n, i, j) \in S}$</span>
            </p>
          </li>
          <li>
            <p><span class="Iidentity">$\text{[}\mathord{\star}\mathord{\star}\mathord{\star}\text{]}$</span>
              <span class="Iidentity">$\quad$</span> <span class="Iidentity">$(0, 1, 0) \in S \qquad \infer{(n + 1, i +
                2, i + j) \in S}{(n, i,
                j) \in S}$</span>
            </p>
          </li>
        </ol>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..3)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._30))"></a>
          找出自然数的子集 <span
            class="Iidentity">$T$</span>，满足 <span class="Iidentity">$0 \in
            T$</span>，且对任何 <span class="Iidentity">$n \in
            T$</span>，都有 <span class="Iidentity">$n + 3
            \in T$</span>，但 <span class="Iidentity">$T \neq S$</span>，<span
            class="Iidentity">$S$</span> 是由<span class="EoplDefinitionRef"></span>
          给出的集合。
          <a name="(idx._(gentag._31))"></a>
        </p>
      </blockquote>
      <h5>1.1.2<tt> </tt><a name="(part._s1..1..2)"></a>语法定义法</h5>
      <p><a name="(idx._(gentag._32))"></a>
        前述例子较为直观，但是不难想象，描述更复杂的数据类型会有多麻烦。为了方便，我们展
        示如何用<span class="emph">语法</span> (<span class="emph">grammar</span>)
        定义集合。语法通常用来指定字符串的集合，但也能用
        来定义值的集合。</p>
      <p><a name="(idx._(gentag._33))"></a>
        例如，集合 <span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>
        可用语法定义为：</p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*}\mathit{List\mbox{-}of\mbox{-}Int} &::= <span class="stt">()</span>
            \\[-3pt]
            \mathit{List\mbox{-}of\mbox{-}Int} &::= <span class="stt">(</span><span
              class="Iidentity">\mathit{Int}</span><span class="stt"> . </span><span
              class="Iidentity">\mathit{List\mbox{-}of\mbox{-}Int}</span><span class="stt">)</span>\end{align*}</span>
        </p>
      </blockquote>
      <p>这两条规则对应上述<span class="EoplDefinitionRef"></span>
        中的两条性质。规则一是说空表属于
        <span
          class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>；规则二是说，若
        <span class="texMathInline">n</span> 属于 <span class="texMathInline">\mathit{Int}</span> 且
        <span class="texMathInline">l</span> 属于
        <span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>，则 <span
          class="stt">(</span><span class="texMathInline">n</span><span class="stt"> . </span><span
          class="texMathInline">l</span><span class="stt">)</span> 属于 <span
          class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>。这些规则
        叫做<span class="emph">语法</span>。
      </p>
      <p>
        来看看该定义的各个部分，其中有：
      </p>
      <ul>
        <li>
          <p><span
              style="font-weight: bold">非终结符</span>。这些是所定义的集合名。本例中只定义了一个集合，但是通常，
            可能会定义数个集合。这些集合有时称为<span
              class="emph">句法类别</span> (<span class="emph">syntactic
              category</span>)。
            <a name="(idx._(gentag._34))"></a>
            <a name="(idx._(gentag._35))"></a>
          </p>
          <p>
            依照惯例，我们将非终结符和集合名的首字母大写，在文中提及它们的元素时，则
            用小写。这要比听起来容易。例如，
            <span class="texMathInline">\mathit{Expression}</span>
            是非终结符，但
            我们写作 <span class="texMathInline">e \in \mathit{Expression}</span> 或
            “<span class="texMathInline">e</span> 是一个
            expression”。</p>
          <p>另一常见写法，名叫<span
              class="emph">巴科斯-诺尔范
              式</span> (<span class="emph">Backus-Naur Form</span>)<a name="(idx._(gentag._36))"></a>
            或<span class="emph">BNF</span>，是在词周围加
            尖括号，如<span class="texMathInline">\langle</span>expression<span
              class="texMathInline">\rangle</span>。</p>
        </li>
        <li>
          <p><span
              style="font-weight: bold">终结符</span>。这些是集合外在表示中的字符，在本例中，是
            “<span class="stt">.</span>”、
            “<span class="stt">(</span>”和
            “<span
              class="stt">)</span>”。这些常用打字机字体写出，如
            <span class="stt">lambda</span>。<a name="(idx._(gentag._37))"></a>
          </p>
        </li>
        <li>
          <p><span
              style="font-weight: bold">生成式</span>。规则叫做<span
              class="emph">生成式</span> (<span class="emph">production</span>)。
            <a
              name="(idx._(gentag._38))"></a>每个生成式的左边是一个非终结符，右边
            包含终结符和非终结符。左右两边通常用符号
            <span class="texMathInline">::=</span>分隔，读作<span
              class="emph">是</span>
            或<span
              class="emph">可以是</span>。式子右边用其他句法类别和<span
              class="emph">终结符</span>（如左括号、
            右括号和句点）指定一种方法，用以构建当前句法类别的元素。
          </p>
        </li>
      </ul>
      <p>
        如果某些句法类别的含义在上下文中足够清晰，在生成式中提到它们时通常不作定义，如
        <span class="texMathInline">\mathit{Int}</span>。
      </p>
      <p>
        语法常常简写。当一个生成式的左边与前一生成式相同时，一般会略去。根据这一惯例，我
        们的语法可以写作</p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*}\mathit{List\mbox{-}of\mbox{-}Int} &::= <span class="stt">()</span>
            \\[-3pt]
            &::= <span class="stt">(</span><span class="Iidentity">\mathit{Int}</span><span class="stt"> .
            </span><span class="Iidentity">\mathit{List\mbox{-}of\mbox{-}Int}</span><span
              class="stt">)</span>\end{align*}</span></p>
      </blockquote>
      <p>
        给同一句法类别编写一组规则时，也可以只写一次
        <span class="texMathInline">::=</span>
        和左边内容，随后的各个右边
        内容用特殊符号“<span
          class="texMathInline">\mid</span>”（竖线，读作<span
          class="emph">或</span><a name="(idx._(gentag._39))"></a>）
        分隔。用“<span class="texMathInline">\mid</span>”，<span
          class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>
        的语法可写成：</p>
      <p><span class="texMathDisplay"><span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span> ::= <span
            class="stt">()</span> <span class="texMathDisplay">\mid</span> <span class="stt">(</span><span
            class="texMathInline">\mathit{Int}</span><span class="stt"> . </span><span
            class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span><span class="stt">)</span></span>
        <a name="(idx._(gentag._40))"></a>
      </p>
      <p><a name="(idx._(gentag._41))"></a>
        另一种简写是<a name="(elem._kleene-star)"></a><span
          class="emph">克莱尼星号</span> (<span class="emph">Kleene
          Star</span>)，写作
        <span
          class="texMathInline">\{...\}^*</span>。当它出现在右边时，表示一个序列，由任意多个花括号之间的内容组成。
        用克莱尼星号，<span
          class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span>
        的定义可以简写为
      </p>
      <p><span class="texMathDisplay"><span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Int}</span> ::= <span
            class="stt">(</span><span class="texMathInline">\{\mathit{Int}\}^*</span><span class="stt">)</span></span>
      </p>
      <p>
        这也包含没有任何内容的情况。如果内容出现
        0 次，得到的是空字符串。</p>
      <p><a name="(idx._(gentag._42))"></a>
        星号的变体是<span
          class="emph">克莱尼加号</span> (<span class="emph">Kleene Plus</span>) <span
          class="texMathInline">\{...\}^+</span>，表示一个或多个内容的
        序列。把上例中的 <span class="texMathInline">^*</span>
        换成 <span
          class="texMathInline">^+</span>，定义的句法类别是非空整数列表。
      </p>
      <p><a name="(idx._(gentag._43))"></a>
        星号的另一变体是<span
          class="emph">分隔表</span> (<span class="emph">separated list</span>)
        表示法。例如，
        <span class="texMathInline">\mathit{Int}^{*(c)}</span>
        表示一个序列，包含任意数量的非终结符
        <span class="texMathInline">\mathit{Int}</span> 元素，以非
        空字符序列 <span class="texMathInline">c</span>
        分隔。这也包含没有元素的情况。如果有
        0 个元素，得到的是空字符串。
        例如，<span class="texMathInline">\mathit{Int}^{*(,)}</span>
        包含字符串
      </p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">8</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">14, 12</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">7, 3, 14, 16</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p><span class="texMathInline">\mathit{Int}^{*(;)}</span> 包含字符串</p>
        <blockquote class="EoplCodeInset">
          <p>
          <div class="SIntrapara">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">8</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">14; 12</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">7; 3; 14; 16</span></p>
                </td>
              </tr>
            </table>
          </div>
          <div class="SIntrapara"><a name="(idx._(gentag._44))"></a></div>
          </p>
        </blockquote>
      </blockquote>
      <p>
        这些简写不是必需的，总能够不用它们重写语法。
      </p>
      <p><a name="(idx._(gentag._45))"></a>
        <a name="(idx._(gentag._46))"></a>
        对由语法定义的集合，可以用<span
          class="emph">句法推导</span> (<span class="emph">syntactic derivation</span>)
        证明给定值是其
        元素。这样的推导从集合对应的非终结符开始，在由箭头<span
          class="texMathInline">\Rightarrow</span> 指示的每一步中，
        如果非终结符对应的句法类别未做定义，则将其代换为该类别的已知元素，否则代换为对应
        规则右边的内容。例如，前述证明“<span
          class="stt">(14 . ())</span> 是整数列表
        ”，可以用句法推导化为
      </p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*}\mathit{List\mbox{-}of\mbox{-}Int} &\Rightarrow <span
              class="stt">(</span><span class="Iidentity">\mathit{Int}</span><span class="stt"> . </span><span
              class="Iidentity">\mathit{List\mbox{-}of\mbox{-}Int}</span><span class="stt">)</span> \\[-3pt]
            &\Rightarrow <span class="stt">(14 . </span><span
              class="Iidentity">\mathit{List\mbox{-}of\mbox{-}Int}</span><span class="stt">)</span> \\[-3pt]
            &\Rightarrow <span class="stt">(14 . ())</span>\end{align*}</span></p>
      </blockquote>
      <p>
        非终结符的替换顺序无关紧要，所以
        <span class="stt">(14 . ())</span> 的推导也可以写成：</p>
      <blockquote class="Small">
        <p><span class="Iidentity">\begin{align*}\mathit{List\mbox{-}of\mbox{-}Int} &\Rightarrow <span
              class="stt">(</span><span class="Iidentity">\mathit{Int}</span><span class="stt"> . </span><span
              class="Iidentity">\mathit{List\mbox{-}of\mbox{-}Int}</span><span class="stt">)</span> \\[-3pt]
            &\Rightarrow <span class="stt">(</span><span class="Iidentity">\mathit{Int}</span><span class="stt"> .
              ())</span> \\[-3pt]
            &\Rightarrow <span class="stt">(14 . ())</span>\end{align*}</span></p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..4)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写出从 <span
            class="Iidentity">$\mathit{List\mbox{-}of\mbox{-}Int}$</span> 到 <span class="stt">(-7 . (3 . (14
            ())))</span> 的推导。<br /></p>
      </blockquote>
      <p>再来看一些有用集合的定义。</p>
      <ol>
        <li>
          <p><a name="(idx._(gentag._47))"></a>
            <a name="(idx._(gentag._48))"></a>
            许多符号操作过程用于处理只包含符号和具有类似限制的列表。我们把这些叫做
            <span class="stt">s-list</span>，定义如下：
          </p>
          <blockquote class="EoplDefinition">
            <p>
            <div class="SIntrapara"><a name="(elem._d1..1..6)"></a><span
                class="EoplDefinitionTitle">s-list，s-exp</span></div>
            <div class="SIntrapara">
              <blockquote class="NormalFont">
                <blockquote class="Small">
                  <p><span class="Iidentity">\begin{align*}\mathit{S\mbox{-}list} &::= <span
                        class="stt">(</span><span class="Iidentity">\{\mathit{S\mbox{-}exp}\}^*</span><span
                        class="stt">)</span> \\[-3pt]
                      \mathit{S\mbox{-}exp} &::= \mathit{Symbol} \mid \mathit{S\mbox{-}list}\end{align*}</span></p>
                </blockquote>
              </blockquote>
            </div>
            </p>
          </blockquote>
          <p><a name="(elem._s-list)"></a>s-list 是 s-exp 的列表，s-exp
            或者是 s-list，或者是一个符号。
            这里是一些 s-list。</p>
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">(a b c)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">(an (((s-list)) (with () lots) ((of) nesting)))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
          <p>有时也使用更宽松的 s-list
            定义，既允许整数，也允许符号。
            <a name="(idx._(gentag._49))"></a>
            <a name="(idx._(gentag._50))"></a>
          </p>
        </li>
        <li>
          <p>
            使用三元素列表表示内部节点，则以数值为叶子，以符号标示内部节点的二叉树可
            用语法表示为：
            <a name="(idx._(gentag._51))"></a>
          </p>
          <blockquote class="EoplDefinition">
            <p>
            <div class="SIntrapara"><a name="(elem._d1..1..7)"></a><span
                class="EoplDefinitionTitle">二叉树</span></div>
            <div class="SIntrapara">
              <blockquote class="NormalFont">
                <blockquote class="Small">
                  <p><span class="texMathDisplay">\mathit{Bintree} ::= \mathit{Int} \mid <span class="stt">(</span><span
                        class="texMathInline">\mathit{Symbol}</span><span class="stt"> </span><span
                        class="texMathInline">\mathit{Bintree}</span><span class="stt"> </span><span
                        class="texMathInline">\mathit{Bintree}</span><span class="stt">)</span></span></p>
                </blockquote>
              </blockquote>
            </div>
            </p>
          </blockquote>
          <p>这是此类树的几个例子：</p>
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">2</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">(foo 1 2)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">(bar 1 (foo 1 2))</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">(baz</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(bar 1 (foo 1
                      2))</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">(biz 4 5))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </li>
        <li>
          <p><span class="emph">lambda 演算</span> (<span class="emph">lambda calculus</span>)
            是一种简单语言，常用于研究编程语言
            理论。这一语言只包含变量引用，单参数过程，以及过程调用，可用语法定义为：
            <a name="(idx._(gentag._52))"></a>
          </p>
          <blockquote class="EoplDefinition">
            <p>
            <div class="SIntrapara"><a name="(elem._d1..1..8)"></a><span class="EoplDefinitionTitle">lambda
                演算</span><a name="(idx._(gentag._53))"></a>
            </div>
            <div class="SIntrapara">
              <blockquote class="NormalFont">
                <blockquote class="Small">
                  <p><span class="Iidentity">\begin{align*}\mathit{LcExp} &::= \mathit{Identifier} \\[-3pt]
                      &::= <span class="stt">(lambda (</span><span class="Iidentity">\mathit{Identifier}</span><span
                        class="stt">) </span><span class="Iidentity">\mathit{LcExp}</span><span class="stt">)</span>
                      \\[-3pt]
                      &::= <span class="stt">(</span><span class="Iidentity">\mathit{LcExp}</span><span class="stt">
                      </span><span class="Iidentity">\mathit{LcExp}</span><span class="stt">)</span>\end{align*}</span>
                  </p>
                </blockquote>
              </blockquote>
            </div>
            </p>
            <p>其中，identifier 是除 <span class="NormalFont"><span
                  class="stt">lambda</span></span> 之外的任何符号。</p>
          </blockquote>
          <p><a name="(idx._(gentag._54))"></a>
            <a name="(idx._(gentag._55))"></a>
            <a name="(idx._(gentag._56))"></a>
            第二个生成式中的 identifier 是 <span
              class="stt">lambda</span>
            表达式主体内的变量名。这一变量叫做表
            达式的<span class="emph">绑定变量</span> (<span class="emph">bound
              variable</span>)，因为它绑定（或称捕获）主体内出现的任何
            同名变量。出现在主体内的同名变量都指代这一个。
            <a name="(idx._(gentag._57))"></a>
          </p>
          <p>
            要明白这怎么用，考虑用算术操作符扩展的
            lambda 演算。在这种语言里，</p>
          <blockquote class="EoplCodeInset">
            <blockquote class="SCodeFlow">
              <table cellspacing="0" cellpadding="0" class="RktBlk">
                <tr>
                  <td><span class="RktPn">(</span><span class="RktSym">lambda</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                      class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                      class="RktSym">+</span><span class="RktMeta"></span><span class="hspace"> </span><span
                      class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span class="RktVal">5</span><span
                      class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
                </tr>
              </table>
            </blockquote>
          </blockquote>
          <p>是一表达式，<span class="stt">x</span>
            是其绑定变量。这式子表示一个过程，把它的参数加5。因此，在
          </p>
          <blockquote class="EoplCodeInset">
            <blockquote class="SCodeFlow">
              <table cellspacing="0" cellpadding="0" class="RktBlk">
                <tr>
                  <td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">x</span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktSym">x</span><span class="RktMeta"></span><span class="hspace"> </span><span
                      class="RktMeta"></span><span class="RktVal">7</span><span class="RktPn">)</span><span
                      class="RktPn">)</span><span class="RktMeta"></span></td>
                </tr>
              </table>
            </blockquote>
          </blockquote>
          <p>中，最后一个出现的 <span class="stt">x</span>
            不是指 <span class="stt">lambda</span>
            表达式中绑定的 <span class="stt">x</span>。
            <a href="#%28part._s1..2..4%29" data-pltdoc="x"><span
                class="stt">occurs-free?</span></a>中介绍了 <span
              class="stt">occurs-free?</span>，到时我们再讨论这个问题。
          </p>
          <p>该语法定义 <span class="texMathInline">\mathit{LcExp}</span>
            的元素为 Scheme
            值，因此很容易写出程序来处理它们。
          </p>
        </li>
      </ol>
      <p><a name="(idx._(gentag._58))"></a>
        这些语法叫做<span
          class="emph">上下文无关</span> (<span class="emph">context-free</span>)
        语法，因为一条规则定义的句法类别可
        以在任何引用它的上下文中使用。有时这不够严格。考虑<a
          name="(elem._bst)"></a>二叉搜索树。
        其节点或者为空，或者包含一个整数和两棵子树
        <a name="(idx._(gentag._59))"></a>
        <span class="texMathDisplay">\mathit{Binary\mbox{-}search\mbox{-}tree} ::= <span class="stt">()</span> \mid
          <span class="stt">(</span><span class="texMathInline">\mathit{Int}</span><span class="stt"> </span><span
            class="texMathInline">\mathit{Binary\mbox{-}search\mbox{-}tree}</span><span class="stt"> </span><span
            class="texMathInline">\mathit{Binary\mbox{-}search\mbox{-}tree}</span><span class="stt">)</span></span>
      </p>
      <p>
        这如实反映了每个节点的结构，但是忽略了二叉搜索树的一个要点：所有左子树的键值都小
        于（或等于）当前节点，所有右子树的键值都大于当前节点。
      </p>
      <p><a name="(idx._(gentag._60))"></a>
        因为这条额外限制，从 <span
          class="texMathInline">\mathit{Binary\mbox{-}search\mbox{-}tree}</span>
        得出的句法推
        导并不都是正确的二叉搜索树。要判定某个生成式能否用于特定的句法推导，必须检查生成
        式用在哪种上下文。这种限制叫做<span
          class="emph">上下文敏感
          限制</span> (<span class="emph">context-sensitive constraints</span>)，或称<a
          name="(elem._invariant)"></a><span class="emph">不变式</span> (<span
          class="emph">invariants</span>)。
        <a name="(idx._(gentag._61))"></a>
      </p>
      <p>
        定义编程语言的语法也会产生上下文敏感限制。例如，在许多编程语言中变量必须在使用之
        前声明。对变量使用的这一限制就对其上下文敏感。虽然可以用形式化方法定义上下文敏感
        限制，但这些方法远比本章考虑的复杂。实际中，常用的方法是先定义上下文无关语法，随
        后再用其他方法添加上下文敏感限制。<a
          href="types.html"
          data-pltdoc="x">类型</a>展示了这种技巧的一个例子。
        <a name="(idx._(gentag._62))"></a>
        <a name="(idx._(gentag._63))"></a>
        <a name="(idx._(gentag._64))"></a>
        <a name="(idx._(gentag._65))"></a>
      </p>
      <h5>1.1.3<tt> </tt><a name="(part._s1..1..3)"></a>归纳证明法</h5>
      <p><a name="(idx._(gentag._66))"></a>
        用归纳法描述的集合，其定义有两种用法：证明关于集合元素的定理，写出操作集合元素的
        程序。这里给出一个此类证明的例子，写程序留作下节的主题。
      </p>
      <blockquote class="EoplTheorem">
        <p><a name="(elem._t1..1..1)"></a><span class="hspace"> </span><a name="(idx._(gentag._67))"></a>
          令 t 为二叉树，形如<span
            class="EoplDefinitionRef"></span>，则 t
          包含奇数个节点。</p>
      </blockquote>
      <blockquote class="EoplProof">
        <p><a name="(idx._(gentag._68))"></a>
          <a name="(idx._(gentag._69))"></a>
          用归纳法证明 <span class="texMathInline">t</span>
          的大小。令 <span class="texMathInline">t</span>
          的大小等于 <span class="texMathInline">t</span>
          中节点的个数。归纳假设为
          <span class="texMathInline">\mathit{IH}(k)</span>：树的大小<span
            class="texMathInline">\leq
            k</span>时有奇数个节点。依照归纳法的惯例：先证明
          <span
            class="texMathInline">\mathit{IH}(0)</span>为真，然后证明若对任一整数
          <span class="texMathInline">k</span>，<span class="texMathInline">\mathit{IH}</span>
          为真，则对
          <span class="texMathInline">k + 1</span>，<span class="texMathInline">\mathit{IH}</span>
          也为真。
        </p>
        <ol>
          <li>
            <p>没有哪棵树只有 <span class="texMathInline">0</span>
              个节点，所以 <span class="texMathInline">\mathit{IH}(0)</span>
              显然成立。</p>
          </li>
          <li>
            <p>设 <span class="texMathInline">k</span> 为整数时，<span
                class="texMathInline">\mathit{IH}(k)</span>
              成立，即，任何树的节点数 <span
                class="texMathInline">\leq
                k</span>
              时，其实际数目为奇数。需证明
              <span class="texMathInline">\mathit{IH}(k + 1)</span>
              也成立：任何树的节点数
              <span class="texMathInline">\leq k + 1</span>
              时，节点数为奇数。若 <span
                class="texMathInline">t</span> 有 <span class="texMathInline">\leq k + 1</span>
              个节点，根据二叉树
              的定义，只有两种可能：
            </p>
            <ol>
              <li>
                <p><span class="texMathInline">t</span> 形如 <span
                    class="texMathInline">n</span>，<span class="texMathInline">n</span>
                  为整数。此时 <span class="texMathInline">t</span>
                  只有一个节点，1为奇数。</p>
              </li>
              <li>
                <p><span class="texMathInline">t</span> 形如 <span class="texMathInline"><span
                      class="stt">(</span><span class="texMathInline">sym</span><span class="stt"> </span><span
                      class="texMathInline">t_1</span><span class="stt"> </span><span
                      class="texMathInline">t_2</span><span
                      class="stt">)</span></span>，其中，<span class="texMathInline">sym</span>
                  是一符号，
                  <span class="texMathInline">t_1</span> 和 <span class="texMathInline">t_2</span>
                  是树。此时 <span class="texMathInline">t_1</span> 和 <span
                    class="texMathInline">t_2</span> 节点数少于 <span
                    class="texMathInline">t</span>。因为 <span class="texMathInline">t</span>
                  有 <span class="texMathInline">\leq k + 1</span>个节点，<span
                    class="texMathInline">t_1</span> 和 <span class="texMathInline">t_2</span>
                  一定有 <span class="texMathInline">\leq k</span>
                  个节点。因此它
                  们符合 <span
                    class="texMathInline">\mathit{IH}(k)</span>，一定各有奇数个节点，不妨分别设为<span
                    class="texMathInline">2n_1 + 1</span> 和
                  <span class="texMathInline">2n_2 +
                    1</span>。则算上两棵子树和根，原树中的节点总数为
                </p>
                <p><span class="texMathDisplay">(2n_1 + 1) + (2n_2 + 1) + 1 = 2(n_1 + n_2 + 1) + 1</span></p>
                <p>也是一个奇数。</p>
              </li>
            </ol>
          </li>
        </ol>
        <p>陈述“<span class="texMathInline">\mathit{IH}(k + 1)</span>
          成立”证毕，归纳完成。
          <a name="(idx._(gentag._70))"></a>
        </p>
      </blockquote>
      <p>证明的关键是树 <span class="texMathInline">t</span>
        的子结构总是比 <span class="texMathInline">t</span>
        自身小。这种证明模式
        叫做<span class="emph">结构化归纳法</span> (<span
          class="emph">structural induction</span>)。</p>
      <blockquote class="Tip">
        <blockquote class="SCentered">
          <p><span style="font-weight: bold">结构化归纳证明</span></p>
        </blockquote>
        <p class="TipContent">欲证明假设 <span class="texMathInline">\mathit{IH}(s)</span>
          对所有结构 <span class="texMathInline">s</span> 为真，
          需证明：</p>
        <ol>
          <li>
            <p><span class="texMathInline">\mathit{IH}</span>
              对简单结构（没有子结构）为真。
            </p>
          </li>
          <li>
            <p>若 <span class="texMathInline">\mathit{IH}</span> 对 <span class="texMathInline">s</span>
              的子结构为真，则对 <span
                class="texMathInline">s</span> 本身也为真。
              <a name="(idx._(gentag._71))"></a>
            </p>
          </li>
        </ol>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..5)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._72))"></a>
          证明：若 <span class="Iidentity">$e \in \mathit{LcExp}$</span>，则 <span
            class="Iidentity">$e$</span>
          中的左右括号数量相等。</p>
      </blockquote>
      <h4>1.2<tt> </tt><a name="(part._s1..2)"></a>推导递归程序</h4>
      <p><a name="(idx._(gentag._73))"></a>
        <a name="(idx._(gentag._74))"></a>
        <a name="(idx._(gentag._75))"></a>
        <a name="(idx._(gentag._76))"></a>
        <a name="(idx._(gentag._77))"></a>
        我们已经用归纳定义法描述了复杂集合。我们能够分析归纳式集合的元素，观察如何从较小
        元素构建集合。我们用这一想法写出了过程
        <span
          class="stt">in-S?</span>，用以判断自然数是否属于集合
        <span
          class="texMathInline">S</span>。现在，我们用同样的想法定义更通用的过程，以便对归纳式集合做运算。
      </p>
      <p><a name="(idx._(gentag._78))"></a>
        递归过程依赖于一条重要原则：
      </p>
      <blockquote class="Tip">
        <blockquote class="SCentered">
          <p><span style="font-weight: bold">较小子问题原则</span></p>
        </blockquote>
        <p class="TipContent">
          若能化问题为较小子问题，则能调用解决原问题的过程解决
          子问题。</p>
      </blockquote>
      <p>
        已求得的子问题解随后可用来求解原问题。这可行，因为每次过程调用都是针对较小的子问
        题，直至最终调用，针对一个可以直接求解的问题，不需再次调用自身。
        <a name="(idx._(gentag._79))"></a>
        <a name="(idx._(gentag._80))"></a>
        <a name="(idx._(gentag._81))"></a>
      </p>
      <p>
        我们用一些例子解释这一想法。
      </p>
      <h5>1.2.1<tt> </tt><a name="(part._s1..2..1)"></a><span class="stt">list-length</span></h5>
      <p><a name="(idx._(gentag._82))"></a>
        <a name="(idx._(gentag._83))"></a>
        标准的 Scheme 程序 <span class="stt">length</span>
        求出列表中的元素个数。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">length</span><span
                  class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                  class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">b</span><span
                  class="hspace"> </span><span class="RktVal">c</span><span class="RktVal">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">3</span></p>
              </td>
            </tr>
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">length</span><span
                  class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                  class="RktVal">(</span><span class="RktVal">x</span><span class="RktVal">)</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">2</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>我们来写出自己的过程 <span
          class="stt">list-length</span>，做同样的事。</p>
      <p><a name="(idx._(gentag._84))"></a>
        先来写出过程的<span
          class="emph">合约</span>。合约指定了过程可取参数和可能返回值的集合。合约也
        可以包含过程的期望用法或行为。这有助于我们在编写时及以后追踪我们的意图。在代码中，
        这是一条注释，我们用打字机字体示之，以便阅读。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">list-length</span></span> : <span
                  class="texMathInline">\mathit{List} \to \mathit{Int}</span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold">用法</span> : <span class="stt">(list-length </span><span
                  class="texMathInline">l</span><span class="stt">) = </span><span class="texMathInline">l</span><span
                  class="stt">的长度</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">list-length</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">lst</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktSym">...</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>列表的集合定义为</p>
      <p><span class="texMathDisplay">\mathit{List} ::= <span class="stt">()</span> \mid <span class="stt">(</span><span
            class="texMathInline">Scheme \; value</span><span class="stt">
          </span><span class="stt">. </span><span class="texMathInline">\mathit{List}</span><span
            class="stt">)</span></span></p>
      <p>
        因此，考虑列表的每种情况。若列表为空，则长度为0。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">list-length</span></span> : <span
                  class="texMathInline">\mathit{List} \to \mathit{Int}</span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold">用法</span> : <span class="stt">(list-length </span><span
                  class="texMathInline">l</span><span class="stt">) = </span><span class="texMathInline">l</span><span
                  class="stt"> 的长度</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">list-length</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">lst</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>\begin{mdframed}[style=codediff]</td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">lst</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktVal">0</span></td>
            </tr>
            <tr>
              <td>\end{mdframed}</td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>
        若列表非空，则其长度比其余项长度多1。这就给出了完整定义。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">list-length</span></span> : <span
                  class="texMathInline">\mathit{List} \to \mathit{Int}</span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold">用法</span> : <span class="stt">(list-length </span><span
                  class="texMathInline">l</span><span class="stt">) = </span><span class="texMathInline">l</span><span
                  class="stt"> 的长度</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">list-length</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">lst</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">lst</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktVal">0</span></td>
            </tr>
            <tr>
              <td>\begin{mdframed}[style=codediff]</td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktPn">(</span><span class="RktSym">+</span><span class="hspace"> </span><span
                  class="RktVal">1</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">list-length</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">lst</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>\end{mdframed}</td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>通过 <span class="stt">list-length</span>
        的定义，我们可以看到它的运算过程。
      </p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">(list-length '(a
                    (b c) d))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">= (+ 1 (list-length '((b c) d)))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">= (+ 1 (+ 1 (list-length '(d))))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">= (+ 1 (+ 1 (+ 1 (list-length '()))))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">= (+ 1 (+ 1 (+ 1 0)))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">= 3</span></p>
              </td>
            </tr>
          </table>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._85))"></a></div>
        </p>
      </blockquote>
      <h5>1.2.2<tt> </tt><a name="(part._s1..2..2)"></a><span class="stt">nth-element</span></h5>
      <p><a name="(idx._(gentag._86))"></a>
        标准的 Scheme 过程 <span class="stt">list-ref</span>
        取一列表 <span class="stt">lst</span> 和从 0
        开始计数的索引 <span class="stt">n</span>，
        返回 <span class="stt">lst</span> 的第 <span class="stt">n</span>
        个元素。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">list-ref</span><span
                  class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                  class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">b</span><span
                  class="hspace"> </span><span class="RktVal">c</span><span class="RktVal">)</span><span
                  class="hspace"> </span><span class="RktVal">1</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">'b</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>我们来写出自己的过程 <span
          class="stt">nth-element</span>，做同样的事。</p>
      <p>仍沿用上述 <span class="texMathInline">List</span>
        的定义。</p>
      <p>当 <span class="texMathInline">lst</span> 为空时，<span class="stt">(nth-element
        </span><span class="texMathInline">lst</span><span class="stt"> </span><span class="texMathInline">n</span><span
          class="stt">)</span>
        应当返回什么？这种情况下，
        <span class="stt">(nth-element </span><span class="texMathInline">lst</span><span class="stt"> </span><span
          class="texMathInline">n</span><span class="stt">)</span>
        想要取空列表的元素，所以报错。
      </p>
      <p>当 <span class="texMathInline">lst</span> 非空时，<span class="stt">(nth-element
        </span><span class="texMathInline">lst</span><span class="stt"> </span><span class="texMathInline">n</span><span
          class="stt">)</span>
        应当返回什么？答案取决于
        <span class="texMathInline">n</span>。若 <span class="texMathInline">n =
          0</span>，答案是 <span class="texMathInline">lst</span>
        的首项。
      </p>
      <p>当 <span class="texMathInline">lst</span> 非空，且 <span class="texMathInline">n
          \neq 0</span> 时，<span class="stt">(nth-element </span><span
          class="texMathInline">lst</span><span class="stt"> </span><span class="texMathInline">n</span><span
          class="stt">)</span> 应当返回什
        么？这种情况下，答案是 <span
          class="texMathInline">lst</span> 余项的第 <span class="texMathInline">(n - 1)</span>
        个元素。由 <span class="texMathInline">n \in N</span> 且
        <span class="texMathInline">n \neq 0</span>，可知 <span class="texMathInline">n - 1</span>
        一定属于 <span
          class="texMathInline">N</span>，因此可以递归调用 <span
          class="stt">nth-element</span>找
        出第 <span class="texMathInline">(n - 1)</span> 个元素。
      </p>
      <p>这就得出定义</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">nth-element</span></span> : <span
                  class="texMathInline">\mathit{List} \times \mathit{Int} \to \mathit{SchemeVal}</span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold">用法</span> : <span class="stt">(nth-element </span><span
                  class="texMathInline">lst</span><span class="stt"> </span><span class="texMathInline">n</span><span
                  class="stt">) = </span><span class="texMathInline">lst</span><span class="stt"> 的第
                </span><span class="texMathInline">n</span><span class="stt"> 个元素</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">nth-element</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">lst</span><span class="hspace"> </span><span class="RktSym">n</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">lst</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">report-list-too-short</span><span class="hspace"> </span><span
                  class="RktSym">n</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">zero?</span><span class="hspace"> </span><span class="RktSym">n</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                  class="RktSym">lst</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktPn">(</span><span class="RktSym">nth-element</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace"> </span><span
                  class="RktSym">lst</span><span class="RktPn">)</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span
                  class="hspace"> </span><span class="RktSym">n</span><span class="hspace"> </span><span
                  class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">report-list-too-short</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">n</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">eopl:error</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">nth-element</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktVal">"List too short
                  by ~s elements.~%"</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">+</span><span class="hspace"> </span><span class="RktSym">n</span><span
                  class="hspace"> </span><span class="RktVal">1</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>这里的注释 <span style="font-weight: bold"><span
            class="stt">nth-element</span></span><span class="stt"> : </span><span class="texMathInline">\mathit{List}
          \times \mathit{Int}
          \to \mathit{SchemeVal}</span> 表示 <span style="font-weight: bold"><span
            class="stt">nth-element</span></span>
        是一个过程，取两个参数，一
        个为列表，一个为整数，返回一个Scheme
        值。这与数学中的表示 <span class="texMathInline">f :
          A \times B \to
          C</span> 相同。</p>
      <p><a name="(idx._(gentag._87))"></a>
        <a name="(idx._(gentag._88))"></a>
        <a name="(idx._(gentag._89))"></a>
        过程 <span class="stt">report-list-too-short</span> 调用 <span
          class="stt">eopl:error</span>
        来报告错误，后者会终止计算。
        它的首个参数是一符号，用于在错误信息中指示调用
        <span class="stt">eopl:error</span> 的过程。第二个参
        数是一个字符串，会打印为错误信息。对应于字符串中的每个字符序列
        <span class="stt">~s</span>，都必须有
        一个额外参数。打印字符串时，这些参数的值会替换对应的
        <span class="stt">~s</span> 。<span class="stt">~%</span>代表换行。
        错误信息打印后，计算终结。过程
        <span class="stt">eopl:error</span> 并非标准 Scheme
        的一部分，但大多
        数 Scheme
        实现提供这样的组件。在本书中，我们以类似方式，用名字含
        <span class="stt">report-</span> 的
        过程报告错误。
        <a name="(idx._(gentag._90))"></a>
        <a name="(idx._(gentag._91))"></a>
      </p>
      <p>来看看 <span class="stt">nth-element</span>
        如何算出答案：</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">(nth-element '(a b
                    c d e) 3)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">= (nth-element</span><span class="hspace">   </span><span
                    class="stt">'(b c d e) 2)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">= (nth-element</span><span
                    class="hspace">     </span><span class="stt">'(c d e) 1)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">= (nth-element</span><span
                    class="hspace">       </span><span class="stt">'(d e) 0)</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">= d</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>这里，<span class="stt">nth-element</span>
          递归处理越来越短的列表和越来越小的数字。
        </p>
      </blockquote>
      <p>如果排除错误检查，我们得靠 <span
          class="stt">car</span> 和 <span class="stt">cdr</span>
        报错来获知传递了空列表，但它们的
        错误信息无甚帮助。例如，当我们收到
        <span class="stt">car</span>
        的错误信息，可能得找遍整个程序中使用
        <span class="stt">car</span> 的地方。
        <a name="(idx._(gentag._92))"></a>
        <a name="(idx._(gentag._93))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..6)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>如果调换 <span class="stt">nth-element</span>
          中两个条件的顺序，会有什么问题？
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..7)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span><span class="stt">nth-element</span>
          的错误信息不够详尽。重写 <span
            class="stt">nth-element</span>，给出更详细的错误信
          息，像是 “<span class="stt">(a b c)</span> 不足 8
          个元素”。</p>
      </blockquote>
      <h5>1.2.3<tt> </tt><a name="(part._s1..2..3)"></a><span class="stt">remove-first</span></h5>
      <p><a name="(idx._(gentag._94))"></a>
        <a name="(idx._(gentag._95))"></a>
        过程 <span class="stt">remove-first</span>
        取两个参数：符号 <span class="texMathInline">s</span>
        和符号列表 <span
          class="texMathInline">los</span>。它返回一个列表，
        除了不含第一个出现在 <span
          class="texMathInline">los</span> 中的符号 <span class="texMathInline">s</span>
        外，所含元素及其排列顺序与 <span
          class="texMathInline">los</span>
        相同。如果 <span class="texMathInline">s</span>
        没有出现在 <span class="texMathInline">los</span>
        中，则返回 <span class="texMathInline">los</span>。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span
                  class="RktSym">remove-first</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">(</span><span class="RktVal">a</span><span class="hspace"> </span><span
                  class="RktVal">b</span><span class="hspace"> </span><span class="RktVal">c</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">'(b<span class="stt"> </span>c)</span></p>
              </td>
            </tr>
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span
                  class="RktSym">remove-first</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">b</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">(</span><span class="RktVal">e</span><span class="hspace"> </span><span
                  class="RktVal">f</span><span class="hspace"> </span><span class="RktVal">g</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">'(e<span class="stt"> </span>f<span class="stt"> </span>g)</span></p>
              </td>
            </tr>
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span
                  class="RktSym">remove-first</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">a4</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">(</span><span class="RktVal">c1</span><span class="hspace"> </span><span
                  class="RktVal">a4</span><span class="hspace"> </span><span class="RktVal">c1</span><span
                  class="hspace"> </span><span class="RktVal">a4</span><span class="RktVal">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">'(c1<span class="stt"> </span>c1<span class="stt"> </span>a4)</span></p>
              </td>
            </tr>
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span
                  class="RktSym">remove-first</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">'()</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>
        写出此过程之前，我们先要定义符号列表集合
        <span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Symbol}</span>
        ，以便给出问题的完整描述。不像上一节介
        绍的
        s-lists，符号列表不包含子列表。
      </p>
      <blockquote class="SubFlow">
        <p><span class="texMathDisplay">\mathit{List\mbox{-}of\mbox{-}Symbol} ::= <span class="stt">()</span> \mid
            <span class="stt">(</span><span class="texMathInline">\mathit{Symbol}</span><span class="stt"> .
            </span><span class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Symbol}</span><span
              class="stt">)</span></span></p>
        <p>
          符号列表或者是空列表，或者是首项为符号，余项为符号列表。
        </p>
      </blockquote>
      <p>如果列表为空，不需要移除 <span
          class="texMathInline">s</span>，则答案为空列表。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><a name="(elem._remove-first)"></a><span style="font-weight: bold"><span
                    class="stt">remove-first</span></span> : <span class="texMathInline">\mathit{Sym} \times
                  \mathit{Listof}(\mathit{Sym}) \to \mathit{Listof}(\mathit{Sym})</span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold">用法</span> : <span class="stt">(remove-first </span><span
                  class="texMathInline">s</span><span class="stt"> </span><span class="texMathInline">los</span><span
                  class="stt">)
                  返回一列表，除了不含第一个出现在
                </span><span class="texMathInline">los</span><span class="stt"> 中的符号
                </span><span class="texMathInline">s</span><span class="stt">
                  外，元素及其排列顺序与 </span><span
                  class="texMathInline">los</span><span class="stt"> 相同。</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">remove-first</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">s</span><span class="hspace"> </span><span class="RktSym">los</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">los</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>写合约时，我们用 <span
          class="texMathInline">\mathit{Listof}(\mathit{Sym})</span> 而不是
        <span
          class="texMathInline">\mathit{List\mbox{-}of\mbox{-}Symbol}</span>。用这种写法可以免除许多上面那样的定义。
      </p>
      <p>如果 <span class="texMathInline">los</span>
        非空，有没有哪种情况可以立刻得出答案？如果
        <span class="texMathInline">los</span> 的第一个元素是
        <span class="texMathInline">s</span>，比如 <span class="texMathInline">los = <span
            class="stt">(</span><span class="texMathInline">s</span><span class="stt"> </span><span
            class="texMathInline">s_1</span><span class="stt"> </span><span class="texMathInline">...</span><span
            class="stt"> </span><span class="texMathInline">s_{n-1}</span><span class="stt">)</span></span>，<span
          class="texMathInline">s</span> 首次出现时
        是 <span class="texMathInline">los</span>
        的第一个元素，那么把它删除之后的结果是
        <span class="stt">(</span><span class="texMathInline">s_1</span><span class="stt"> </span><span
          class="texMathInline">...</span><span class="stt">
        </span><span class="texMathInline">s_{n-1}</span><span class="stt">)</span>。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">remove-first</span></span> : <span
                  class="texMathInline">\mathit{Sym} \times \mathit{Listof}(\mathit{Sym}) \to
                  \mathit{Listof}(\mathit{Sym})</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">remove-first</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">s</span><span class="hspace"> </span><span class="RktSym">los</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">los</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td>\begin{mdframed}[style=codediff]</td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktPn">(</span><span class="RktSym">if</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">eqv?</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                  class="RktSym">los</span><span class="RktPn">)</span><span class="hspace"> </span><span
                  class="RktSym">s</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span
                  class="hspace">            </span><span
                  class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace"> </span><span
                  class="RktSym">los</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span
                  class="hspace">            </span><span
                  class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>\end{mdframed}</td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>如果 <span class="texMathInline">los</span>
        的第一个元素不是 <span
          class="texMathInline">s</span>，比如 <span class="texMathInline">los = <span
            class="stt">(</span><span class="texMathInline">s_0</span><span class="stt"> </span><span
            class="texMathInline">s_1</span><span class="stt"> </span><span class="texMathInline">...</span><span
            class="stt">
          </span><span class="texMathInline">s_{n-1}</span><span class="stt">)</span></span>，可知
        <span class="texMathInline">s_0</span> 不是第一个出现的 <span
          class="texMathInline">s</span>，因此答案中的第一个元素一定
        是<span class="texMathInline">s_0</span>，即表达式 <span class="stt">(car
          los)</span> 的值。而且，<span class="texMathInline">los</span>
        中的首个 <span class="texMathInline">s</span> 一定在
        <span class="stt">(</span><span class="texMathInline">s_1</span><span class="stt"> </span><span
          class="texMathInline">...</span><span class="stt"> </span><span class="texMathInline">s_{n-1}</span><span
          class="stt">)</span>
        中。所以答案的余下部分一定是移除
        <span class="texMathInline">los</span> 余项
        中首个 <span class="texMathInline">s</span> 的结果。因为
        <span class="texMathInline">los</span> 的余项比 <span class="texMathInline">los</span>
        短，我们可以递归调用
        <span class="stt">remove-first</span>，从 <span class="texMathInline">los</span>
        的余项中移除 <span
          class="texMathInline">s</span>，即答案的余项可用
        <span class="stt">(remove-first s (cdr los))</span>
        求得。已知如何找出答案的首项和余项，可以用
        <span class="stt">cons</span> 结合二者，通过表达式
        <span class="stt">(cons (car los) (remove-first s (cdr los)))</span>
        求得整个答案。由此，<span
          class="stt">remove-first</span> 的完整定义为
      </p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">remove-first</span></span> : <span
                    class="texMathInline">\mathit{Sym} \times \mathit{Listof}(\mathit{Sym}) \to
                    \mathit{Listof}(\mathit{Sym})</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span
                    class="hspace"> </span><span class="RktSym">remove-first</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">s</span><span class="hspace"> </span><span class="RktSym">los</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">los</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span
                    class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span
                    class="RktPn">(</span><span class="RktSym">if</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">eqv?</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                    class="RktSym">los</span><span class="RktPn">)</span><span class="hspace"> </span><span
                    class="RktSym">s</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span
                    class="hspace">            </span><span
                    class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace"> </span><span
                    class="RktSym">los</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>\begin{mdframed}[style=codediff]</td>
              </tr>
              <tr>
                <td><span
                    class="hspace">            </span><span
                    class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                    class="RktSym">los</span><span class="RktPn">)</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">remove-first</span><span
                    class="hspace"> </span><span class="RktSym">s</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace"> </span><span
                    class="RktSym">los</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>\end{mdframed}</td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._96))"></a>
          <a name="(idx._(gentag._97))"></a>
        </div>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..8)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>如果把 <span class="stt">remove-first</span>
          定义中的最后一行改为 <span
            class="stt">(remove-first s (cdr los))</span>，
          得到的过程做什么运算？对修改后的版本，给出合约，包括用法。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..9)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>定义 <span
            class="stt">remove</span>。它类似于 <span
            class="stt">remove-first</span>，但会从符号列表中移除所有给定符号，
          而不只是第一个。</p>
      </blockquote>
      <h5>1.2.4<tt> </tt><a name="(part._s1..2..4)"></a><span class="stt">occurs-free?</span></h5>
      <p><a name="(idx._(gentag._98))"></a>
        <a name="(idx._(gentag._99))"></a>
        <a name="(idx._(gentag._100))"></a>
        过程 <span class="stt">occurs-free?</span> 取一个变量 <span
          class="texMathInline">var</span>，由 Scheme
        符号表示；一个 lambda 演算
        表达式 <span class="texMathInline">exp</span>，形如<span
          class="EoplDefinitionRef"></span>；判断 <span class="texMathInline">var</span>
        是否自由出现于 <span class="texMathInline">exp</span>。
        如果一个变量出现于表达式 <span
          class="texMathInline">exp</span> 中，但不在某一 <span
          class="stt">lambda</span> 绑定之内，我们说该变
        量<span class="emph">自由出现</span> (<span class="emph">occur free</span>)
        于表达式 <span class="texMathInline">exp</span> 中。例如，
        <a name="(idx._(gentag._101))"></a>
        <a name="(idx._(gentag._102))"></a>
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span
                  class="RktSym">occurs-free?</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">x</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">#t</span></p>
              </td>
            </tr>
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span
                  class="RktSym">occurs-free?</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">y</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">#f</span></p>
              </td>
            </tr>
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span
                  class="RktSym">occurs-free?</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">(</span><span class="RktVal">lambda</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">x</span><span class="RktVal">)</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">x</span><span
                  class="hspace"> </span><span class="RktVal">y</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">#f</span></p>
              </td>
            </tr>
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span
                  class="RktSym">occurs-free?</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">(</span><span class="RktVal">lambda</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">y</span><span class="RktVal">)</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">x</span><span
                  class="hspace"> </span><span class="RktVal">y</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">#t</span></p>
              </td>
            </tr>
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span
                  class="RktSym">occurs-free?</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">lambda</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">x</span><span
                  class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">x</span><span
                  class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">y</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">#t</span></p>
              </td>
            </tr>
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span
                  class="RktSym">occurs-free?</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">(</span><span class="RktVal">lambda</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">y</span><span class="RktVal">)</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">lambda</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">z</span><span
                  class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">y</span><span class="hspace"> </span><span class="RktVal">z</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">#t</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>我们可以遵照 lambda
        演算表达式的语法解决此问题：
      </p>
      <blockquote class="NormalFont">
        <p><span class="Iidentity">\begin{align*}\mathit{LcExp} &::= <span
              class="Iidentity">\mathit{Identifier}</span> \\
            &::= <span class="stt">(lambda (</span><span class="Iidentity">\mathit{Identifier}</span><span
              class="stt">) </span><span class="Iidentity">\mathit{LcExp}</span><span class="stt">)</span> \\
            &::= <span class="stt">(</span><span class="Iidentity">\mathit{LcExp}</span><span class="stt">
            </span><span class="Iidentity">\mathit{LcExp}</span><span class="stt">)</span>\end{align*}</span></p>
      </blockquote>
      <p>
        我们可以总结出规则的各种情况：
      </p>
      <ul>
        <li>
          <p>若表达式 <span class="texMathInline">e</span>
            是一变量，则当且仅当 <span
              class="texMathInline">x</span> 与 <span class="texMathInline">e</span>
            相同时，变量 <span class="texMathInline">x</span> 自
            由出现于 <span class="texMathInline">e</span>。</p>
        </li>
        <li>
          <p>若表达式 <span class="texMathInline">e</span> 形如 <span
              class="stt">(</span><span class="texMathInline">lambda</span><span class="stt"> (</span><span
              class="texMathInline">y</span><span class="stt">) </span><span
              class="texMathInline">e{}’</span><span
              class="stt">)</span>，则当且仅当 <span class="texMathInline">y</span>
            不
            同于 <span class="texMathInline">x</span> 且 <span class="texMathInline">x</span>
            自由出现于 <span class="texMathInline">e{}’</span>
            时，变量 <span class="texMathInline">x</span>
            自由出现于 <span class="texMathInline">e</span>。</p>
        </li>
        <li>
          <p>若表达式 <span class="texMathInline">e</span> 形如 <span
              class="stt">(</span><span class="texMathInline">e_1</span><span class="stt"> </span><span
              class="texMathInline">e_2</span><span class="stt">)</span>，则当且仅当
            <span class="texMathInline">x</span> 自由出现于
            <span class="texMathInline">e_1</span> 或 <span class="texMathInline">e_2</span> 时，<span
              class="texMathInline">x</span> 自由出现于 <span
              class="texMathInline">e</span>。这里的“或
            ”表示<span class="emph">涵盖或</span> (<span class="emph">inclusive
              or</span>)，意为它包含 <span class="texMathInline">x</span>
            同时自由出现
            于 <span class="texMathInline">e_1</span> 和 <span class="texMathInline">e_2</span>
            的情况。我们通常用“或”表示这
            种意思。
            <a name="(idx._(gentag._103))"></a>
            <a name="(idx._(gentag._104))"></a>
          </p>
        </li>
      </ul>
      <p>
        你可以说服自己，这些规则涵盖了“<span
          class="texMathInline">x</span> 不在某一 lambda 绑定之中
        ”表示的所有意思。
        <a name="(idx._(gentag._105))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..10)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>我们常用“或”表示“涵盖或
          ”。“或”还有什么含义？<br /></p>
      </blockquote>
      <p>然后，定义 <span class="stt">occurs-free?</span>
        就很容易了。因为有三种情况要检查，我们不用
        Scheme
        的 <span class="stt">if</span>，而是用 <span
          class="stt">cond</span>。在 Scheme 中，若 <span
          class="texMathInline">exp_1</span> 或 <span class="texMathInline">exp_2</span>
        返回真值，
        则 <span class="stt">(or </span><span class="texMathInline">exp_1</span><span class="stt"> </span><span
          class="texMathInline">exp_2</span><span class="stt">)</span> 返回真值。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><a name="(elem._occurs-free-1~3f)"></a><span style="font-weight: bold"><span
                    class="stt">occurs-free?</span></span> : <span class="texMathInline">\mathit{Sym} \times
                  \mathit{LcExp} \to \mathit{Bool}</span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold">用法</span> : <span class="stt">若符号
                </span><span class="texMathInline">var</span><span class="stt"> 自由出现于
                </span><span class="texMathInline">exp</span><span class="stt">，返回
                  #t，否则返回 #f</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">occurs-free?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">var</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">cond</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktPn">(</span><span class="RktSym">symbol?</span><span class="hspace"> </span><span
                  class="RktSym">exp</span><span class="RktPn">)</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">eqv?</span><span class="hspace"> </span><span
                  class="RktSym">var</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktPn">(</span><span class="RktSym">eqv?</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                  class="RktSym">exp</span><span class="RktPn">)</span><span class="hspace"> </span><span
                  class="RktVal">'</span><span class="RktVal">lambda</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktPn">(</span><span class="RktSym">and</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span
                  class="RktPn">(</span><span class="RktSym">not</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">eqv?</span><span class="hspace"> </span><span
                  class="RktSym">var</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">car</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">cadr</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span
                  class="RktPn">(</span><span class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                  class="RktSym">var</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">caddr</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">else</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktPn">(</span><span class="RktSym">or</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span
                  class="RktPn">(</span><span class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                  class="RktSym">var</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span
                  class="RktPn">(</span><span class="RktSym">occurs-free?</span><span class="hspace"> </span><span
                  class="RktSym">var</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">cadr</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>
        这一过程略显晦涩。比如，很难弄明白
        <span class="stt">(car (cadr exp))</span> 指代 <span class="stt">lambda</span>
        表达式
        中的变量声明，或者 <span class="stt">(caddr exp)</span>
        指代 <span class="stt">lambda</span>
        表达式的主体。在
        <a href="da.html#%28part._s2..5%29"
          data-pltdoc="x">抽象语法及其表示</a>，我们展示如何显著改善这种情况。
        <a name="(idx._(gentag._106))"></a>
        <a name="(idx._(gentag._107))"></a>
      </p>
      <h5>1.2.5<tt> </tt><a name="(part._s1..2..5)"></a><span class="stt">subst</span></h5>
      <p><a name="(idx._(gentag._108))"></a>
        <a name="(idx._(gentag._109))"></a>
        <a name="(idx._(gentag._110))"></a>
        <a name="(idx._(gentag._111))"></a>
        <a name="(idx._(gentag._112))"></a>
        <a name="(idx._(gentag._113))"></a>
        <a name="(idx._(gentag._114))"></a>
        <a name="(idx._(gentag._115))"></a>
        过程 <span class="stt">subst</span>
        取三个参数：两个符号 <span class="stt">new</span>
        和 <span class="stt">old</span>，一个 s-list，
        <span class="stt">slist</span>。它检查 <span class="stt">slist</span>
        的所有元素，返回类似 <span class="stt">slist</span>
        的新列表，但把其中
        所有的 <span class="stt">old</span> 替换为 <span
          class="stt">new</span>。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">subst</span><span
                  class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">a</span><span
                  class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">b</span><span
                  class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                  class="RktVal">(</span><span class="RktVal">b</span><span class="hspace"> </span><span
                  class="RktVal">c</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">b</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">d</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>
                <p><span class="RktRes">'((a<span class="stt"> </span>c)<span class="stt"> </span>(a<span class="stt">
                    </span>()<span class="stt"> </span>d))</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>因为 <span class="stt">subst</span> 定义于 s-list
        上，它的结构应当反映 s-list
        的定义（<span class="EoplDefinitionRef"></span>）：</p>
      <blockquote class="NormalFont">
        <p><span class="Iidentity">\begin{align*}\mathit{S\mbox{-}list} &::= <span class="stt">(</span><span
              class="Iidentity">\{\mathit{S\mbox{-}exp}\}^*</span><span class="stt">)</span> \\
            \mathit{S\mbox{-}exp} &::= \mathit{Symbol} \mid \mathit{S\mbox{-}list}\end{align*}</span></p>
      </blockquote>
      <p>克莱尼星号简洁地描述了集合
        s-list，但对写程序没什么用。因此我们的第一步是抛开克
        莱尼星号重写语法。得出的语法表明，我们的过程应当该递归处理
        s-list 的首项和余项。</p>
      <blockquote class="NormalFont">
        <p><span class="Iidentity">\begin{align*}\mathit{S\mbox{-}list} &::= <span class="stt">()</span> \\
            &::= <span class="stt">(</span><span class="Iidentity">\mathit{S\mbox{-}exp}</span><span class="stt"> .
            </span><span class="Iidentity">\mathit{S\mbox{-}list}</span><span class="stt">)</span> \\
            \mathit{S\mbox{-}exp} &::= \mathit{Symbol} \mid \mathit{S\mbox{-}list}\end{align*}</span></p>
      </blockquote>
      <p>
        这一例子比之前的复杂，因为它的语法输入包含两个非终结符，<span
          class="texMathInline">S\mbox{-}list</span> 和
        <span
          class="texMathInline">S\mbox{-}exp</span>。因此，我们需要两个过程，一个处理
        <span class="texMathInline">S\mbox{-}list</span>，另一个处理
        <span class="texMathInline">S\mbox{-}exp</span>。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">subst</span></span> : <span
                  class="Iidentity">$\mathit{Sym} \times \mathit{Sym} \times \mathit{S\mbox{-}list} \to
                  \mathit{S\mbox{-}list}$</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">subst</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">new</span><span class="hspace"> </span><span class="RktSym">old</span><span
                  class="hspace"> </span><span class="RktSym">slist</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktSym">...</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">subst-in-s-exp</span></span> : <span
                  class="Iidentity">$\mathit{Sym} \times \mathit{Sym} \times \mathit{S\mbox{-}exp} \to
                  \mathit{S\mbox{-}exp}$</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">subst-in-s-exp</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">new</span><span class="hspace"> </span><span class="RktSym">old</span><span
                  class="hspace"> </span><span class="RktSym">sexp</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktSym">...</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>我们首先处理 <span
          class="stt">subst</span>。如果列表为空，不需要替换
        <span class="stt">old</span>。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">subst</span></span> : <span
                  class="Iidentity">$\mathit{Sym} \times \mathit{Sym} \times \mathit{S\mbox{-}list} \to
                  \mathit{S\mbox{-}list}$</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">subst</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">new</span><span class="hspace"> </span><span class="RktSym">old</span><span
                  class="hspace"> </span><span class="RktSym">slist</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">slist</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>如果 <span class="stt">slist</span>
        非空，它的首项是一个 <span
          class="texMathInline">S\mbox{-}exp</span>，余项是另一
        s-list。这时，
        答案应当是一个列表，它的首项是把
        <span class="stt">slist</span> 首项中的 <span class="stt">old</span>
        替换为 <span class="stt">new</span> 的
        结果，它的余项是把 <span class="stt">slist</span>
        余项中的 <span class="stt">old</span> 替换为 <span
          class="stt">new</span> 的结果。因为
        <span class="stt">slist</span> 的首项是 <span class="texMathInline">S\mbox{-}exp</span>
        的元素，我们用 <span
          class="stt">subst-in-s-exp</span>解决这一
        子问题。因为 <span class="stt">slist</span> 的余项是
        <span class="texMathInline">S\mbox{-}list</span>
        的元素，我们递归调用
        <span class="stt">subst</span> 处理它。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><a name="(elem._subst)"></a><span style="font-weight: bold"><span class="stt">subst</span></span> :
                <span class="Iidentity">$\mathit{Sym} \times \mathit{Sym} \times \mathit{S\mbox{-}list} \to
                  \mathit{S\mbox{-}list}$</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">subst</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">new</span><span class="hspace"> </span><span class="RktSym">old</span><span
                  class="hspace"> </span><span class="RktSym">slist</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">slist</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td>\begin{mdframed}[style=codediff]</td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktPn">(</span><span class="RktSym">cons</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span
                  class="RktPn">(</span><span class="RktSym">subst-in-s-exp</span><span
                  class="hspace"> </span><span class="RktSym">new</span><span class="hspace"> </span><span
                  class="RktSym">old</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">slist</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span
                  class="RktPn">(</span><span class="RktSym">subst</span><span class="hspace"> </span><span
                  class="RktSym">new</span><span class="hspace"> </span><span class="RktSym">old</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">cdr</span><span
                  class="hspace"> </span><span class="RktSym">slist</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>\end{mdframed}</td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>现在来处理 <span
          class="stt">subst-in-s-exp</span>。由语法，可知符号表达式
        <span class="stt">sexp</span> 或者是符号，或
        者是
        s-list。如果它是符号，那么得检查它与符号
        <span class="stt">old</span>
        是否相同。如果是，答案为
        <span class="stt">new</span>；否则，答案还是 <span
          class="stt">sexp</span>。如果 <span class="stt">sexp</span> 是一个
        s-list，那么我们递归调
        用 <span class="stt">subst</span> 找出答案。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">subst-in-s-exp</span></span> : <span
                  class="Iidentity">$\mathit{Sym} \times \mathit{Sym} \times \mathit{S\mbox{-}exp} \to
                  \mathit{S\mbox{-}exp}$</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">subst-in-s-exp</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">new</span><span class="hspace"> </span><span class="RktSym">old</span><span
                  class="hspace"> </span><span class="RktSym">sexp</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>\begin{mdframed}[style=codediff]</td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">symbol?</span><span class="hspace"> </span><span class="RktSym">sexp</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktPn">(</span><span class="RktSym">if</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">eqv?</span><span class="hspace"> </span><span
                  class="RktSym">sexp</span><span class="hspace"> </span><span class="RktSym">old</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">new</span><span
                  class="hspace"> </span><span class="RktSym">sexp</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktPn">(</span><span class="RktSym">subst</span><span class="hspace"> </span><span
                  class="RktSym">new</span><span class="hspace"> </span><span class="RktSym">old</span><span
                  class="hspace"> </span><span class="RktSym">sexp</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td>\end{mdframed}</td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>因为我们严格依照 <span
          class="texMathInline">\mathit{S\mbox{-}list}</span> 和 <span
          class="texMathInline">\mathit{S\mbox{-}exp}</span> 的定义，
        这个递归一定会终止。因为 <span
          class="stt">subst</span> 和 <span class="stt">subst-in-s-exp</span>
        递归调用彼此，我们称
        之为<span class="emph">互递归</span> (<span class="emph">mutually
          recursive</span>)。
        <a name="(idx._(gentag._116))"></a>
      </p>
      <p>把 <span class="stt">subst</span>
        拆解为两个过程——每个处理一种句法类别——是个重要技巧。对更为复杂的程
        序，我们得以每次考虑一个句法类别，从而化繁为简。
        <a name="(idx._(gentag._117))"></a>
        <a name="(idx._(gentag._118))"></a>
        <a name="(idx._(gentag._119))"></a>
        <a name="(idx._(gentag._120))"></a>
        <a name="(idx._(gentag._121))"></a>
        <a name="(idx._(gentag._122))"></a>
        <a name="(idx._(gentag._123))"></a>
        <a name="(idx._(gentag._124))"></a>
        <a name="(idx._(gentag._125))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..11)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><span class="stt">subst-in-s-exp</span>
          的最后一行中，递归是针对 <span
            class="stt">sexp</span>
          而非更小的子结构，为什
          么一定能终止？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..12)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._126))"></a>
          用 <span class="stt">subst-in-s-exp</span> 的定义替换 <span
            class="stt">subst</span>
          中的调用，从而排除这次调用，然后简
          化得到的过程。结果中的 <span
            class="stt">subst</span> 应当不需要 <span
            class="stt">subst-in-s-exp</span>。这种技巧
          叫做<span class="emph">内联</span> (<span
            class="emph">inlining</span>)，用于优化编译器。
          <a name="(idx._(gentag._127))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..13)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>在我们的例子中，我们从排除
          <span class="Iidentity">$S\mbox{-}list$</span>
          语法内的克莱尼星号开始。依照原本的
          语法，用 <span class="stt">map</span> 重写 <span
            class="stt">subst</span>。<br /></p>
      </blockquote>
      <p><a name="(idx._(gentag._128))"></a>
        <a name="(idx._(gentag._129))"></a>
        现在，我们有了编写过程处理归纳数据集的窍门，来把它总结成一句口诀。
      </p>
      <blockquote class="Tip">
        <blockquote class="SCentered">
          <p><span style="font-weight: bold">遵循语法！</span><a
              name="(idx._(gentag._130))"></a></p>
        </blockquote>
        <p class="TipContent">
          定义过程处理归纳式数据时，程序的结构应当反映数据的结
          构。</p>
      </blockquote>
      <p>更准确地说：</p>
      <ul>
        <li>
          <p><a name="(idx._(gentag._131))"></a>
            为语法中的每个非终结符编写一个过程。这一过程负责处理相应非终结符的数据，
            不做其他。</p>
        </li>
        <li>
          <p>
            在每个过程中，为相应非终结符的每一生成式写一分支。你可能需要额外的分支结
            构，但这样才能起步。对生成式右边出现的每个非终结符，递归调用相应的过程。
            <a name="(idx._(gentag._132))"></a>
            <a name="(idx._(gentag._133))"></a>
            <a name="(idx._(gentag._134))"></a>
          </p>
        </li>
      </ul>
      <h4>1.3<tt> </tt><a
          name="(part._s1..3)"></a>辅助过程和上下文参数</h4>
      <p><a name="(idx._(gentag._135))"></a>
        <a name="(idx._(gentag._136))"></a>
        <a name="(idx._(gentag._137))"></a>
        窍门<span
          class="emph">遵循语法</span>很有效，有时却还是不够。考虑过程
        <span class="stt">number-elements</span>。这
        一过程取任何列表 <span class="stt">(</span><span
          class="texMathInline">v_0</span><span class="stt"> </span><span class="texMathInline">v_1</span><span
          class="stt"> </span><span class="texMathInline">v_2</span><span class="stt"> ...)</span>
        ，返回一列表 <span class="stt">((0</span><span class="stt">
        </span><span class="texMathInline">v_0</span><span class="stt">) (1 </span><span
          class="texMathInline">v_1</span><span class="stt">) (2 </span><span class="texMathInline">v_2</span><span
          class="stt">) ...)</span>。
      </p>
      <p>
        我们用过的那种直拆法不凑效，因为没有明显的方法能从
        <span class="stt">(number-elements (cdr
          lst))</span> 得出 <span class="stt">(number-elements lst)</span>
        （但是，看看<span class="EoplExerciseRef"></span>）。</p>
      <p><a name="(idx._(gentag._138))"></a>
        要解决这个问题，我们<span
          class="emph">放宽</span> (<span class="emph">generalize</span>)
        问题。我们写一个过程
        <span class="stt">number-elements-from</span>
        ，它取一个额外参数 <span
          class="texMathInline">n</span>，指定起始编号。用递归处理列表，
        这个过程很容易写。
        <a name="(idx._(gentag._139))"></a>
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">number-elements-from</span></span> : <span
                  class="Iidentity">$\mathit{Listof}(\mathit{SchemeVal}) \times \mathit{Int} \to
                  \mathit{Listof}(\mathit{List}(\mathit{Int}, \mathit{SchemeVal}))$</span></td>
            </tr>
            <tr>
              <td><span class="texMathInline">\begin{alignedat}{-1}<span
                    style="font-weight: bold">用法</span> : &<span class="stt">(number-elements-from
                  </span><span class="stt">’</span><span class="stt">(</span><span
                    class="texMathInline">v_0</span><span class="stt"> </span><span
                    class="texMathInline">v_1</span><span class="stt"> </span><span
                    class="texMathInline">v_2</span><span class="stt"> ...) n)</span> \\ &\hphantom{x}= <span
                    class="stt">((</span><span class="texMathInline">n</span><span class="stt"> </span><span
                    class="texMathInline">v_0</span><span class="stt">) (</span><span class="texMathInline">n +
                    1</span><span class="stt"> </span><span class="texMathInline">v_1</span><span class="stt">)
                    (</span><span class="texMathInline">n + 2</span><span class="stt"> </span><span
                    class="texMathInline">v_2</span><span class="stt">) ...)</span>\end{alignedat}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">number-elements-from</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">lst</span><span class="hspace"> </span><span class="RktSym">n</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">lst</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">(</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span
                  class="RktPn">(</span><span class="RktSym">cons</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span
                  class="RktPn">(</span><span class="RktSym">list</span><span class="hspace"> </span><span
                  class="RktSym">n</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">lst</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span
                  class="RktPn">(</span><span class="RktSym">number-elements-from</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">cdr</span><span
                  class="hspace"> </span><span class="RktSym">lst</span><span class="RktPn">)</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">+</span><span
                  class="hspace"> </span><span class="RktSym">n</span><span class="hspace"> </span><span
                  class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>
        合约的标题告诉我们这个过程取两个参数，一个列表（包含任意
        Scheme 值）和一个整数，
        返回一个列表，列表中的每个元素是包含两个元素的列表：一个整数，一个
        Scheme 值。</p>
      <p>一旦我们定义了 <span
          class="stt">number-elements-from</span>，很容易写出所需的过程。
      </p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><a name="(elem._n-e)"></a><span style="font-weight: bold"><span
                      class="stt">number-elements</span></span> : <span
                    class="Iidentity">$\mathit{Listof}(\mathit{SchemeVal}) \to
                    \mathit{Listof}(\mathit{List}(\mathit{Int}, \mathit{SchemeVal}))$</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span
                    class="hspace"> </span><span class="RktSym">number-elements</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">lst</span><span class="hspace"> </span><span class="RktSym">n</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">number-elements-from</span><span class="hspace"> </span><span
                    class="RktSym">lst</span><span class="hspace"> </span><span class="RktVal">0</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._140))"></a></div>
        </p>
      </blockquote>
      <p>这里有两个要点。首先，过程 <span
          class="stt">number-elements-from</span> 的定义独立于
        <span
          class="stt">number-elements</span>。程序员经常要写一个过程，只调用某个辅助过程，并传递额外的常
        量参数。除非我们理解辅助过程对参数的<span
          class="emph">每个</span>值做什么，我们很难理解调用它的过
        程做什么。这给了我们一条口诀：
      </p>
      <blockquote class="Tip">
        <blockquote class="SCentered">
          <p><a name="(elem._no-myth)"></a><span
              style="font-weight: bold">避免神秘小工具！</span>
            <a name="(idx._(gentag._141))"></a>
          </p>
        </blockquote>
        <p class="TipContent">
          定义辅助过程时，总是指明它对所有参数值做什么，而不只
          是初始值。</p>
      </blockquote>
      <p><a name="(idx._(gentag._142))"></a>
        <a name="(idx._(gentag._143))"></a>
        其次，<span class="stt">number-elements-from</span>
        的两个参数各有作用。第一个参数是我们要处理的列表，
        随每一次递归调用而减小。而第二个参数，则是对我们当前任务<span
          class="emph">上下文</span> (<span class="emph">context</span>)
        的抽象。在本例中，当调用 <span
          class="stt">number-elements</span> 时，我们最终调用
        <span class="stt">number-elements-from</span>
        处理原列表的每个子列表。第二个参数告知我们子列表在原列
        表中的位置。随递归调用，它不减反增，因为我们每次经过原列表的一个元素。有时我们称
        之为<span class="emph">上下文参数</span> (<span class="emph">context
          argument</span>)，或者<span class="emph">继承
          属性</span> (<span class="emph">inherited attribute</span>)。
        <a name="(idx._(gentag._144))"></a>
        <a name="(idx._(gentag._145))"></a>
      </p>
      <p>另一个例子是向量求和。</p>
      <p>
        要求列表中各项的和，我们可以遵循语法，递归处理列表的余项。那么我们的过程看起来像
        是：</p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara"><a name="(idx._(gentag._146))"></a>
        </div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><a name="(elem._list-sum)"></a><span style="font-weight: bold"><span
                      class="stt">list-sum</span></span> : <span class="Iidentity">$\mathit{Listof}(\mathit{Int}) \to
                    \mathit{Int}$</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span
                    class="hspace"> </span><span class="RktSym">list-sum</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">loi</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">null?</span><span class="hspace"> </span><span class="RktSym">loi</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span
                    class="RktVal">0</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span
                    class="RktPn">(</span><span class="RktSym">+</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                    class="RktSym">loi</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">           </span><span
                    class="RktPn">(</span><span class="RktSym">list-sum</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace"> </span><span
                    class="RktSym">loi</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
      </blockquote>
      <p>
        但是无法按照这种方式处理向量，因为它们不能够很方便地拆解。
      </p>
      <p>
      <div class="SIntrapara"><a name="(idx._(gentag._147))"></a>
        因为我们无法拆解向量，我们放宽问题，为向量某一部分求和。问题定义为，计算
      </div>
      <div class="SIntrapara">
        <blockquote class="SubFlow">
          <p><span class="texMathDisplay">\sum_{i=0}^{i=length(v)-1} v_i</span>
            其中，<span class="texMathInline">v</span>
            是整数向量。通过把上界改为一个参数
            <span
              class="texMathInline">n</span>，我们放宽了原问题，所以新的
            任务是计算
            <span class="texMathDisplay">\sum_{i=0}^{i=n} v_i</span>
            其中，<span class="texMathInline">0 \leq n < length(v)</span>。
            <a name="(idx._(gentag._148))"></a>
          </p>
        </blockquote>
      </div>
      </p>
      <p><a name="(idx._(gentag._149))"></a>
        <a name="(idx._(gentag._150))"></a>
        按照定义，用归纳法处理第二个参数
        <span
          class="texMathInline">n</span>，可以直接写出此过程。
      </p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">partial-vector-sum</span></span> : <span
                    class="texMathInline">\mathit{Vectorof}(\mathit{Int}) \times \mathit{Int} \to \mathit{Int}</span>
                </td>
              </tr>
              <tr>
                <td><span style="font-weight: bold">用法</span> : <span class="stt">若 </span><span
                    class="texMathInline">0 \leq n < length(v)</span><span class="stt">，则 </span><span
                    class="Iidentity">\[<span class="stt">(partial-vector-sum </span><span
                      class="Iidentity">v</span><span class="stt"> </span><span class="Iidentity">n</span><span
                      class="stt">) = </span><span class="Iidentity">\sum_{i=0}^{i=n} v_i</span>\]</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span
                    class="hspace"> </span><span class="RktSym">partial-vector-sum</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">v</span><span class="hspace"> </span><span class="RktSym">n</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">zero?</span><span class="hspace"> </span><span class="RktSym">n</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span
                    class="RktPn">(</span><span class="RktSym">vector-ref</span><span class="hspace"> </span><span
                    class="RktSym">v</span><span class="hspace"> </span><span class="RktVal">0</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span
                    class="RktPn">(</span><span class="RktSym">+</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">vector-ref</span><span class="hspace"> </span><span
                    class="RktSym">v</span><span class="hspace"> </span><span class="RktSym">n</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">           </span><span
                    class="RktPn">(</span><span class="RktSym">partial-vector-sum</span><span
                    class="hspace"> </span><span class="RktSym">v</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span
                    class="hspace"> </span><span class="RktSym">n</span><span class="hspace"> </span><span
                    class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._151))"></a></div>
        </p>
      </blockquote>
      <p>由于 <span class="texMathInline">n</span>
        一定会递减至零，证明此程序的正确性需要用归纳法处理
        <span class="texMathInline">n</span>。由 <span class="texMathInline">0
          \leq n</span> 且 <span class="texMathInline">n \neq 0</span>，可得 <span
          class="texMathInline">0 \leq (n -
          1)</span>，所以递归调用过程
        <span class="stt">partial-vector-sum</span> 仍然满足其合约。
      </p>
      <p>
        现在，要解决原问题就简单多了。因为向量长度为0时无法使用过程
        <span
          class="stt">partial-vector-sum</span>，所以得另行处理这种情况。
      </p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">vector-sum</span></span> : <span
                    class="Iidentity">$\mathit{Vectorof}(\mathit{Int}) \to \mathit{Int}$</span></td>
              </tr>
              <tr>
                <td><span style="font-weight: bold">用法</span> : <span class="stt">(vector-sum </span><span
                    class="Iidentity">$v$</span><span class="stt">) = </span><span
                    class="Iidentity">$\sum\limits_{i=0}^{i=length(v)-1} v_i$</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span
                    class="hspace"> </span><span class="RktSym">vector-sum</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span
                    class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">v</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">n</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">vector-length</span><span
                    class="hspace"> </span><span class="RktSym">v</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">zero?</span><span class="hspace"> </span><span class="RktSym">n</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span
                    class="RktVal">0</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span
                    class="RktPn">(</span><span class="RktSym">partial-vector-sum</span><span
                    class="hspace"> </span><span class="RktSym">v</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span
                    class="hspace"> </span><span class="RktSym">n</span><span class="hspace"> </span><span
                    class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._152))"></a></div>
        </p>
      </blockquote>
      <p>
        还有许多情况下，引入辅助变量或过程来解决问题会有帮助，甚至必不可少。只要能对新过
        程做什么给出独立的定义，尽可以如此。
        <a name="(idx._(gentag._153))"></a>
        <a name="(idx._(gentag._154))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..14)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._155))"></a>
          若 <span class="Iidentity">$0 \leq n < length(v)$</span>，证明 <span
            class="stt">partial-vector-sum</span> 的正确性。</p>
      </blockquote>
      <h4>1.4<tt> </tt><a name="(part._s1..4)"></a>练习</h4>
      <p><a name="(idx._(gentag._156))"></a>
        学写递归程序需要练习，那么我们拿几道习题结束本章。
      </p>
      <p>每道习题都假定 <span class="stt">s</span>
        是一个符号，<span class="stt">n</span>
        是一个非负整数，<span class="stt">lst</span>
        是一个列表，
        <span class="stt">loi</span> 是一个整数列表，<span
          class="stt">los</span> 是一个符号列表，<span
          class="stt">slist</span> 是一个 s-list，
        <span class="stt">x</span> 是任意 Scheme 值；类似地，<span
          class="stt">s1</span> 是一个符号，<span class="stt">los2</span>
        是一个符号列表，
        <span class="stt">x1</span> 是一个 Scheme
        值，等等。还假定 <span class="stt">pred</span>
        是一个<span class="emph">谓词</span> (<span class="emph">predicate</span>)，
        即一个过程，取任意 Scheme 值，返回
        <span class="stt">#t</span> 或者 <span
          class="stt">#f</span>。除非某个具体问题另有限
        制，不要对数据作其他假设。在这些习题中，不需要检查输入是否符合描述；对每个过程，
        都假定输入值是指定集合的成员。
      </p>
      <p>
        定义，测试和调试每个过程。你的定义应当有本章这种合约和用法注释。可以随便定义辅助
        过程，但是你定义的每个辅助过程都应该有其说明，如同<a
          href="#%28part._s1..3%29"
          data-pltdoc="x">辅助过程和上下文参数</a>那样。
      </p>
      <p>
        测试这些程序时，先试试所有给出的例子，然后用其他例子测试，因为给定的例子不足以涵
        盖所有可能的错误。</p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..15)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._157))"></a>
          <span class="stt">(duple n x)</span> 返回包含 <span class="stt">n</span> 个
          <span class="stt">x</span> 的列表。
        </p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">duple</span><span
                    class="hspace"> </span><span class="RktVal">2</span><span class="hspace"> </span><span
                    class="RktVal">3</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(3<span class="stt"> </span>3)</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">duple</span><span
                    class="hspace"> </span><span class="RktVal">4</span><span class="hspace"> </span><span
                    class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">ha</span><span
                    class="hspace"> </span><span class="RktVal">ha</span><span class="RktVal">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'((ha<span class="stt"> </span>ha)<span class="stt"> </span>(ha<span
                        class="stt"> </span>ha)<span class="stt"> </span>(ha<span class="stt"> </span>ha)<span
                        class="stt"> </span>(ha<span class="stt"> </span>ha))</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">duple</span><span
                    class="hspace"> </span><span class="RktVal">0</span><span class="hspace"> </span><span
                    class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">blah</span><span
                    class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'()</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..16)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span> <span class="stt">lst</span>
          是由二元列表（长度为2的列表）组成的列表，<span
            class="stt">(invert lst)</span> 返回一列表，
          把每个二元列表反转。</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">invert</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">(</span><span class="RktVal">a</span><span class="hspace"> </span><span
                    class="RktVal">1</span><span class="RktVal">)</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">a</span><span class="hspace"> </span><span
                    class="RktVal">2</span><span class="RktVal">)</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">1</span><span class="hspace"> </span><span
                    class="RktVal">b</span><span class="RktVal">)</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">2</span><span class="hspace"> </span><span
                    class="RktVal">b</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'((1<span class="stt"> </span>a)<span class="stt"> </span>(2<span class="stt">
                      </span>a)<span class="stt"> </span>(b<span class="stt"> </span>1)<span class="stt"> </span>(b<span
                        class="stt"> </span>2))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..17)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span> <span class="stt">(down lst)</span> 给 <span class="stt">lst</span>
          的每个顶层元素加上一对括号。
        </p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">down</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">1</span><span class="hspace"> </span><span class="RktVal">2</span><span
                    class="hspace"> </span><span class="RktVal">3</span><span class="RktVal">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'((1)<span class="stt"> </span>(2)<span class="stt"> </span>(3))</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">down</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">(</span><span class="RktVal">a</span><span class="RktVal">)</span><span
                    class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">fine</span><span
                    class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">(</span><span
                    class="RktVal">idea</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(((a))<span class="stt"> </span>((fine))<span class="stt">
                      </span>((idea)))</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">down</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">(</span><span
                    class="RktVal">more</span><span class="hspace"> </span><span class="RktVal">(</span><span
                    class="RktVal">complicated</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                    class="hspace"> </span><span class="RktVal">object</span><span class="RktVal">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'((a)<span class="stt"> </span>((more<span class="stt">
                      </span>(complicated)))<span class="stt"> </span>(object))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..18)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._158))"></a>
          <span class="stt">(swapper s1 s2 slist)</span> 返回一列表，将 <span
            class="stt">slist</span> 中出现的所有 <span class="stt">s1</span>
          替换为
          <span class="stt">s2</span>，所有 <span class="stt">s2</span> 替换为 <span
            class="stt">s1</span>。
        </p>
        <blockquote class="EoplCodeInset">
          <p>
          <div class="SIntrapara">
            <blockquote class="SCodeFlow">
              <table cellspacing="0" cellpadding="0" class="RktBlk">
                <tr>
                  <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">swapper</span><span
                      class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">a</span><span
                      class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">d</span><span
                      class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                      class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">b</span><span
                      class="hspace"> </span><span class="RktVal">c</span><span class="hspace"> </span><span
                      class="RktVal">d</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td>
                    <p><span class="RktRes">'(d<span class="stt"> </span>b<span class="stt"> </span>c<span class="stt">
                        </span>a)</span></p>
                  </td>
                </tr>
                <tr>
                  <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">swapper</span><span
                      class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">a</span><span
                      class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">d</span><span
                      class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                      class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">d</span><span
                      class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">)</span><span
                      class="hspace"> </span><span class="RktVal">c</span><span class="hspace"> </span><span
                      class="RktVal">d</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td>
                    <p><span class="RktRes">'(d<span class="stt"> </span>a<span class="stt"> </span>()<span class="stt">
                        </span>c<span class="stt"> </span>a)</span></p>
                  </td>
                </tr>
                <tr>
                  <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">swapper</span><span
                      class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">x</span><span
                      class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">y</span><span
                      class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                      class="RktVal">(</span><span class="RktVal">x</span><span class="RktVal">)</span><span
                      class="hspace"> </span><span class="RktVal">y</span><span class="hspace"> </span><span
                      class="RktVal">(</span><span class="RktVal">z</span><span class="hspace"> </span><span
                      class="RktVal">(</span><span class="RktVal">x</span><span class="RktVal">)</span><span
                      class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td>
                    <p><span class="RktRes">'((y)<span class="stt"> </span>x<span class="stt"> </span>(z<span
                          class="stt"> </span>(y)))</span></p>
                  </td>
                </tr>
              </table>
            </blockquote>
          </div>
          <div class="SIntrapara"><a name="(idx._(gentag._159))"></a></div>
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..19)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>
          <span class="stt">(list-set lst n x)</span> 返回一列表，除第
          <span class="stt">n</span> 个元素
          （从零开始计数）为
          <span class="stt">x</span> 外，与 <span class="stt">lst</span> 相同。
        </p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">list-set</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">b</span><span
                    class="hspace"> </span><span class="RktVal">c</span><span class="hspace"> </span><span
                    class="RktVal">d</span><span class="RktVal">)</span><span class="hspace"> </span><span
                    class="RktVal">2</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">(</span><span class="RktVal">1</span><span class="hspace"> </span><span
                    class="RktVal">2</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(a<span class="stt"> </span>b<span class="stt"> </span>(1<span class="stt">
                      </span>2)<span class="stt"> </span>d)</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">list-ref</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">list-set</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">b</span><span
                    class="hspace"> </span><span class="RktVal">c</span><span class="hspace"> </span><span
                    class="RktVal">d</span><span class="RktVal">)</span><span class="hspace"> </span><span
                    class="RktVal">3</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">(</span><span class="RktVal">1</span><span class="hspace"> </span><span
                    class="RktVal">5</span><span class="hspace"> </span><span class="RktVal">10</span><span
                    class="RktVal">)</span><span class="RktPn">)</span><span class="hspace"> </span><span
                    class="RktVal">3</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(1<span class="stt"> </span>5<span class="stt"> </span>10)</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..20)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._160))"></a>
          <span class="stt">(count-occurrences s slist)</span> 返回 <span class="stt">slist</span>
          中出现的 <span class="stt">s</span> 个数。
        </p>
        <blockquote class="EoplCodeInset">
          <p>
          <div class="SIntrapara">
            <blockquote class="SCodeFlow">
              <table cellspacing="0" cellpadding="0" class="RktBlk">
                <tr>
                  <td><span class="stt">> </span><span class="RktPn">(</span><span
                      class="RktSym">count-occurrences</span><span class="hspace"> </span><span
                      class="RktVal">'</span><span class="RktVal">x</span><span class="hspace"> </span><span
                      class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span
                      class="RktVal">f</span><span class="hspace"> </span><span class="RktVal">x</span><span
                      class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">y</span><span
                      class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">(</span><span
                      class="RktVal">(</span><span class="RktVal">x</span><span class="hspace"> </span><span
                      class="RktVal">z</span><span class="RktVal">)</span><span class="hspace"> </span><span
                      class="RktVal">x</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                      class="RktVal">)</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td>
                    <p><span class="RktRes">3</span></p>
                  </td>
                </tr>
                <tr>
                  <td><span class="stt">> </span><span class="RktPn">(</span><span
                      class="RktSym">count-occurrences</span><span class="hspace"> </span><span
                      class="RktVal">'</span><span class="RktVal">x</span><span class="hspace"> </span><span
                      class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span
                      class="RktVal">f</span><span class="hspace"> </span><span class="RktVal">x</span><span
                      class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">y</span><span
                      class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">(</span><span
                      class="RktVal">(</span><span class="RktVal">x</span><span class="hspace"> </span><span
                      class="RktVal">z</span><span class="RktVal">)</span><span class="hspace"> </span><span
                      class="RktVal">(</span><span class="RktVal">)</span><span class="hspace"> </span><span
                      class="RktVal">x</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                      class="RktVal">)</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td>
                    <p><span class="RktRes">3</span></p>
                  </td>
                </tr>
                <tr>
                  <td><span class="stt">> </span><span class="RktPn">(</span><span
                      class="RktSym">count-occurrences</span><span class="hspace"> </span><span
                      class="RktVal">'</span><span class="RktVal">w</span><span class="hspace"> </span><span
                      class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span
                      class="RktVal">f</span><span class="hspace"> </span><span class="RktVal">x</span><span
                      class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">y</span><span
                      class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">(</span><span
                      class="RktVal">(</span><span class="RktVal">x</span><span class="hspace"> </span><span
                      class="RktVal">z</span><span class="RktVal">)</span><span class="hspace"> </span><span
                      class="RktVal">x</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                      class="RktVal">)</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td>
                    <p><span class="RktRes">0</span></p>
                  </td>
                </tr>
              </table>
            </blockquote>
          </div>
          <div class="SIntrapara"><a name="(idx._(gentag._161))"></a></div>
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..21)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>
          <span class="stt">sos1</span> 和 <span class="stt">sos2</span>
          是两个没有重复元素的符号列表，<span
            class="stt">(product sos1 sos2)</span>返
          回二元列表的列表，代表 <span
            class="stt">sos1</span> 和 <span class="stt">sos2</span>
          的笛卡尔积。二元列表排列顺序不限。
        </p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">product</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">b</span><span
                    class="hspace"> </span><span class="RktVal">c</span><span class="RktVal">)</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">y</span><span
                    class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'((a<span class="stt"> </span>x)<span class="stt"> </span>(a<span class="stt">
                      </span>y)<span class="stt"> </span>(b<span class="stt"> </span>x)<span class="stt"> </span>(b<span
                        class="stt"> </span>y)<span class="stt"> </span>(c<span class="stt"> </span>x)<span class="stt">
                      </span>(c<span class="stt"> </span>y))</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..22)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>
          <span class="stt">(filter-in pred lst)</span> 返回的列表，由 <span
            class="stt">lst</span> 中满足谓词 <span class="stt">pred</span>
          的元素组
          成。</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">filter-in</span><span
                    class="hspace"> </span><span class="RktSym">number?</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">2</span><span
                    class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">1</span><span
                    class="hspace"> </span><span class="RktVal">3</span><span class="RktVal">)</span><span
                    class="hspace"> </span><span class="RktVal">b</span><span class="hspace"> </span><span
                    class="RktVal">7</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(2<span class="stt"> </span>7)</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">filter-in</span><span
                    class="hspace"> </span><span class="RktSym">symbol?</span><span
                    class="hspace">  </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">(</span><span
                    class="RktVal">b</span><span class="hspace"> </span><span class="RktVal">c</span><span
                    class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">17</span><span
                    class="hspace"> </span><span class="RktVal">foo</span><span class="RktVal">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(a<span class="stt"> </span>foo)</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..23)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>
          <span class="stt">(list-index pred lst)</span> 返回 <span class="stt">lst</span>
          中第一个满足谓词 <span class="stt">pred</span>
          的元素位置，
          从零开始计数。如果 <span class="stt">lst</span>
          中没有元素满足谓词，<span
            class="stt">list-index</span> 返回 <span class="stt">#f</span>。</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">list-index</span><span class="hspace"> </span><span
                    class="RktSym">number?</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">(</span><span class="RktVal">a</span><span class="hspace"> </span><span
                    class="RktVal">2</span><span class="hspace"> </span><span class="RktVal">(</span><span
                    class="RktVal">1</span><span class="hspace"> </span><span class="RktVal">3</span><span
                    class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">b</span><span
                    class="hspace"> </span><span class="RktVal">7</span><span class="RktVal">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">1</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">list-index</span><span class="hspace"> </span><span
                    class="RktSym">symbol?</span><span class="hspace">  </span><span
                    class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">a</span><span
                    class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">b</span><span
                    class="hspace"> </span><span class="RktVal">c</span><span class="RktVal">)</span><span
                    class="hspace"> </span><span class="RktVal">17</span><span class="hspace"> </span><span
                    class="RktVal">foo</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">0</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span
                    class="RktSym">list-index</span><span class="hspace"> </span><span
                    class="RktSym">symbol?</span><span class="hspace">  </span><span
                    class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span
                    class="hspace"> </span><span class="RktVal">2</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">a</span><span class="hspace"> </span><span
                    class="RktVal">b</span><span class="RktVal">)</span><span class="hspace"> </span><span
                    class="RktVal">3</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">#f</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..24)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>
          若 <span class="stt">lst</span> 中的任何元素不满足
          <span class="stt">pred</span>，<span class="stt">(every? pred lst)</span> 返回 <span
            class="stt">#f</span>，
          否则返回 <span class="stt">#t</span>。</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">every?</span><span
                    class="hspace"> </span><span class="RktSym">number?</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">b</span><span
                    class="hspace"> </span><span class="RktVal">c</span><span class="hspace"> </span><span
                    class="RktVal">3</span><span class="hspace"> </span><span class="RktVal">e</span><span
                    class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">#f</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">every?</span><span
                    class="hspace"> </span><span class="RktSym">number?</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">1</span><span class="hspace"> </span><span class="RktVal">2</span><span
                    class="hspace"> </span><span class="RktVal">3</span><span class="hspace"> </span><span
                    class="RktVal">4</span><span class="hspace"> </span><span class="RktVal">5</span><span
                    class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">#t</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..25)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>
          若 <span class="stt">lst</span> 中的任何元素满足 <span
            class="stt">pred</span>，<span class="stt">(exists? pred lst)</span> 返回 <span
            class="stt">#t</span>，否则返回 <span class="stt">#f</span>。</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">exists?</span><span
                    class="hspace"> </span><span class="RktSym">number?</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">b</span><span
                    class="hspace"> </span><span class="RktVal">c</span><span class="hspace"> </span><span
                    class="RktVal">3</span><span class="hspace"> </span><span class="RktVal">e</span><span
                    class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">#t</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">exists?</span><span
                    class="hspace"> </span><span class="RktSym">number?</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">b</span><span
                    class="hspace"> </span><span class="RktVal">c</span><span class="hspace"> </span><span
                    class="RktVal">d</span><span class="hspace"> </span><span class="RktVal">e</span><span
                    class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">#f</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..26)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>
          <span class="stt">(up lst)</span> 移除 <span class="stt">lst</span>
          中每个顶层元素周围的一对括号。如果顶层元素不是列表，
          则照原样放入结果中。<span class="stt">(up (down
            lst))</span> 的结果与 <span class="stt">lst</span> 相同，但
          <span class="stt">(down
            (up lst))</span> 不一定是 <span class="stt">lst</span>（参见<span
            class="EoplExerciseRef"></span>）。</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">up</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">(</span><span class="RktVal">1</span><span class="hspace"> </span><span
                    class="RktVal">2</span><span class="RktVal">)</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">3</span><span class="hspace"> </span><span
                    class="RktVal">4</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(1<span class="stt"> </span>2<span class="stt"> </span>3<span class="stt">
                      </span>4)</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">up</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">(</span><span class="RktVal">x</span><span class="hspace"> </span><span
                    class="RktVal">(</span><span class="RktVal">y</span><span class="RktVal">)</span><span
                    class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">z</span><span
                    class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(x<span class="stt"> </span>(y)<span class="stt"> </span>z)</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..27)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._162))"></a>
          <span class="stt">(flatten slist)</span> 返回一列表，由 <span
            class="stt">slist</span>
          中的符号按出现顺序组成。直观上，
          <span class="stt">flatten</span>
          移除参数内的所有内层括号。
        </p>
        <p>
        <div class="SIntrapara">
          <blockquote class="EoplCodeInset">
            <p>
            <div class="SIntrapara">
              <blockquote class="SCodeFlow">
                <table cellspacing="0" cellpadding="0" class="RktBlk">
                  <tr>
                    <td><span class="stt">> </span><span class="RktPn">(</span><span
                        class="RktSym">flatten</span><span class="hspace"> </span><span
                        class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">a</span><span
                        class="hspace"> </span><span class="RktVal">b</span><span class="hspace"> </span><span
                        class="RktVal">c</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
                  </tr>
                  <tr>
                    <td>
                      <p><span class="RktRes">'(a<span class="stt"> </span>b<span class="stt"> </span>c)</span></p>
                    </td>
                  </tr>
                  <tr>
                    <td><span class="stt">> </span><span class="RktPn">(</span><span
                        class="RktSym">flatten</span><span class="hspace"> </span><span
                        class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span
                        class="RktVal">a</span><span class="RktVal">)</span><span class="hspace"> </span><span
                        class="RktVal">(</span><span class="RktVal">)</span><span class="hspace"> </span><span
                        class="RktVal">(</span><span class="RktVal">b</span><span class="hspace"> </span><span
                        class="RktVal">(</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                        class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">)</span><span
                        class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">c</span><span
                        class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
                  </tr>
                  <tr>
                    <td>
                      <p><span class="RktRes">'(a<span class="stt"> </span>b<span class="stt"> </span>c)</span></p>
                    </td>
                  </tr>
                  <tr>
                    <td><span class="stt">> </span><span class="RktPn">(</span><span
                        class="RktSym">flatten</span><span class="hspace"> </span><span
                        class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">(</span><span
                        class="RktVal">a</span><span class="hspace"> </span><span class="RktVal">b</span><span
                        class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">c</span><span
                        class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">(</span><span
                        class="RktVal">(</span><span class="RktVal">d</span><span class="RktVal">)</span><span
                        class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">e</span><span
                        class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
                  </tr>
                  <tr>
                    <td>
                      <p><span class="RktRes">'(a<span class="stt"> </span>b<span class="stt"> </span>c<span
                            class="stt"> </span>d<span class="stt"> </span>e)</span></p>
                    </td>
                  </tr>
                  <tr>
                    <td><span class="stt">> </span><span class="RktPn">(</span><span
                        class="RktSym">flatten</span><span class="hspace"> </span><span
                        class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">a</span><span
                        class="hspace"> </span><span class="RktVal">b</span><span class="hspace"> </span><span
                        class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">)</span><span
                        class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">c</span><span
                        class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                        class="RktPn">)</span></td>
                  </tr>
                  <tr>
                    <td>
                      <p><span class="RktRes">'(a<span class="stt"> </span>b<span class="stt"> </span>c)</span></p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </div>
            <div class="SIntrapara"><a name="(idx._(gentag._163))"></a></div>
            </p>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._164))"></a></div>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..28)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span> <a
            name="(idx._(gentag._165))"></a>
          <span class="stt">loi1</span> 和 <span class="stt">loi2</span>
          是元素按照升序排列的整数列表，<span
            class="stt">(merge loi1 loi2)</span> 返
          回 <span class="stt">loi1</span> 和 <span class="stt">loi2</span>
          中所有整数组成的的有序列表。
        </p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">merge</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">1</span><span class="hspace"> </span><span class="RktVal">4</span><span
                    class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">(</span><span class="RktVal">1</span><span class="hspace"> </span><span
                    class="RktVal">2</span><span class="hspace"> </span><span class="RktVal">8</span><span
                    class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(1<span class="stt"> </span>1<span class="stt"> </span>2<span class="stt">
                      </span>4<span class="stt"> </span>8)</span></p>
                </td>
              </tr>
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">merge</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">35</span><span class="hspace"> </span><span class="RktVal">62</span><span
                    class="hspace"> </span><span class="RktVal">81</span><span class="hspace"> </span><span
                    class="RktVal">90</span><span class="hspace"> </span><span class="RktVal">91</span><span
                    class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">'</span><span
                    class="RktVal">(</span><span class="RktVal">3</span><span class="hspace"> </span><span
                    class="RktVal">83</span><span class="hspace"> </span><span class="RktVal">85</span><span
                    class="hspace"> </span><span class="RktVal">90</span><span class="RktVal">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(3<span class="stt"> </span>35<span class="stt"> </span>62<span class="stt">
                      </span>81<span class="stt"> </span>83<span class="stt"> </span>85<span class="stt"> </span>90<span
                        class="stt"> </span>90<span class="stt"> </span>91)</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..29)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>
          <span class="stt">(sort loi)</span> 返回一列表，将 <span
            class="stt">loi</span>
          中的元素按照升序排列。</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="stt">> </span><span class="RktPn">(</span><span class="RktSym">sort</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                    class="RktVal">8</span><span class="hspace"> </span><span class="RktVal">2</span><span
                    class="hspace"> </span><span class="RktVal">5</span><span class="hspace"> </span><span
                    class="RktVal">2</span><span class="hspace"> </span><span class="RktVal">3</span><span
                    class="RktVal">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(2<span class="stt"> </span>2<span class="stt"> </span>3<span class="stt">
                      </span>5<span class="stt"> </span>8)</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..30)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>
          <span class="stt">(sort/predicate pred loi)</span> 返回一列表，将
          <span class="stt">loi</span>
          的元素按照谓词指定的顺序
          排列。</p>
        <blockquote class="EoplCodeInset">
          <p>
          <div class="SIntrapara">
            <blockquote class="SCodeFlow">
              <table cellspacing="0" cellpadding="0" class="RktBlk">
                <tr>
                  <td><span class="stt">> </span><span class="RktPn">(</span><span
                      class="RktSym">sort/predicate</span><span class="hspace"> </span><span
                      class="RktSym"><</span><span class="hspace"> </span><span class="RktVal">'</span><span
                      class="RktVal">(</span><span class="RktVal">8</span><span class="hspace"> </span><span
                      class="RktVal">2</span><span class="hspace"> </span><span class="RktVal">5</span><span
                      class="hspace"> </span><span class="RktVal">2</span><span class="hspace"> </span><span
                      class="RktVal">3</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td>
                    <p><span class="RktRes">'(2<span class="stt"> </span>2<span class="stt"> </span>3<span class="stt">
                        </span>5<span class="stt"> </span>8)</span></p>
                  </td>
                </tr>
                <tr>
                  <td><span class="stt">> </span><span class="RktPn">(</span><span
                      class="RktSym">sort/predicate</span><span class="hspace"> </span><span
                      class="RktSym">></span><span class="hspace"> </span><span class="RktVal">'</span><span
                      class="RktVal">(</span><span class="RktVal">8</span><span class="hspace"> </span><span
                      class="RktVal">2</span><span class="hspace"> </span><span class="RktVal">5</span><span
                      class="hspace"> </span><span class="RktVal">2</span><span class="hspace"> </span><span
                      class="RktVal">3</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td>
                    <p><span class="RktRes">'(8<span class="stt"> </span>5<span class="stt"> </span>3<span class="stt">
                        </span>2<span class="stt"> </span>2)</span></p>
                  </td>
                </tr>
              </table>
            </blockquote>
          </div>
          <div class="SIntrapara"><a name="(idx._(gentag._166))"></a></div>
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..31)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._167))"></a>
          写出如下过程，对二叉树（<span
            class="EoplDefinitionRef"></span>）做运算：<span class="stt">leaf</span>
          和 <span class="stt">interior-node</span>
          生成二叉树，<span class="stt">leaf?</span>
          检查二叉树是否是一片叶子，<span
            class="stt">lson</span>、<span class="stt">rson</span>和
          <span class="stt">contents-of</span>
          取出一个节点的各部分。<span
            class="stt">contents-of</span>
          应对叶子和内部节点都适
          用。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..32)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写出过程 <span
            class="stt">double-tree</span>，它取一棵二叉树，形如<span
            class="EoplDefinitionRef"></span>，生成另一棵二叉树，把
          原二叉树中的所有整数翻倍。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..33)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._168))"></a>
          写出过程 <span
            class="stt">mark-leaves-with-red-depth</span>，它取一棵二叉树（<span
            class="EoplDefinitionRef"></span>），生成与
          原树形状相同的另一棵二叉树，但在新的二叉树中，每个叶子中的整数表示它和树根之间
          含有 <span class="stt">red</span>
          符号的节点数。例如，表达式</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">mark-leaves-with-red-depth</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">interior-node</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">'</span><span
                    class="RktSym">red</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">interior-node</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">'</span><span class="RktSym">bar</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">   </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">leaf</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">26</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">   </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">leaf</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">12</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">interior-node</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">'</span><span class="RktSym">red</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">   </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">leaf</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">11</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">   </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">interior-node</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">'</span><span class="RktSym">quux</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">leaf</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">117</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">leaf</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">14</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>使用<span class="EoplExerciseRef"></span>
          中定义的过程，应返回二叉树</p>
        <blockquote class="EoplCodeInset">
          <p>
          <div class="SIntrapara">
            <blockquote class="SCodeFlow">
              <table cellspacing="0" cellpadding="0" class="RktBlk">
                <tr>
                  <td><span class="RktPn">(</span><span class="RktSym">red</span><span class="RktMeta"></span></td>
                </tr>
                <tr>
                  <td><span class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktPn">(</span><span class="RktSym">bar</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span class="RktVal">1</span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
                </tr>
                <tr>
                  <td><span class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktPn">(</span><span class="RktSym">red</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span class="RktVal">2</span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktPn">(</span><span class="RktSym">quux</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span class="RktVal">2</span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                      class="RktPn">)</span><span class="RktMeta"></span></td>
                </tr>
              </table>
            </blockquote>
          </div>
          <div class="SIntrapara"><a name="(idx._(gentag._169))"></a></div>
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..34)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span> <a name="(idx._(gentag._170))"></a>
          写出过程 <span
            class="stt">path</span>，它取一个整数 <span class="stt">n</span>
          和一棵含有整数 <span class="stt">n</span>
          的二叉搜索树
          （<span class="stt">bst</span>）<span class="stt">bst</span>，返回由 <span
            class="stt">left</span> 和 <span class="stt">right</span>
          组成的列表，表示如何
          找到包含 <span class="stt">n</span>
          的节点。如果在树根处发现 <span
            class="stt">n</span>，它返回空列表。</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td>
                  <table cellspacing="0" cellpadding="0" class="RktBlk">
                    <tr>
                      <td><span class="stt">> </span><span class="RktPn">(</span><span
                          class="RktSym">path</span><span class="hspace"> </span><span
                          class="RktVal">17</span><span class="hspace"> </span><span class="RktVal">'</span><span
                          class="RktVal">(</span><span class="RktVal">14</span><span class="hspace"> </span><span
                          class="RktVal">(</span><span class="RktVal">7</span><span class="hspace"> </span><span
                          class="RktVal">(</span><span class="RktVal">)</span><span class="hspace"> </span><span
                          class="RktVal">(</span><span class="RktVal">12</span><span class="hspace"> </span><span
                          class="RktVal">(</span><span class="RktVal">)</span><span class="hspace"> </span><span
                          class="RktVal">(</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                          class="RktVal">)</span></td>
                    </tr>
                    <tr>
                      <td><span class="hspace">  </span><span
                          class="hspace">              </span><span
                          class="RktVal">(</span><span class="RktVal">26</span><span class="hspace"> </span><span
                          class="RktVal">(</span><span class="RktVal">20</span><span class="hspace"> </span><span
                          class="RktVal">(</span><span class="RktVal">17</span><span class="hspace"> </span><span
                          class="RktVal">(</span><span class="RktVal">)</span><span class="hspace"> </span><span
                          class="RktVal">(</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
                    </tr>
                    <tr>
                      <td><span class="hspace">  </span><span
                          class="hspace">                      </span><span
                          class="RktVal">(</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
                    </tr>
                    <tr>
                      <td><span class="hspace">  </span><span
                          class="hspace">                  </span><span
                          class="RktVal">(</span><span class="RktVal">31</span><span class="hspace"> </span><span
                          class="RktVal">(</span><span class="RktVal">)</span><span class="hspace"> </span><span
                          class="RktVal">(</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                          class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
                    </tr>
                  </table>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="RktRes">'(right<span class="stt"> </span>left<span class="stt"> </span>left)</span>
                  </p>
                </td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..35)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._171))"></a>
          写出过程 <span
            class="stt">number-leaves</span>，它取一棵二叉树，生成与原树形状相同的二叉树，但叶子
          的内容从 0
          开始计的整数。例如，</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">number-leaves</span><span class="RktMeta"></span>
                </td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">interior-node</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">'</span><span
                    class="RktSym">foo</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">interior-node</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">'</span><span class="RktSym">bar</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">   </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">leaf</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">26</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">   </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">leaf</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">12</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">interior-node</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">'</span><span class="RktSym">baz</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">   </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">leaf</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">11</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">   </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">interior-node</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">'</span><span class="RktSym">quux</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">leaf</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">117</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">leaf</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">14</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>应返回</p>
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">foo</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">bar</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktVal">0</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">baz</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktVal">2</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">quux</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktVal">3</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex1..36)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._172))"></a>
          写出过程 <span class="stt">g</span>，则<span
            class="stt">n-e</span>的 <span class="stt">number-elements</span>
          可以定义为：</p>
        <blockquote class="EoplCodeInset">
          <p>
          <div class="SIntrapara">
            <blockquote class="SCodeFlow">
              <table cellspacing="0" cellpadding="0" class="RktBlk">
                <tr>
                  <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktSym">number-elements</span><span class="RktMeta"></span></td>
                </tr>
                <tr>
                  <td><span class="RktMeta"></span><span class="hspace">  </span><span
                      class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktPn">(</span><span class="RktSym">lst</span><span class="RktPn">)</span><span
                      class="RktMeta"></span></td>
                </tr>
                <tr>
                  <td><span class="RktMeta"></span><span class="hspace">    </span><span
                      class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">if</span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktPn">(</span><span class="RktSym">null?</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">lst</span><span
                      class="RktPn">)</span><span class="RktMeta"></span><span class="hspace"> </span><span
                      class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span
                      class="RktPn">)</span><span class="RktMeta"></span></td>
                </tr>
                <tr>
                  <td><span class="RktMeta"></span><span
                      class="hspace">        </span><span
                      class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">g</span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktPn">(</span><span class="RktSym">list</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span class="RktVal">0</span><span
                      class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                      class="RktPn">(</span><span class="RktSym">car</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">lst</span><span
                      class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
                </tr>
                <tr>
                  <td><span class="RktMeta"></span><span
                      class="hspace">           </span><span
                      class="RktMeta"></span><span class="RktPn">(</span><span
                      class="RktSym">number-elements</span><span class="RktMeta"></span><span
                      class="hspace"> </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                      class="RktSym">cdr</span><span class="RktMeta"></span><span class="hspace"> </span><span
                      class="RktMeta"></span><span class="RktSym">lst</span><span class="RktPn">)</span><span
                      class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                      class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
                </tr>
              </table>
            </blockquote>
          </div>
          <div class="SIntrapara"><a name="(idx._(gentag._173))"></a>
            <a name="(idx._(gentag._174))"></a>
          </div>
          </p>
        </blockquote>
      </blockquote>
      <div class="navsetbottom"><span class="navleft">
          <div class="nosearchform"></div>  <span class="tocsettoggle">  <a
              href="javascript:void(0);" title="show/hide table of contents"
              onclick="TocsetToggle();">contents</a></span>
        </span><span class="navright">  <a href="awk.html" title="backward to "致谢""
            data-pltdoc="x">← prev</a>  <a href="index.html" title="up to "编程语言要素""
            data-pltdoc="x">up</a>  <a href="da.html" title="forward to "2 数据抽象""
            data-pltdoc="x">next →</a></span> </div>
    </div>
  </div>
  <div id="contextindicator"> </div>
</body>

</html>