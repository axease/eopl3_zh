<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=0.8" />
  <title>9 对象和类</title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default" />
  <link rel="stylesheet" type="text/css" href="footnote.css" title="default" />
  <link rel="stylesheet" type="text/css" href="racket.css" title="default" />
  <script type="text/javascript" src="scribble-common.js"></script>
  <script src="katex/katex.min.js"></script>
  <script src="onload.js"></script>

</head>

<body id="scribble-racket-lang-org">
  <div class="tocset">
    <div class="tocview">
      <div class="tocviewlist tocviewlisttopspace">
        <div class="tocviewtitle">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle"
                  onclick="TocviewToggle(this," tocview_0");">▼</a></td>
              <td></td>
              <td><a href="index.html" class="tocviewlink" data-pltdoc="x">编程语言要素</a></td>
            </tr>
          </table>
        </div>
        <div class="tocviewsublisttop" style="display: block;" id="tocview_0">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td align="right"></td>
              <td><a href="fw-trans.html" class="tocviewlink" data-pltdoc="x">译者的话</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="glo.html" class="tocviewlink" data-pltdoc="x">译名表</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="fw.html" class="tocviewlink" data-pltdoc="x">序</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="pf.html" class="tocviewlink" data-pltdoc="x">前言</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="awk.html" class="tocviewlink" data-pltdoc="x">致谢</a></td>
            </tr>
            <tr>
              <td align="right">1 </td>
              <td><a href="isd.html" class="tocviewlink" data-pltdoc="x">归纳式数据集</a></td>
            </tr>
            <tr>
              <td align="right">2 </td>
              <td><a href="da.html" class="tocviewlink" data-pltdoc="x">数据抽象</a></td>
            </tr>
            <tr>
              <td align="right">3 </td>
              <td><a href="expr.html" class="tocviewlink" data-pltdoc="x">表达式</a></td>
            </tr>
            <tr>
              <td align="right">4 </td>
              <td><a href="state.html" class="tocviewlink" data-pltdoc="x">状态</a></td>
            </tr>
            <tr>
              <td align="right">5 </td>
              <td><a href="cpi.html" class="tocviewlink" data-pltdoc="x">传递续文的解释器</a></td>
            </tr>
            <tr>
              <td align="right">6 </td>
              <td><a href="cps.html" class="tocviewlink" data-pltdoc="x">续文传递风格</a></td>
            </tr>
            <tr>
              <td align="right">7 </td>
              <td><a href="types.html" class="tocviewlink" data-pltdoc="x">类型</a></td>
            </tr>
            <tr>
              <td align="right">8 </td>
              <td><a href="modules.html" class="tocviewlink" data-pltdoc="x">模块</a></td>
            </tr>
            <tr>
              <td align="right">9 </td>
              <td><a href="" class="tocviewselflink" data-pltdoc="x">对象和类</a></td>
            </tr>
            <tr>
              <td align="right">10 </td>
              <td><a href="further-reading.html" class="tocviewlink" data-pltdoc="x">扩展阅读</a></td>
            </tr>
            <tr>
              <td align="right">11 </td>
              <td><a href="sllgen-parsing-system.html" class="tocviewlink" data-pltdoc="x">SLLGEN解析系统</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="bib.html" class="tocviewlink" data-pltdoc="x">参考书目</a></td>
            </tr>
            <tr>
              <td align="right"></td>
              <td><a href="indices.html" class="tocviewlink" data-pltdoc="x">索引</a></td>
            </tr>
          </table>
        </div>
      </div>
      <div class="tocviewlist">
        <table cellspacing="0" cellpadding="0">
          <tr>
            <td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle"
                onclick="TocviewToggle(this," tocview_1");">►</a></td>
            <td>9 </td>
            <td><a href="" class="tocviewselflink" data-pltdoc="x">对象和类</a></td>
          </tr>
        </table>
        <div class="tocviewsublistbottom" style="display: none;" id="tocview_1">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td align="right">9.1 </td>
              <td><a href="#%28part._s9..1%29" class="tocviewlink" data-pltdoc="x">面向对象编程</a></td>
            </tr>
            <tr>
              <td align="right">9.2 </td>
              <td><a href="#%28part._s9..2%29" class="tocviewlink" data-pltdoc="x">继承</a></td>
            </tr>
            <tr>
              <td align="right">9.3 </td>
              <td><a href="#%28part._s9..3%29" class="tocviewlink" data-pltdoc="x">语言</a></td>
            </tr>
            <tr>
              <td align="right">9.4 </td>
              <td><a href="#%28part._s9..4%29" class="tocviewlink" data-pltdoc="x">解释器</a></td>
            </tr>
            <tr>
              <td align="right">9.5 </td>
              <td><a href="#%28part._s9..5%29" class="tocviewlink" data-pltdoc="x">带有类型的语言</a></td>
            </tr>
            <tr>
              <td align="right">9.6 </td>
              <td><a href="#%28part._s9..6%29" class="tocviewlink" data-pltdoc="x">类型检查器</a></td>
            </tr>
          </table>
        </div>
      </div>
    </div>
    <div class="tocsub">
      <div class="tocsubtitle">On this page:</div>
      <table class="tocsublist" cellspacing="0">
        <tr>
          <td><span class="tocsublinknumber">9.1<tt> </tt></span><a href="#%28part._s9..1%29" class="tocsubseclink"
              data-pltdoc="x">面向对象编程</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">9.2<tt> </tt></span><a href="#%28part._s9..2%29" class="tocsubseclink"
              data-pltdoc="x">继承</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">9.3<tt> </tt></span><a href="#%28part._s9..3%29" class="tocsubseclink"
              data-pltdoc="x">语言</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">9.4<tt> </tt></span><a href="#%28part._s9..4%29" class="tocsubseclink"
              data-pltdoc="x">解释器</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">9.4.1<tt> </tt></span><a href="#%28part._s9..4..1%29" class="tocsubseclink"
              data-pltdoc="x">对象</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">9.4.2<tt> </tt></span><a href="#%28part._s9..4..2%29" class="tocsubseclink"
              data-pltdoc="x">方法</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">9.4.3<tt> </tt></span><a href="#%28part._s9..4..3%29" class="tocsubseclink"
              data-pltdoc="x">类和类环境</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">9.4.4<tt> </tt></span><a href="#%28part._s9..4..4%29" class="tocsubseclink"
              data-pltdoc="x">方法环境</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">9.4.5<tt> </tt></span><a href="#%28part._s9..4..5%29" class="tocsubseclink"
              data-pltdoc="x">练习</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">9.5<tt> </tt></span><a href="#%28part._s9..5%29" class="tocsubseclink"
              data-pltdoc="x">带有类型的语言</a></td>
        </tr>
        <tr>
          <td><span class="tocsublinknumber">9.6<tt> </tt></span><a href="#%28part._s9..6%29" class="tocsubseclink"
              data-pltdoc="x">类型检查器</a></td>
        </tr>
      </table>
    </div>
  </div>
  <div class="maincolumn">
    <div class="main">
      <div class="navsettop"><span class="navleft">
          <div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);"
              title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
        </span><span class="navright">  <a href="modules.html" title="backward to " 8 模块"" data-pltdoc="x">←
            prev</a>  <a href="index.html" title="up to " 编程语言要素"" data-pltdoc="x">up</a>  <a
            href="further-reading.html" title="forward to " 10 扩展阅读"" data-pltdoc="x">next →</a></span> </div>
      <h3>9<tt> </tt><a name="(part._oac)"></a>对象和类</h3>
      <p><a name="(idx._(gentag._1301))"></a>
        在许多编程工作中，程序都要用接口管理某些状态。例如，文件系统内部状态的访问和修改
        只能通过系统的接口。状态常常涉及多个变量，为了维护状态的一致性，必须协同修改那些
        变量。因此，我们需要某种技术，确保组成状态的多个变量能协同更新。
        <span class="emph">面向对象编程</span> (<span class="emph">Object-oriented programming</span>) 技术正是为了完成这一任务。
      </p>
      <p><a name="(idx._(gentag._1302))"></a>
        <a name="(idx._(gentag._1303))"></a>
        <a name="(idx._(gentag._1304))"></a>
        <a name="(idx._(gentag._1305))"></a>
        在面向对象编程中，每个受管理的状态称为一个<span class="emph">对象</span> (<span class="emph">object</span>)。一个对象中存有
        多个量，称为<span class="emph">字段</span> (<span class="emph">field</span>)；有多个相关过程，称为<span class="emph">方法</span>
        (<span class="emph">method</span>)，方
        法能够访问字段。调用方法常被视为将方法名和参数当作消息传给对象；有时，又说这是
        从<span class="emph">消息传递</span> (<span class="emph">message-psasing</span>) 的视角看待面向对象编程。
        <a name="(idx._(gentag._1306))"></a>
      </p>
      <p>在<a href="state.html" data-pltdoc="x">状态</a>那样的有状态语言中，过程也能体现用对象编程的优势。过程是一种对象，
        其状态包含于自由变量之中。闭包只有一种行为：拿参数调用它。例如，
        <span class="stt">g-counter</span>的 <span class="stt">g</span> 控制计数器的状态，此状态的唯一操作就是递增。但更常
        见的是，一个对象具有多种行为。面向对象的编程语言具有这种能力。
      </p>
      <p>一个方法通常需要管理多重状态，例如多个文件系统或程序中的多个队列。为便于方法共享，
        面向对象编程系统通常提供名为<span class="emph">类</span> (<span class="emph">class</span>) 的结构，用来指定某种对象的字段及
        方法。每个对象都创建为类的<span class="emph">实例</span> (<span class="emph">instance</span>)。
        <a name="(idx._(gentag._1307))"></a>
      </p>
      <p><a name="(idx._(gentag._1308))"></a>
        类似地，多个类可能有相似而不相同的字段和方法。为便于共享实现，面向对象编程语言通
        常支持<span class="emph">继承</span> (<span class="emph">inheritance</span>)，允许程序员增改某些方法的行为，添加字段，对现有
        类小做修改，就能定义新类。这时，由于新类的其他行为从原类继承而得，我们说
        新类<span class="emph">继承于</span> (<span class="emph">inherit from</span>) 或<span class="emph">扩展</span> (<span
          class="emph">extend</span>) 旧类。</p>
      <p>不论是用代码建模真实世界中的对象还是人工层面的系统状态，一旦程序能由结合行为和状
        态的对象组成，其结构通常都清晰明了。将行为类似的对象与同一个类关联起来，也是自然
        而然的。</p>
      <p>真实世界中的对象通常兼具<span class="emph">状态</span>和<span class="emph">行为</span>，后者要么控制前者，要么受前者控
        制。例如，猫能吃，打呼噜，跳，躺下，这些活动都由猫当前的状态控制，包括有多饿，有
        多累。</p>
      <p><a name="(idx._(gentag._1309))"></a>
        对象和模块既相似，又不同。模块和类都提供了定义模糊类型的机制，但对象是一种具有行
        为的数据结构，模块只是一组绑定。同一个类可以有很多个对象；大多数模块系统没有提供
        相仿的能力。但 PROC-MODULES 这样的模块系统提供了更为灵活的方式来控制名字的可见性。
        模块和类能够相得益彰。
        <a name="(idx._(gentag._1310))"></a>
        <a name="(idx._(gentag._1311))"></a>
      </p>
      <h4>9.1<tt> </tt><a name="(part._s9..1)"></a>面向对象编程</h4>
      <p>本章，我们研究一种简单的面向对象语言，名为 CLASSES。CLASSES 程序包含一些类声明，
        然后是一个可能用到那些类的表达式。
        <a name="(idx._(gentag._1312))"></a>
        <a name="(idx._(gentag._1313))"></a>
      </p>
      <p><a name="(idx._(gentag._1314))"></a>
        <span class="EoplFigureRef"></span> 展示了用这种语言写成的简单程序。它定义了继承于 <span class="stt">object</span>
        的类 <span class="stt">c1</span>。类 <span class="stt">c1</span> 的每个对象都包含两个字段，名为 <span class="stt">i</span> 和 <span
          class="stt">j</span>。
        <a name="(idx._(gentag._1315))"></a>
        <a name="(idx._(gentag._1316))"></a>
        <a name="(idx._(gentag._1317))"></a>
        字段叫做<span class="emph">成员</span> (<span class="emph">member</span>) 或<span class="emph">实例变量</span> (<span
          class="emph">instance variable</span>)。类 <span class="stt">c1</span>
        支持三个<span class="emph">方法</span>或<span class="emph">成员函数</span> (<span class="emph">member function</span>)，名为
        <span class="stt">initialize</span>、
        <span class="stt">countup</span> 和 <span class="stt">getstate</span>。每个方法包含<span class="emph">方法名</span> (<span
          class="emph">method name</span>)，
        若干<span class="emph">方法变量</span> (<span class="emph">method var</span>)（又称<span class="emph">方法参数</span> (<span
          class="emph">method parameters</span>)），
        以及<span class="emph">方法主体</span> (<span class="emph">method body</span>)。<a
          name="(idx._(gentag._1318))"></a>方法名对应 <span class="stt">c1</span> 实例能够响应的<span
          class="emph">消息</span>种类。有时，我们称之为
        “<span class="stt">c1</span> 的方法 <span class="stt">countup</span>”。
        <a name="(idx._(gentag._1319))"></a>
        <a name="(idx._(gentag._1320))"></a>
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">class c1 extends object</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field i</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field j</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize
                      (x)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set i = x;</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set j = -(0,x)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method countup (d)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set i = +(i,d);</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set j = -(j,d)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method getstate ()
                      list(i,j)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let t1 = 0</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">t2 = 0</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">o1 = new c1(3)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">set t1 = send o1
                      getstate();</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">send o1
                      countup(2);</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">set t2 = send o1
                      getstate();</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">list(t1,t2)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">end</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>简单的面向对象程序<a name="(elem._fig-9..1)"></a></p>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._1321))"></a>
        <a name="(idx._(gentag._1322))"></a>
        本例中，类的每个方法都维护完整性约束或<span class="emph">不变式</span> <span class="texMathInline">i = -j</span>。当然，真实程序的
        完整性约束可能复杂得多。
      </p>
      <p><span class="EoplFigureRef"></span> 中的程序首先初始化三个变量。<span class="stt">t1</span> 和 <span class="stt">t2</span>
        初始化为 0。
        <span class="stt">o1</span> 初始化为类 <span class="stt">c1</span> 的一个对象。我们说这个对象是类 <span class="stt">c1</span>
        的一个<span class="emph">实
          例</span>。对象通过 <span class="stt">new</span> 操作创建。它会触发调用类的方法 <span class="stt">initialize</span>，在本例中，
        是将对象的字段 <span class="stt">i</span> 设置为 3，字段 <span class="stt">j</span> 设置为 -3。然后，程序调用 <span
          class="stt">o1</span> 的
        方法 <span class="stt">getstate</span>，返回列表 <span class="stt">(3 -3)</span>。接着，它调用 <span class="stt">o1</span> 的方法
        <span class="stt">countup</span>，将两个字段的值改为 5 和 -5，然后再次调用 <span class="stt">getstate</span>，返回
        <span class="stt">(5 -5)</span>。最后，值 <span class="stt">list(t1,t2)</span>，即 <span class="stt">((3 -3) (5
          -5))</span>，成为整段程序的
        返回值。
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">class interior-node extends object</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field left</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field right</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize (l,
                      r)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set left = l;</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set right = r</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method sum () +(send left
                      sum(),send right sum())</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">class leaf-node extends object</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field value</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize (v) set
                      value = v</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method sum () value</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let o1 = new interior-node(</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">          </span><span class="stt">new
                      interior-node(</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">           </span><span class="stt">new
                      leaf-node(3),</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">           </span><span class="stt">new
                      leaf-node(4)),</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">          </span><span class="stt">new
                      leaf-node(5))</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in send o1 sum()</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>求树叶之和的面向对象程序<a name="(elem._fig-9..2)"></a></p>
        </blockquote>
      </blockquote>
      <p><span class="EoplFigureRef"></span> 解释了面向对象编程中的关键思想：<span class="emph">动态分发</span> (<span class="emph">dynamic
          dispatch</span>)。在这段程序中，树有两种节点，<span class="stt">interior-node</span> 和
        <span class="stt">leaf-node</span>。通常，我们不知道是在给哪种节点发送消息。相反，每个节点接收
        <span class="stt">sum</span> 消息，并用自身的 <span class="stt">sum</span> 方法做适当操作。这叫做<span class="emph">动态分发</span>。这里，
        表达式生成一棵树，有两个内部节点，三个叶节点。它将 <span class="stt">sum</span> 消息发给节点 <span class="stt">o1</span>；
        <span class="stt">o1</span> 将 <span class="stt">sum</span> 消息发给子树，依此类推，最终返回 12。这段程序也表明：所有方
        法都是互递归的。
      </p>
      <p><a name="(idx._(gentag._1323))"></a>
        方法主体可通过标识符 <span class="stt">self</span>（有时叫做 <span class="stt">this</span>）调用同一对象的其他方法，
        <span class="stt">self</span> 总是绑定于方法调用时的对象。例如，在
      </p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">class oddeven extends object</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize () 1</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method even (n)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">if zero?(n) then 1 else send
                    self odd(-(n,1))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method odd (n)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">if zero?(n) then 0 else send
                    self even(-(n,1))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">let o1 = new oddeven()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in send o1 odd(13)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>中，方法 <span class="stt">even</span> 和 <span class="stt">odd</span> 递归调用彼此，因为它们执行时，<span
            class="stt">self</span> 绑定到包
          含二者的对象。这就像<span class="EoplExerciseRef"></span> 中，用动态绑定实现递归。
          <a name="(idx._(gentag._1324))"></a>
        </p>
      </blockquote>
      <h4>9.2<tt> </tt><a name="(part._s9..2)"></a>继承</h4>
      <p><a name="(idx._(gentag._1325))"></a>
        通过继承，程序员能够渐进地修改旧类，得到新类。在实践中，这十分有用。
        例如<span class="EoplFigureRef"></span> 中的经典例子：有色点与点类似，但多了处理颜色的方法。</p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">class point extends object</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field x</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field y</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize (initx,
                      inity)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set x = initx;</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set y = inity</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method move (dx, dy)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set x = +(x,dx);</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set y = +(y,dy)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method get-location ()
                      list(x,y)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">class colorpoint extends point</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field color</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method set-color (c) set
                      color = c</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method get-color ()
                      color</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let p = new point(3,4)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">cp = new colorpoint(10,
                      20)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">send p move(3,4);</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">send cp
                      set-color(87);</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">send cp
                      move(10,20);</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">list(send p
                      get-location(),</span><span class="hspace">   </span><span class="stt">% </span><span
                      class="emph">返回</span><span class="stt"></span><span class="hspace"> </span><span class="stt">(6
                      8)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">         </span><span class="stt">send cp
                      get-location(),</span><span class="hspace">  </span><span class="stt">% </span><span
                      class="emph">返回</span><span class="stt"></span><span class="hspace"> </span><span class="stt">(20
                      40)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">         </span><span class="stt">send cp
                      get-color())</span><span class="hspace">     </span><span class="stt">% </span><span
                      class="emph">返回</span><span class="stt"></span><span class="hspace"> </span><span
                      class="stt">87</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">end</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>继承的经典例子：<span class="stt">colorpoint</span><a name="(elem._fig-9..3)"></a></p>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._1326))"></a>
        <a name="(idx._(gentag._1327))"></a>
        <a name="(idx._(gentag._1328))"></a>
        如果类 <span class="texMathInline">c_2</span> 扩展类 <span class="texMathInline">c_1</span>，我们说 <span
          class="texMathInline">c_1</span> 是 <span class="texMathInline">c_2</span> 的<span class="emph">父类</span> (<span
          class="emph">parent</span>)
        <a name="(idx._(gentag._1329))"></a>
        <a name="(idx._(gentag._1330))"></a>
        或<span class="emph">超类</span> (<span class="emph">superclass</span>)，<span class="texMathInline">c_2</span> 是
        <span class="texMathInline">c_1</span> 的<span class="emph">子类</span> (<span class="emph">child</span>)。在继承中，
        由于 <span class="texMathInline">c_2</span> 定义为 <span class="texMathInline">c_1</span> 的扩展，所以 <span
          class="texMathInline">c_1</span> 必须在 <span class="texMathInline">c_2</span> 之前定义。作为起始，
        语言还包含一个预先定义的类，名为 <span class="stt">object</span>，它没有任何方法或字段。由于类
        <span class="stt">object</span> 没有 <span class="stt">initialize</span> 方法，因此无法用它创建对象。除 <span
          class="stt">object</span> 之外
        的所有类都有唯一父类，但可以有多个子类。因此，由 <span class="stt">extends</span> 得出的关系在类与类
        之间产生了树状结构，根为 <span class="stt">object</span>。因为每个类至多只有一个直接超类，这是一种
        <span class="emph">单继承</span> (<span class="emph">single-inheritance</span>) 语言。有些语言允许类继承自多个
        超类。<span class="emph">多继承</span> (<span class="emph">multiple inheritance</span>) 虽然强大，却不无问题。在练习中，我们
        会看到一些不便之处。
        <a name="(idx._(gentag._1331))"></a>
        <a name="(idx._(gentag._1332))"></a>
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><a name="(elem._field-shadowing)"></a><span class="stt">class c1 extends object</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field x</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field y</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize ()
                      1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method setx1 (v) set x =
                      v</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method sety1 (v) set y =
                      v</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method getx1 () x</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method gety1 () y</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">class c2 extends c1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field y</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method sety2 (v) set y =
                      v</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method getx2 () x</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method gety2 () y</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let o2 = new c2()</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">send o2
                      setx1(101);</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">send o2
                      sety1(102);</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">send o2
                      sety2(999);</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">    </span><span class="stt">list(send o2
                      getx1(),</span><span class="hspace">  </span><span class="stt">% </span><span
                      class="emph">返回</span><span class="stt"></span><span class="hspace"> </span><span
                      class="stt">101</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">         </span><span class="stt">send o2
                      gety1(),</span><span class="hspace">  </span><span class="stt">% </span><span
                      class="emph">返回</span><span class="stt"></span><span class="hspace"> </span><span
                      class="stt">102</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">         </span><span class="stt">send o2
                      getx2(),</span><span class="hspace">  </span><span class="stt">% </span><span
                      class="emph">返回</span><span class="stt"></span><span class="hspace"> </span><span
                      class="stt">101</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">         </span><span class="stt">send o2
                      gety2())</span><span class="hspace">  </span><span class="stt">% </span><span
                      class="emph">返回</span><span class="stt"></span><span class="hspace"> </span><span
                      class="stt">999</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">end</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>字段遮蔽的例子<a name="(elem._fig-9..4)"></a></p>
        </blockquote>
      </blockquote>
      <p>术语<span class="emph">继承</span>源于宗谱的类比。我们常常引申这一类比，说类的<span class="emph">祖
          先</span> (<span class="emph">ancestor</span>)<a name="(idx._(gentag._1333))"></a>（从类的父类到根类 <span
          class="stt">object</span>）
        <a name="(idx._(gentag._1334))"></a>
        和<span class="emph">后代</span> (<span class="emph">descendant</span>)。如果 <span class="texMathInline">c_2</span> 是
        <span class="texMathInline">c_1</span> 的后代，可以说 <span class="texMathInline">c_2</span> 是
        <span class="texMathInline">c_1</span> 的<span class="emph">子类</span> (<span class="emph">subclass</span>)，写作
        <span class="texMathInline">c_2 < c_1</span>。
            <a name="(idx._(gentag._1335))"></a>
            <a name="(idx._(gentag._1336))"></a>
      </p>
      <p>如果类 <span class="texMathInline">c_2</span> 继承自 <span class="texMathInline">c_1</span>，除非在 <span
          class="texMathInline">c_2</span> 中重新声明，<span class="texMathInline">c_1</span> 的所有字段和方
        法都对 <span class="texMathInline">c_2</span> 的方法可见。由于一个类继承了父类的所有方法和字段，任何能够使用父
        类实例的地方都可以使用子类实例。类似地，任何能够使用类实例的地方都可以使用其后代
        的实例。有时，这叫做<span class="emph">子类多态</span> (<span class="emph">subclass polymorphism</span>)。我们的语言选择这种
        设计，其他面向对象语言可能选择不同的可见性规则。<a name="(idx._(gentag._1337))"></a>
        <a name="(idx._(gentag._1338))"></a>
      </p>
      <p>接下来，我们考虑重新声明类的字段或方法时会发生什么。如果 <span class="texMathInline">c_1</span> 的某个字段在某
        个子类 <span class="texMathInline">c_2</span> 中重新声明，新的声明<span class="emph">遮蔽</span> (<span
          class="emph">shadow</span>) 旧的，就像词法定界一样。
        <a name="(idx._(gentag._1339))"></a>
        例如<span class="EoplFigureRef"></span>。类 <span class="stt">c2</span> 的对象有两个名为 <span class="stt">y</span>
        的字段：<span class="stt">c1</span> 中
        声明的和 <span class="stt">c2</span> 中声明的。<span class="stt">c1</span> 中声明的方法能看到 <span class="stt">c1</span> 的字段
        <span class="stt">x</span> 和
        <span class="stt">y</span>。在 <span class="stt">c2</span> 中，<span class="stt">getx2</span> 中的 <span
          class="stt">x</span> 指代 <span class="stt">c1</span> 的字段 <span class="stt">x</span>，但
        <span class="stt">gety2</span> 中的 <span class="stt">y</span> 指代 <span class="stt">c2</span> 的字段 <span
          class="stt">y</span>。
      </p>
      <p>如果类 <span class="texMathInline">c_1</span> 的方法 <span class="texMathInline">m</span> 在某个子类 <span
          class="texMathInline">c_2</span> 中重新声明，我们说新的
        方法<span class="emph">覆盖</span> (<span class="emph">override</span>) 旧的方法。我们将方法声明所在的类称为方法
        的<span class="emph">持有类</span> (<span class="emph">host class</span>)。
        <a name="(idx._(gentag._1340))"></a>
        <a name="(idx._(gentag._1341))"></a>
        <a name="(idx._(gentag._1342))"></a>
        类似地，我们将表达式的持有类定义为表达式所在方法（如果有的话）的持有类。我们还将
        方法或表达式的超类定义为持有类的父类。
        <a name="(idx._(gentag._1343))"></a>
        <a name="(idx._(gentag._1344))"></a>
      </p>
      <p>如果给类 <span class="texMathInline">c_2</span> 的对象发送消息 <span class="texMathInline">m</span>，应使用新的方法。这条规则很简单，结果却不
        简单。考虑下面的例子：</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">class c1 extends object</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize () 1</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m1 () 11</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m2 () send self
                    m1()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">class c2 extends c1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m1 () 22</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">let o1 = new c1() o2 = new c2()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in list(send o1 m1(), send o2 m1(), send o2 m2())</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>我们希望 <span class="stt">send o1 m1()</span> 返回 11，因为 <span class="stt">o1</span> 是 <span class="stt">c1</span>
          的实例。同样地，我们
          希望 <span class="stt">send o2 m1()</span> 返回 22，因为 <span class="stt">o2</span> 是 <span class="stt">c2</span>
          的实例。那么 <span class="stt">send o2
            m2()</span> 呢？方法 <span class="stt">m2</span> 直接调用方法 <span class="stt">m1</span>，但它调用的是哪个 <span
            class="stt">m1</span>？</p>
      </blockquote>
      <p><a name="(idx._(gentag._1345))"></a>
        动态分发告诉我们，应查看绑定到 <span class="stt">self</span> 的对象属于哪个类。<span class="stt">self</span> 的值是
        <span class="stt">o2</span>，属于类 <span class="stt">c2</span>。因此，调用 <span class="stt">send self m1()</span> 应返回
        22。
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">class point extends object</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field x</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field y</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize (initx,
                      inity)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set x = initx;</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set y = inity</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">end</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method move (dx, dy)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set x = +(x,dx);</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set y = +(y,dy)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method get-location ()
                      list(x,y)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">class colorpoint extends point</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field color</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize (initx,
                      inity, initcolor)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set x = initx;</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set y = inity;</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set color =
                      initcolor</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method set-color (c) set
                      color = c</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method get-color ()
                      color</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let o1 = new colorpoint(3,4,172)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in send o1 get-color()</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>演示 <span class="stt">super</span> 必要性的例子
            <a name="(idx._(gentag._1346))"></a><a name="(elem._fig-9..5)"></a>
          </p>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._1347))"></a>
        我们的语言还有一个重要特性：<span class="emph">超类调用</span> (<span class="emph">super call</span>)。
        考虑<span class="EoplFigureRef"></span> 中的程序。我们在类 <span class="stt">colorpoint</span> 中重写了
        <span class="stt">initialize</span> 方法，同时设置字段 <span class="stt">x</span>、<span class="stt">y</span> 和 <span
          class="stt">color</span>。但是，新方法的
        主体复制了原方法的代码。在我们的小例子中，这尚可接受，但在大型例子中，这显然是一
        种坏的做法（为什么？）。而且，如果 <span class="stt">colorpoint</span> 声明了字段 <span class="stt">x</span>，就没法初始
        化 <span class="stt">point</span> 的字段 <span class="stt">x</span>，正如<span
          class="stt">field-shadowing</span>的例子中，没法初始化第
        一个 <span class="stt">y</span> 一样。
      </p>
      <p>解决方案是，把 <span class="stt">colorpoint</span> 的 <span class="stt">initialize</span> 方法主体中的重复代码替换
        为<span class="emph">超类调用</span>，形如 <span class="stt">super initialize()</span>。那么 <span
          class="stt">colorpoint</span> 中的
        <span class="stt">initialize</span> 方法写作：
      </p>
      <blockquote class="EoplCodeInset">
        <table cellspacing="0" cellpadding="0" class="SVerbatim">
          <tr>
            <td>
              <p><span class="stt">method initialize (initx, inity, initcolor)</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">begin</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">  </span><span class="stt">super initialize(initx,
                  inity);</span></p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace">  </span><span class="stt">set color = initcolor</span>
              </p>
            </td>
          </tr>
          <tr>
            <td>
              <p><span class="stt"></span><span class="hspace"> </span><span class="stt">end</span></p>
            </td>
          </tr>
        </table>
      </blockquote>
      <p>方法 <span class="texMathInline">m</span> 主体中的超类调用 <span class="stt">super </span><span
          class="texMathInline">n</span><span class="stt">(...)</span> 使用的是 <span class="texMathInline">m</span> 持有类父类的方
        法 <span class="texMathInline">n</span>。这不一定是 <span class="stt">self</span> 所指类的父类。<span class="stt">self</span>
        所指类总是 <span class="texMathInline">m</span> 持有类的
        子类，但不一定是同一个，<span class="NoteBox"><span class="NoteContent">任何类都是自身的子类，故有此说。——<span
              class="emph">译注</span></span></span>因为
        <span class="texMathInline">m</span> 可能在目标对象的某个祖先中声明。
      </p>
      <p>要解释这种区别，考虑<span class="EoplFigureRef"></span>。给类 <span class="stt">c3</span> 的对象 <span class="stt">o3</span>
        发送消息
        <span class="stt">m3</span>，找到的是 <span class="stt">c2</span> 的方法 <span class="stt">m3</span>，它执行 <span
          class="stt">super m1()</span>。<span class="stt">o3</span> 的类是
        <span class="stt">c3</span>，其父类是 <span class="stt">c2</span>，但方法的持有类是 <span class="stt">c2</span>，<span
          class="stt">c2</span> 的超类是 <span class="stt">c1</span>。
        所以，执行的是 <span class="stt">c1</span> 的方法 <span class="stt">m1</span>。这是<span class="emph">静态
          方法分发</span> (<span class="emph">static method dispatch</span>) <a
          name="(idx._(gentag._1348))"></a>的例子。虽然进行超类方法调用的对
        象是 <span class="stt">self</span>，方法分发却是静态的，因为要调用的方法可以从程序文本中推断出来，与
        <span class="stt">self</span> 所指类无关。
      </p>
      <p>本例中，<span class="stt">c1</span> 的方法 <span class="stt">m1</span> 调用 <span class="stt">o3</span> 的方法 <span
          class="stt">m2</span>。这是普通方法调用，所
        以使用动态分发，找出的是 <span class="stt">c3</span> 的方法 <span class="stt">m2</span>，返回 33。
        <a name="(idx._(gentag._1349))"></a>
        <a name="(idx._(gentag._1350))"></a>
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="EoplCodeInset">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">class c1 extends object</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize ()
                      1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m1 () send self
                      m2()</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m2 () 13</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">class c2 extends c1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m1 () 22</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m2 () 23</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m3 () super
                      m1()</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">class c3 extends c2</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m1 () 32</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m2 () 33</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">let o3 = new c3()</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt">in send o3 m3()</span></p>
                </td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>解释 <span class="stt">super</span> 调用与 <span class="stt">self</span> 相互作用的例子
            <a name="(idx._(gentag._1351))"></a>
            <a name="(idx._(gentag._1352))"></a><a name="(elem._fig-9..6)"></a>
          </p>
        </blockquote>
      </blockquote>
      <h4>9.3<tt> </tt><a name="(part._s9..3)"></a>语言</h4>
      <p>我们的语言 CLASSES 由 IMPLICIT-REFS 扩展而得，新增生成式如<span class="EoplFigureRef"></span>
        所示。
        <a name="(idx._(gentag._1353))"></a>
        <a name="(idx._(gentag._1354))"></a>
        程序开头是一些类声明，然后是一个待执行的表达式。类声明有名字，最相近的超类名，0
        或多个字段声明，以及 0 或多个方法声明。方法声明类似 <span class="stt">letrec</span> 中的过程声明，
        <a name="(idx._(gentag._1355))"></a>
        <a name="(idx._(gentag._1356))"></a>
        <a name="(idx._(gentag._1357))"></a>
        <a name="(idx._(gentag._1358))"></a>
        <a name="(idx._(gentag._1359))"></a>
        有名字、形参列表以及主体。同时我们扩展语言，支持多参数过程、多声明 <span class="stt">let</span> 和多
        声明 <span class="stt">letrec</span> 表达式，还有些其他操作，如加法和 <span class="stt">list</span>。
        <a name="(idx._(gentag._1360))"></a>
        列表操作同<span class="EoplExerciseRef"></span>。最后，我们增加 <span class="stt">begin</span> 表达式，
        <a name="(idx._(gentag._1361))"></a>
        同<span class="EoplExerciseRef"></span>，它从左到右求出子表达式的值，返回最后一个表达式的值。
      </p>
      <p>
      <div class="SIntrapara">我们新增对象和列表表达值，于是有
      </div>
      <div class="SIntrapara">
        <blockquote class="Small">
          <p><span class="Iidentity">\begin{align*}\mathit{ExpVal} &= \mathit{Int} + \mathit{Bool} + \mathit{Proc} +
              \mathit{Listof(ExpVal)} + \mathit{Obj}\\
              \mathit{DenVal} &= \mathit{Ref(ExpVal)}\end{align*}</span></p>
        </blockquote>
      </div>
      <div class="SIntrapara">
        <blockquote class="SubFlow">
          <p>我们写 <span class="texMathInline">\mathit{Listof(ExpVal)}</span>，表示列表可以包含任何表达值。</p>
        </blockquote>
      </div>
      </p>
      <p>我们将在<a href="#%28part._s9..4..1%29" data-pltdoc="x">对象</a>考察 <span
          class="texMathInline">\mathit{Obj}</span>。在我们的语言中，类既不是指代值，也
        不是表达值：它们能作为对象的一部分，但不能绑定到变量或是成为表达式的值（但要
        看看<span class="EoplExerciseRef"></span>）。</p>
      <blockquote class="EoplFigure">
        <p>[!ht]
          <span class="Iidentity">\begin{align*} \mathit{Program} &::= \{\mathit{ClassDecl}\}^{*} \phantom{x}
            \mathit{Expression} \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">a-program (class-decls body)</span>} \\[5pt]
            \mathit{ClassDecl} &::= <span class="stt">class </span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> extends </span><span
              class="Iidentity">\mathit{Identifier}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \phantom{x}\{<span class="stt">field </span><span
              class="Iidentity">\mathit{Identifier}</span>\}^{*}\phantom{x}\{\mathit{MethodDecl}\}^{*} \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{\begin{math}\begin{alignedat}{-1}
            &<span class="stt">a-class-decl</span> \\
            &\phantom{x}<span class="stt">(</span><span class="stt">class-name super-name</span> \\
            &\phantom{xx}<span class="stt">field-names method-decls</span><span class="stt">)</span>
            \end{alignedat}\end{math}} \\[5pt]
            \mathit{MethodDecl} &::= <span class="stt">method </span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> (</span><span
              class="Iidentity">\{\mathit{Identifier}\}^{*(,)}</span><span class="stt">) </span><span
              class="Iidentity">\mathit{Expression}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">a-method-decl (method-name vars body)</span>} \\[5pt]
            \mathit{Expression} &::= <span class="stt">new </span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> (</span><span
              class="Iidentity">\{\mathit{Expression}\}^{*(,)}</span><span class="stt">)</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">new-object-exp (class-name rands)</span>} \\[5pt]
            \mathit{Expression} &::= <span class="stt">send </span><span
              class="Iidentity">\mathit{Expression}</span><span class="stt"> </span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> (</span><span
              class="Iidentity">\{\mathit{Expression}\}^{*(,)}</span><span class="stt">)</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">method-call-exp (obj-exp method-name rands)</span>} \\[5pt]
            \mathit{Expression} &::= <span class="stt">super </span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> (</span><span
              class="Iidentity">\{\mathit{Expression}\}^{*(,)}</span><span class="stt">)</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">super-call-exp (method-name rands)</span>} \\[5pt]
            \mathit{Expression} &::= <span class="stt">self</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">self-exp</span>}\end{align*}</span>
        </p>
        <blockquote class="caption">
          <p>简单面向对象语言中的新增生成式<a name="(elem._fig-9..7)"></a></p>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._1362))"></a>
        我们新增了四种表达式。<span class="stt">new</span> 表达式创建指定类的对象，然后调用 <span class="stt">initialize</span>
        方法初始化对象的字段。<span class="stt">rands</span> 求值后，传给 <span class="stt">initialize</span> 方法。这个方法调用
        的返回值被直接抛弃，新对象则作为 <span class="stt">new</span> 表达式的值返回。</p>
      <p><a name="(idx._(gentag._1363))"></a>
        <span class="stt">self</span> 表达式返回当前方法操作的对象。
      </p>
      <p><a name="(idx._(gentag._1364))"></a>
        <a name="(idx._(gentag._1365))"></a>
        <span class="stt">send</span> 表达式包含一个值为对象的表达式，一个方法名，以及 0 或多个操作数。它从
        对象的类中找出指定的方法，然后求操作数的值，将得到的实参传给该方法。就像
        IMPLICIT-REFS 那样，它要为每个实参分配一个新位置，然后将方法的形参与对应位置的引
        用绑定起来，并在这个词法绑定作用域内求方法主体的值。
        <a name="(idx._(gentag._1366))"></a>
      </p>
      <p><a name="(idx._(gentag._1367))"></a>
        <span class="stt">super-call</span> 表达式包含一个方法名和 0 或多个参数。它从表达式持有类的超类开始，
        找出指定的方法，然后以当前对象为 <span class="stt">self</span>，求出方法主体的值。
        <a name="(idx._(gentag._1368))"></a>
      </p>
      <h4>9.4<tt> </tt><a name="(part._s9..4)"></a>解释器</h4>
      <p><a name="(idx._(gentag._1369))"></a>
        <a name="(idx._(gentag._1370))"></a>
        <a name="(idx._(gentag._1371))"></a>
        我们求程序的值时，首先用 <span class="stt">initialize-class-env!</span> 处理所有类声明，然后求表达式
        的值。过程 <span class="stt">initialize-class-env!</span> 创建一个全局<span class="emph">类
          环境</span> (<span class="emph">class environment</span>)，将各个类名映射到类的方法。因为这个环境是全局的，我们用一个 Scheme 变量表示
        它。在<a href="#%28part._s9..4..3%29" data-pltdoc="x">类和类环境</a>我们再详细讨论类环境。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">value-of-program</span></span> : <span
                  class="texMathInline">\mathit{Program} \to \mathit{ExpVal}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">value-of-program</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">pgm</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">initialize-store!</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">program</span><span class="hspace"> </span><span
                  class="RktSym">pgm</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">a-program</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">class-decls</span><span class="hspace"> </span><span class="RktSym">body</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">initialize-class-env!</span><span class="hspace"> </span><span
                  class="RktSym">class-decls</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">value-of</span><span class="hspace"> </span><span class="RktSym">body</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">init-env</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>像之前那样，语言中的各种表达式——包括四种新生成式——在过程 <span class="stt">value-of</span> 里都有对
        应的语句。</p>
      <p>我们依次考虑各个新增的表达式。</p>
      <p><a name="(idx._(gentag._1372))"></a>
        <a name="(idx._(gentag._1373))"></a>
        表达式需要求值，通常是因为它是操作某个对象的方法的一部分。在当前环境中，这个对象
        绑定到伪变量 <span class="stt">%self</span>。我们称之为<span class="emph">伪变量</span> (<span
          class="emph">pseudo-variable</span>) 是因为它虽然
        像普通变量那样遵循词法绑定，但却像下面将要探讨的那样，具有一些独特性质。类似地，
        当前方法持有类的超类名字绑定到伪变量 <span class="stt">%super</span>。
      </p>
      <p><a name="(idx._(gentag._1374))"></a>
        求 <span class="stt">self</span> 表达式的值时，返回的是 <span class="stt">%self</span> 的值。这对应 <span
          class="stt">value-of</span> 中的语
        句</p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">self-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">apply-env</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">%self</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._1375))"></a></div>
        </p>
      </blockquote>
      <p><a name="(idx._(gentag._1376))"></a>
        求 <span class="stt">send</span> 表达式的值时，操作数和对象表达式都需要求值。我们从对象中找出它的类
        名，然后用 <span class="stt">find-method</span> 找出方法。<span class="stt">find-method</span> 取一个类名和一个方法名，
        返回一个方法。接着，我们用当前对象和方法的参数调用这个方法。</p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">method-call-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">obj-exp</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">method-name</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">rands</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">args</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">values-of-exps</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">rands</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">obj</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">value-of</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">obj-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">env</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">apply-method</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">find-method</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">object->class-name</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">obj</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span
                    class="RktSym">method-name</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktSym">obj</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktSym">args</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._1377))"></a></div>
        </p>
      </blockquote>
      <p><a name="(idx._(gentag._1378))"></a>
        超类调用与普通方法调用类似，不同之处是，要在表达式持有类的超类中查找方法。
        它在 <span class="stt">value-of</span> 中的对应语句是：</p>
      <blockquote class="EoplCodeInset">
        <p>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">super-call-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">method-name</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">rands</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">args</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">values-of-exps</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">rands</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">obj</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">apply-env</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">%self</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">apply-method</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">find-method</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">apply-env</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">env</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">'</span><span class="RktSym">%super</span><span class="RktPn">)</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">method-name</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktSym">obj</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktSym">args</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        <div class="SIntrapara"><a name="(idx._(gentag._1379))"></a></div>
        </p>
      </blockquote>
      <p>最后一项工作是创建对象。求 <span class="stt">new</span> 表达式的值时，我们需要求操作数的值，并根据类
        名创建一个新对象。然后我们调用对象的初始化函数，但忽略这个函数的值。最后，返回
        该对象。</p>
      <blockquote class="Small">
        <p>
        <div class="SIntrapara"><a name="(idx._(gentag._1380))"></a>
        </div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">new-object-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">class-name</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">rands</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">args</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">values-of-exps</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">rands</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span
                    class="hspace">        </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">obj</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">new-object</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">class-name</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">apply-method</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">find-method</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">class-name</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">initialize</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktSym">obj</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktSym">args</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktSym">obj</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
      </blockquote>
      <p>接下来，我们确定如何表示对象、方法和类。我们通过一个示例解释这种表示，
        如<span class="EoplFigureRef"></span> 所示。</p>
      <blockquote class="EoplFigure">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">class c1 extends object</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field x</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field y</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize ()</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set x = 11;</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set y = 12</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m1 () ... x ... y
                    ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m2 () ... send self
                    m3() ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">class c2 extends c1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field y</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize ()</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">super initialize();</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set y = 22</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m1 (u,v) ... x ... y
                    ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m3 () ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">class c3 extends c2</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field x</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field z</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize ()</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">super initialize();</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set x = 31;</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set z = 32</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method m3 () ... x ... y ...
                    z ...</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">let o3 = new c3()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in send o3 m1(7,8)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <blockquote class="caption">
          <p>OOP 实现的示例程序<a name="(elem._fig-9..8)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <blockquote class="SCentered">
          <p><img src="simple-object.svg" alt="简单对象" width="595.5pt" height="139.5pt" /></p>
        </blockquote>
        <blockquote class="caption">
          <p>简单对象<a name="(elem._fig-9..9)"></a></p>
        </blockquote>
      </blockquote>
      <h5>9.4.1<tt> </tt><a name="(part._s9..4..1)"></a>对象</h5>
      <p><a name="(idx._(gentag._1381))"></a>
        我们用包含类名和字段引用列表的数据类型表示对象。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                  class="hspace"> </span><span class="RktSym">object</span><span class="hspace"> </span><span
                  class="RktSym">object?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">an-object</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">class-name</span><span class="hspace"> </span><span
                  class="RktSym">identifier?</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">fields</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">list-of</span><span
                  class="hspace"> </span><span class="RktSym">reference?</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>在列表中，我们把“最年长”类的字段排在前面。这样，
        在<span class="EoplFigureRef"></span> 中，类 <span class="stt">c1</span> 对象的字段排列为 <span class="stt">(x y)</span>；类
        <span class="stt">c2</span> 对
        象的字段排列为 <span class="stt">(x y y)</span>，其中，第二个 <span class="stt">y</span> 是 <span class="stt">c2</span> 中的；类
        <span class="stt">c3</span> 对
        象的字段排列为 <span class="stt">(x y y x z)</span>。<span class="EoplFigureRef"></span> 中对象 <span class="stt">o3</span>
        的表示
        如<span class="EoplFigureRef"></span> 所示。当然，我们想让类 <span class="stt">c3</span> 中的方法使用 <span class="stt">c3</span>
        中声
        明的字段 <span class="stt">x</span>，而不是 <span class="stt">c1</span> 中声明的。在建立方法主体的求值环境时，我们要处理
        这一点。</p>
      <p>这种方法有个好处：对 <span class="stt">c3</span> 的任何子类，列表中的相同位置具有相同字段，因为后添
        加的任何字段都会出现在这些字段的右边。在 <span class="stt">c3</span> 任一子类定义的某个方法中，
        <span class="stt">x</span> 在什么位置呢？我们知道，如果没有重定义，<span class="stt">x</span> 在所有这些方法中的位置一定
        是 3。这样，在声明字段变量时，变量对应值的位置保持不变。这一特点使字段引用的位置
        能够静态地确定，就像我们在<a href="expr.html#%28part._s3..6%29" data-pltdoc="x">消除变量名</a>中处理变量那样。
      </p>
      <p><a name="(idx._(gentag._1382))"></a>
        创建新对象很容易。我们只需创建 <span class="stt">an-object</span>，它有一个新引用列表，列表长度与对
        象的字段数目相等。要确定其数目，我们从对象所属类中取出字段变量列表。我们用不合法
        的值初始化所有位置，以便探知程序是否使用了未初始化的位置。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="texMathInline">\mathit{ClassName} = \mathit{Sym}</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">new-object</span></span> : <span
                  class="texMathInline">\mathit{ClassName} \to \mathit{Obj}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">new-object</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">class-name</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">an-object</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktSym">class-name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">map</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">field-name</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">newref</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">list</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">uninitialized-field</span><span class="hspace"> </span><span
                  class="RktSym">field-name</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">class->field-names</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-class</span><span class="hspace"> </span><span
                  class="RktSym">class-name</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <h5>9.4.2<tt> </tt><a name="(part._s9..4..2)"></a>方法</h5>
      <p><a name="(idx._(gentag._1383))"></a>
        <a name="(idx._(gentag._1384))"></a>
        <a name="(idx._(gentag._1385))"></a>
        <a name="(idx._(gentag._1386))"></a>
        接下来我们处理方法。方法就像过程，但是它们不保存环境，而是记录所引用的字段名。方
        法调用在如下环境中执行其主体：
      </p>
      <ul>
        <li>
          <p>方法的形参绑定到新引用，引用初始化为实参的值。这与 IMPLICIT-REFS 中的
            <span class="stt">apply-procedure</span> 行为类似。
          </p>
        </li>
        <li>
          <p>伪变量 <span class="stt">%self</span> 绑定到当前对象，<span class="stt">%super</span> 绑定到当前方法的超类。
            <a name="(idx._(gentag._1387))"></a>
          </p>
        </li>
        <li>
          <p>可见字段名绑定到当前对象的字段。要实现这点，我们定义</p>
          <blockquote class="EoplCodeInset">
            <blockquote class="SCodeFlow">
              <table cellspacing="0" cellpadding="0" class="RktBlk">
                <tr>
                  <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                      class="hspace"> </span><span class="RktSym">method</span><span class="hspace"> </span><span
                      class="RktSym">method?</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">a-method</span>
                  </td>
                </tr>
                <tr>
                  <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">vars</span><span
                      class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">list-of</span><span
                      class="hspace"> </span><span class="RktSym">identifier?</span><span class="RktPn">)</span><span
                      class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">body</span><span
                      class="hspace"> </span><span class="RktSym">expression?</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">    </span><span class="RktPn">(</span><span
                      class="RktSym">super-name</span><span class="hspace"> </span><span
                      class="RktSym">identifier?</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">    </span><span class="RktPn">(</span><span
                      class="RktSym">field-names</span><span class="hspace"> </span><span class="RktPn">(</span><span
                      class="RktSym">list-of</span><span class="hspace"> </span><span
                      class="RktSym">identifier?</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                      class="RktPn">)</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace"> </span></td>
                </tr>
                <tr>
                  <td><span style="font-weight: bold"><span class="stt">apply-method</span></span> : <span
                      class="texMathInline">\mathit{Method} \times \mathit{Obj} \times \mathit{Listof(ExpVal)} \to
                      \mathit{ExpVal}</span></td>
                </tr>
                <tr>
                  <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                      class="RktSym">apply-method</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                      class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m</span><span
                      class="hspace"> </span><span class="RktSym">self</span><span class="hspace"> </span><span
                      class="RktSym">args</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                      class="hspace"> </span><span class="RktSym">method</span><span class="hspace"> </span><span
                      class="RktSym">m</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">      </span><span class="RktPn">(</span><span
                      class="RktSym">a-method</span><span class="hspace"> </span><span class="RktPn">(</span><span
                      class="RktSym">vars</span><span class="hspace"> </span><span class="RktSym">body</span><span
                      class="hspace"> </span><span class="RktSym">super-name</span><span class="hspace"> </span><span
                      class="RktSym">field-names</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">        </span><span class="RktPn">(</span><span
                      class="RktSym">value-of</span><span class="hspace"> </span><span class="RktSym">body</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">          </span><span class="RktPn">(</span><span
                      class="RktSym">extend-env*</span><span class="hspace"> </span><span
                      class="RktSym">vars</span><span class="hspace"> </span><span class="RktPn">(</span><span
                      class="RktSym">map</span><span class="hspace"> </span><span class="RktSym">newref</span><span
                      class="hspace"> </span><span class="RktSym">args</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">            </span><span class="RktPn">(</span><span
                      class="RktSym">extend-env-with-self-and-super</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">              </span><span class="RktSym">self</span><span
                      class="hspace"> </span><span class="RktSym">super-name</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">              </span><span class="RktPn">(</span><span
                      class="RktSym">extend-env*</span><span class="hspace"> </span><span
                      class="RktSym">field-names</span><span class="hspace"> </span><span class="RktPn">(</span><span
                      class="RktSym">object->fields</span><span class="hspace"> </span><span
                      class="RktSym">self</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">                </span><span class="RktPn">(</span><span
                      class="RktSym">empty-env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                      class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                      class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                      class="RktPn">)</span></td>
                </tr>
              </table>
            </blockquote>
          </blockquote>
        </li>
      </ul>
      <p>这里，我们使用<span class="EoplExerciseRef"></span> 中的 <span class="stt">extend-env*</span>。它在扩展环境时，把变
        量列表绑定到指代值的列表。我们还给环境接口新增过程
        <span class="stt">extend-env-with-self-and-super</span>，分别将 <span class="stt">%self</span> 和 <span
          class="stt">%super</span> 绑定到对象
        和类名。
      </p>
      <p>要确保各方法看到正确的字段，我们在构建 <span class="stt">field-names</span> 列表时需要小心。各方法只
        应见到最后一个声明的同名字段，其他同名字段应被遮蔽。所以，我们构建
        <span class="stt">field-names</span> 列表时，把最右边之外的出现的每个重复名字替换为新名。
        <span class="EoplFigureRef"></span> 中的程序对应的 <span class="stt">field-names</span> 如下
      </p>
      <blockquote class="SubFlow">
        <p>
        <div class="SIntrapara"><a name="(elem._field-renaming)"></a></div>
        <div class="SIntrapara">
          <table cellspacing="0" cellpadding="0">
            <tr>
              <td>
                <p><span style="font-weight: bold">类</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span style="font-weight: bold">定义的字段</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span style="font-weight: bold">字段</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span style="font-weight: bold"><span class="stt">field-names</span></span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">c1</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span class="stt">x, y</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span class="stt">(x y)</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span class="stt">(x</span><span class="texMathInline">\phantom{xxx}</span><span
                    class="stt">y)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">c2</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span class="stt">y</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span class="stt">(x y y)</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span class="stt">(x</span><span class="texMathInline">\phantom{xxx}</span><span class="stt">y%1
                    y)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">c3</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span class="stt">x, z</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span class="stt">(x y y x z)</span></p>
              </td>
              <td>
                <p><span class="hspace">    </span></p>
              </td>
              <td>
                <p><span class="stt">(x%1</span><span class="texMathInline">\phantom{x}</span><span class="stt">y%1 y x
                    z)</span></p>
              </td>
            </tr>
          </table>
        </div>
        </p>
        <p>由于方法主体无从得知 <span class="stt">x%1</span> 和 <span class="stt">y%1</span>，所以它们只能见到各字段变量在最右边的
          声明，正合期望。</p>
      </blockquote>
      <p><span class="EoplFigureRef"></span> 展示的环境，是求<span class="EoplFigureRef"></span> 中 <span class="stt">send o3
          m1(7,8)</span> 内方
        法主体的值时创建的。这张图表明，引用列表可能比变量列表长：变量列表只是
        <span class="stt">(x y%1 y)</span>，因为 <span class="stt">c2</span> 的方法 <span class="stt">m1</span> 只能见到这些字段变量，但
        <span class="stt">(object->fields self)</span> 的值是对象中所有字段的列表。不过，由于三个可见字段变
        量的值是列表中的头三个元素，而且我们把第一个 <span class="stt">y</span> 重命名为 <span class="stt">y%1</span>（该方法对
        此一无所知），方法 <span class="stt">m1</span> 将把变量 <span class="stt">y</span> 与 <span class="stt">c2</span> 中声明的 <span
          class="stt">y</span> 关联起来，
        正合期望。
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="SCentered">
            <p><img src="env-for-method.svg" alt="方法调用时的环境" width="646.5pt" height="376.5pt" /></p>
          </blockquote>
        </div>
        </p>
        <p>
        <div class="SIntrapara"><a name="(idx._(gentag._1388))"></a>
        </div>
        <div class="SIntrapara">
          <blockquote class="caption">
            <p>方法调用时的环境<a name="(elem._fig-9..10)"></a></p>
          </blockquote>
        </div>
        </p>
      </blockquote>
      <p><a name="(idx._(gentag._1389))"></a>
        当 <span class="stt">self</span> 的持有类和所属类相同时，变量列表的长度通常与字段引用列表相同。如果
        持有类位于类链的上端，那么位置数可能多于字段变量数目，但对应于字段变量的值位于列
        表开头，其余值则不可见。<a name="(idx._(gentag._1390))"></a>
        <a name="(idx._(gentag._1391))"></a>
        <a name="(idx._(gentag._1392))"></a>
        <a name="(idx._(gentag._1393))"></a>
        <a name="(idx._(gentag._1394))"></a>
      </p>
      <h5>9.4.3<tt> </tt><a name="(part._s9..4..3)"></a>类和类环境</h5>
      <p><a name="(idx._(gentag._1395))"></a>
        <a name="(idx._(gentag._1396))"></a>
        <a name="(idx._(gentag._1397))"></a>
        <a name="(idx._(gentag._1398))"></a>
        迄今为止，我们的实现都依赖从类名获取与类相关的信息。所以，我们需要
        一个<span class="emph">类环境</span> (<span class="emph">class environment</span>) 完成这一工作。类环境将每个类名与描述类的
        数据结构关联起来。
      </p>
      <p>类环境是全局的：在我们的语言中，类声明聚集于程序开头，且对整个程序生效。所以，我
        们用名为 <span class="stt">the-class-env</span> 的全局变量表示类环境，它包含列表 <span class="stt">(类名,类)</span> 的列
        表，但我们用过程 <span class="stt">add-to-class-env!</span> 和 <span class="stt">lookup-class</span> 隐藏这一表示。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="texMathInline">\mathit{ClassEnv} = \mathit{Listof(List(ClassName, Class))}</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">the-class-env</span></span> : <span
                  class="texMathInline">\mathit{ClassEnv}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">the-class-env</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">add-to-class-env!</span></span> : <span
                  class="texMathInline">\mathit{ClassName} \times \mathit{Class} \to \mathit{Unspecified}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">add-to-class-env!</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">class-name</span><span
                  class="hspace"> </span><span class="RktSym">class</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">set!</span><span
                  class="hspace"> </span><span class="RktSym">the-class-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">cons</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">list</span><span
                  class="hspace"> </span><span class="RktSym">class-name</span><span class="hspace"> </span><span
                  class="RktSym">class</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktSym">the-class-env</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">lookup-class</span></span> : <span
                  class="texMathInline">\mathit{ClassName} \to \mathit{Class}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">lookup-class</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">name</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">maybe-pair</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">assq</span><span class="hspace"> </span><span class="RktSym">name</span><span
                  class="hspace"> </span><span class="RktSym">the-class-env</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="hspace"> </span><span class="RktSym">maybe-pair</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">cadr</span><span class="hspace"> </span><span
                  class="RktSym">maybe-pair</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">report-unknown-class</span><span class="hspace"> </span><span
                  class="RktSym">name</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>对每个类，我们记录三样东西：超类的名字，字段变量的列表，以及将方法名映射到方法的
        环境。</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                    class="hspace"> </span><span class="RktSym">class</span><span class="hspace"> </span><span
                    class="RktSym">class?</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">a-class</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">super-name</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">maybe</span><span class="hspace"> </span><span class="RktSym">identifier?</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">field-names</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">list-of</span><span class="hspace"> </span><span
                    class="RktSym">identifier?</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">method-env</span><span class="hspace"> </span><span
                    class="RktSym">method-environment?</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
        <p>这里，我们用谓词 <span class="stt">(maybe identifier?)</span> 判断值是否为符号或 <span class="stt">#f</span>。后一种情况
          对是必须的，因为类 <span class="stt">object</span> 没有超类。<span class="stt">filed-names</span> 是类的方法能见到的字段，
          <span class="stt">method-env</span> 是一环境，给出了类中每个方法名的定义。
        </p>
      </blockquote>
      <p>我们初始化类环境时，为类 <span class="stt">object</span> 添加一个绑定。对每个声明，我们向类环境添加
        一个新绑定，将类名绑定到一个 <span class="stt">class</span>，它包含超类名、类中方法的
        <span class="stt">field-names</span> 以及类中方法的环境。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><a name="(elem._initialize-class-env!)"></a><span style="font-weight: bold"><span
                    class="stt">initialize-class-env!</span></span> : <span
                  class="texMathInline">\mathit{Listof(ClassDecl)} \to \mathit{Unspecified}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">initialize-class-env!</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">c-decls</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">set!</span><span
                  class="hspace"> </span><span class="RktSym">the-class-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">list</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">list</span><span
                  class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">object</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">a-class</span><span
                  class="hspace"> </span><span class="RktVal">#f</span><span class="hspace"> </span><span
                  class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span
                  class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                  class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">for-each</span><span
                  class="hspace"> </span><span class="RktSym">initialize-class-decl!</span><span
                  class="hspace"> </span><span class="RktSym">c-decls</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">initialize-class-decl!</span></span> : <span
                  class="texMathInline">\mathit{ClassDecl} \to \mathit{Unspecified}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">initialize-class-decl!</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">c-decl</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">class-decl</span><span class="hspace"> </span><span
                  class="RktSym">c-decl</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">a-class-decl</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">c-name</span><span class="hspace"> </span><span class="RktSym">s-name</span><span
                  class="hspace"> </span><span class="RktSym">f-names</span><span class="hspace"> </span><span
                  class="RktSym">m-decls</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">f-names</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">append-field-names</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                  class="RktSym">class->field-names</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-class</span><span class="hspace"> </span><span class="RktSym">s-name</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktSym">f-names</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">add-to-class-env!</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktSym">c-name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span
                  class="RktSym">a-class</span><span class="hspace"> </span><span class="RktSym">s-name</span><span
                  class="hspace"> </span><span class="RktSym">f-names</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">merge-method-envs</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">class->method-env</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-class</span><span class="hspace"> </span><span class="RktSym">s-name</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">method-decls->method-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktSym">m-decls</span><span
                  class="hspace"> </span><span class="RktSym">s-name</span><span class="hspace"> </span><span
                  class="RktSym">f-names</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>过程 <span class="stt">append-field-names</span> 用来给当前类创建 <span class="stt">field-names</span>。它将新类声明的字
        段添加到超类字段之后，同时将超类中被新字段遮蔽的字段替换为新名字，
        就像<span class="stt">field-renaming</span>的示例那样。</p>
      <p>
      <div class="SIntrapara">
        <blockquote class="EoplCodeInset">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">append-field-names</span></span> : <br /><span
                    class="texMathInline">\phantom{xx}</span><span class="texMathInline">\mathit{Listof(FieldName)}
                    \times \mathit{Listof(FieldName)} \to \mathit{Listof(FieldName)}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">append-field-names</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">super-fields</span><span
                    class="hspace"> </span><span class="RktSym">new-fields</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cond</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">null?</span><span class="hspace"> </span><span
                    class="RktSym">super-fields</span><span class="RktPn">)</span><span class="hspace"> </span><span
                    class="RktSym">new-fields</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">else</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">cons</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">memq</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">super-fields</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">new-fields</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">fresh-identifier</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">super-fields</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">car</span><span class="hspace"> </span><span class="RktSym">super-fields</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">append-field-names</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">cdr</span><span class="hspace"> </span><span class="RktSym">super-fields</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktSym">new-fields</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </blockquote>
      </div>
      <div class="SIntrapara"><a name="(idx._(gentag._1399))"></a>
        <a name="(idx._(gentag._1400))"></a>
        <a name="(idx._(gentag._1401))"></a>
      </div>
      </p>
      <h5>9.4.4<tt> </tt><a name="(part._s9..4..4)"></a>方法环境</h5>
      <p><a name="(idx._(gentag._1402))"></a>
        <a name="(idx._(gentag._1403))"></a>
        剩下的只有 <span class="stt">find-method</span> 和 <span class="stt">merge-method-envs</span> 了。
      </p>
      <p>像处理类那样，我们用列表 <span class="stt">(方法名,方法)</span> 的列表表示方法环境，用
        <span class="stt">find-method</span> 查找方法。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="texMathInline">\mathit{MethodEnv} = \mathit{Listof(List(MethodName, Method))}</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">find-method</span></span> : <span
                  class="texMathInline">\mathit{Sym} \times \mathit{Sym} \to \mathit{Method}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">find-method</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">c-name</span><span
                  class="hspace"> </span><span class="RktSym">name</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">m-env</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">class->method-env</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-class</span><span class="hspace"> </span><span class="RktSym">c-name</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">maybe-pair</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">assq</span><span class="hspace"> </span><span class="RktSym">name</span><span
                  class="hspace"> </span><span class="RktSym">m-env</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">pair?</span><span
                  class="hspace"> </span><span class="RktSym">maybe-pair</span><span class="RktPn">)</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">cadr</span><span
                  class="hspace"> </span><span class="RktSym">maybe-pair</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">report-method-not-found</span><span class="hspace"> </span><span
                  class="RktSym">name</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>用这一信息，我们可以写出 <span class="stt">method-decls->method-env</span>。它取一个类的方法声明，创
        建一个方法环境，记录每个方法的绑定变量、主体、持有类的超类名，以及持有类的
        <span class="stt">field-names</span>。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">method-decls->method-env</span></span> : <br /><span
                  class="texMathInline">\phantom{xx}</span><span class="texMathInline">\mathit{Listof(MethodDecl)}
                  \times \mathit{ClassName} \times \mathit{Listof(FieldName)} \to \mathit{MethodEnv}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">method-decls->method-env</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-decls</span><span
                  class="hspace"> </span><span class="RktSym">super-name</span><span class="hspace"> </span><span
                  class="RktSym">field-names</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">map</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-decl</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">method-decl</span><span class="hspace"> </span><span
                  class="RktSym">m-decl</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">a-method-decl</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">method-name</span><span class="hspace"> </span><span class="RktSym">vars</span><span
                  class="hspace"> </span><span class="RktSym">body</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span
                  class="RktSym">list</span><span class="hspace"> </span><span class="RktSym">method-name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">a-method</span><span class="hspace"> </span><span class="RktSym">vars</span><span
                  class="hspace"> </span><span class="RktSym">body</span><span class="hspace"> </span><span
                  class="RktSym">super-name</span><span class="hspace"> </span><span
                  class="RktSym">field-names</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktSym">m-decls</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>最后，我们写出 <span class="stt">merge-method-envs</span>。由于新类中的方法覆盖了旧类的同名方法，我
        们可以直接扩展环境，将新方法添加到前面。</p>
      <p>
      <div class="SIntrapara">
        <blockquote class="SubFlow">
          <blockquote class="EoplCodeInset">
            <blockquote class="SCodeFlow">
              <table cellspacing="0" cellpadding="0" class="RktBlk">
                <tr>
                  <td><span style="font-weight: bold"><span class="stt">merge-method-envs</span></span> : <span
                      class="texMathInline">\mathit{MethodEnv} \times \mathit{MethodEnv} \to \mathit{MethodEnv}</span>
                  </td>
                </tr>
                <tr>
                  <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                      class="RktSym">merge-method-envs</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                      class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">super-m-env</span><span
                      class="hspace"> </span><span class="RktSym">new-m-env</span><span class="RktPn">)</span></td>
                </tr>
                <tr>
                  <td><span class="hspace">    </span><span class="RktPn">(</span><span
                      class="RktSym">append</span><span class="hspace"> </span><span
                      class="RktSym">new-m-env</span><span class="hspace"> </span><span
                      class="RktSym">super-m-env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                      class="RktPn">)</span></td>
                </tr>
              </table>
            </blockquote>
          </blockquote>
          <p>构建方法环境还有其他一些方式，它们在方法查询时更高效（<span class="EoplExerciseRef"></span>）。</p>
        </blockquote>
      </div>
      <div class="SIntrapara"><a name="(idx._(gentag._1404))"></a>
        <a name="(idx._(gentag._1405))"></a>
        <a name="(idx._(gentag._1406))"></a>
      </div>
      </p>
      <blockquote class="EoplFigure">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">c3</span></td>
            </tr>
            <tr>
              <td><span class="hspace">   </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-class</span><span class="hspace"> </span><span class="RktVal">c2</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">x%2</span><span
                  class="hspace"> </span><span class="RktVal">y%1</span><span class="hspace"> </span><span
                  class="RktVal">y</span><span class="hspace"> </span><span class="RktVal">x</span><span
                  class="hspace"> </span><span class="RktVal">z</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktVal">(</span><span class="RktVal">(</span><span
                  class="RktVal">initialize</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:a-method</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                      </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:begin-exp</span><span class="hspace"> </span><span
                  class="RktVal">...</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">c2</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">x%2</span><span class="hspace"> </span><span class="RktVal">y%1</span><span
                  class="hspace"> </span><span class="RktVal">y</span><span class="hspace"> </span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">z</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktVal">(</span><span class="RktVal">m3</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-method</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">               </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:diff-exp</span><span class="hspace"> </span><span
                  class="RktVal">...</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                  class="hspace"> </span><span class="RktVal">c2</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">x%2</span><span class="hspace"> </span><span
                  class="RktVal">y%1</span><span class="hspace"> </span><span class="RktVal">y</span><span
                  class="hspace"> </span><span class="RktVal">x</span><span class="hspace"> </span><span
                  class="RktVal">z</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktVal">(</span><span
                  class="RktVal">initialize</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:a-method</span><span class="hspace"> </span><span
                  class="RktVal">...</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktVal">(</span><span class="RktVal">m1</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-method</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">u</span><span class="hspace"> </span><span class="RktVal">v</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">               </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:diff-exp</span><span class="hspace"> </span><span
                  class="RktVal">...</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">c1</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">y%1</span><span
                  class="hspace"> </span><span class="RktVal">y</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktVal">(</span><span class="RktVal">m3</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-method</span><span class="hspace"> </span><span class="RktVal">...</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktVal">(</span><span
                  class="RktVal">initialize</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:a-method</span><span class="hspace"> </span><span
                  class="RktVal">...</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktVal">(</span><span class="RktVal">m1</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-method</span><span class="hspace"> </span><span class="RktVal">...</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktVal">(</span><span class="RktVal">m2</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-method</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">               </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:method-call-exp</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:self-exp</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">m3</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">               </span><span class="RktVal">object</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">x</span><span
                  class="hspace"> </span><span class="RktVal">y</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">c2</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-class</span><span class="hspace"> </span><span class="RktVal">c1</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">x</span><span
                  class="hspace"> </span><span class="RktVal">y%1</span><span class="hspace"> </span><span
                  class="RktVal">y</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">       </span><span class="RktVal">(</span><span class="RktVal">(</span><span
                  class="RktVal">initialize</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:a-method</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                       </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:begin-exp</span><span class="hspace"> </span><span
                  class="RktVal">...</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">c1</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">y%1</span><span
                  class="hspace"> </span><span class="RktVal">y</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span class="RktVal">m1</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-method</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">u</span><span class="hspace"> </span><span class="RktVal">v</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:diff-exp</span><span class="hspace"> </span><span
                  class="RktVal">...</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">c1</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">y%1</span><span
                  class="hspace"> </span><span class="RktVal">y</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span class="RktVal">m3</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-method</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:const-exp</span><span class="hspace"> </span><span
                  class="RktVal">23</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">c1</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">y%1</span><span
                  class="hspace"> </span><span class="RktVal">y</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span
                  class="RktVal">initialize</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:a-method</span><span class="hspace"> </span><span
                  class="RktVal">...</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span class="RktVal">m1</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-method</span><span class="hspace"> </span><span class="RktVal">...</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span class="RktVal">m2</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-method</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:method-call-exp</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:self-exp</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">m3</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktVal">object</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">x</span><span
                  class="hspace"> </span><span class="RktVal">y</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">c1</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-class</span><span class="hspace"> </span><span
                  class="RktVal">object</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">y</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">       </span><span class="RktVal">(</span><span class="RktVal">(</span><span
                  class="RktVal">initialize</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:a-method</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                       </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:begin-exp</span><span class="hspace"> </span><span
                  class="RktVal">...</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">object</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">y</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span class="RktVal">m1</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-method</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:diff-exp</span><span class="hspace"> </span><span
                  class="RktVal">...</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">object</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">x</span><span class="hspace"> </span><span class="RktVal">y</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span class="RktVal">m2</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-method</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:method-call-exp</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:self-exp</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">m3</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktVal">object</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">x</span><span
                  class="hspace"> </span><span class="RktVal">y</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">object</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-class</span><span class="hspace"> </span><span class="RktVal">#f</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">)</span><span
                  class="hspace"> </span><span class="RktVal">(</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
        <blockquote class="caption">
          <p><span class="EoplFigureRef"></span> 中的类环境
            <a name="(idx._(gentag._1407))"></a>
            <a name="(idx._(gentag._1408))"></a>
            <a name="(idx._(gentag._1409))"></a><a name="(elem._fig-9..11)"></a>
          </p>
        </blockquote>
      </blockquote>
      <h5>9.4.5<tt> </tt><a name="(part._s9..4..5)"></a>练习</h5>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..1)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>用本节的语言实现以下各项：</p>
        <ol>
          <li>
            <p>队列类 (queue)，包含方法 <span class="stt">empty?</span>、<span class="stt">enqueue</span> 和 <span
                class="stt">dequeue</span>。</p>
          </li>
          <li>
            <p>扩展队列类，添加计数器，记录当前队列已进行的操作数。</p>
          </li>
          <li>
            <p>扩展队列类，添加计数器，记录本类所有队列已进行的操作总数。提示：你可以在
              对象初始化时传递共享计数器。</p>
          </li>
        </ol>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..2)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>继承可能很危险，因为子类可以覆盖任意方法，改变其行为。定义继承自 <span class="stt">oddeven</span> 的
          类 <span class="stt">bogus-oddeven</span>，覆盖方法 <span class="stt">even</span>，从而导致 <span class="stt">let o1 =
            new
            bogus-oddeven() in send o1 odd (13)</span> 给出错误的答案。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..3)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>在<span
            class="EoplFigureRef"></span> 中，哪里是共享的方法环境？哪里是共享的 <span class="stt">field-names</span>
          列表？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..4)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>修改对象的表示，让 <span class="texMathInline">\mathit{Obj}</span> 包含对象所属的类，而非其名字。跟文中的方式相
          比，这种表示有何优劣？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..5)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a href="#%28part._s9..4%29" data-pltdoc="x">解释器</a>中的解释器在词法环境中存储方法持有类的超类名。修改实现，让方法存储
          持有类的名字，然后用持有类的名字查找超类名。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..6)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>给我们的语言添加表达式 <span class="stt">instanceof </span><span
            class="texMathInline">exp</span><span class="stt"> </span><span
            class="texMathInline">class\mbox{-}name</span>。当且仅当表
          达式 <span class="texMathInline">exp</span> 的值为对象，且为 <span class="texMathInline">class\mbox{-}name</span>
          或其子类的实例时，这一表达式
          的值为真。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..7)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>在我们的语言中，方法环境包含持有类<span class="emph">和</span>超类声明的字段变量的绑定。将其限制为
          持有类的字段变量绑定。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..8)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>给我们的语言添加新表达式：</p>
        <blockquote class="SCentered">
          <p><span class="stt">fieldref </span><span class="texMathInline">obj</span><span class="stt"> </span><span
              class="texMathInline">field\mbox{-}name</span></p>
        </blockquote>
        <p>取出指定对象指定字段的内容。再添加：</p>
        <blockquote class="SCentered">
          <p><span class="stt">fieldset </span><span class="texMathInline">obj</span><span class="stt"> </span><span
              class="texMathInline">field\mbox{-}name</span><span class="stt"> = </span><span
              class="texMathInline">exp</span></p>
        </blockquote>
        <p>将指定字段设置为 <span class="texMathInline">exp</span> 的值。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..9)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>添加 <span class="stt">superfieldref</span> <span
            class="texMathInline">field\mbox{-}name</span> 和 <span class="stt">superfieldset</span>
          <span class="texMathInline">field\mbox{-}name</span> <span class="stt">=</span> <span
            class="texMathInline">exp</span> 表达式，处理 <span class="stt">self</span> 中原本被遮蔽的字段。
          记住：<span class="stt">super</span> 是静态的，总是指持有类的超类。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..10)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>有些面向对象编程语言支持指定类名的方法调用和字段引用。在指定类名的方法调用中，可
          以写 <span class="stt">named-send c1 o m1()</span>。只要 <span class="stt">o</span> 是 <span class="stt">c1</span>
          或其子类的实例，即使
          <span class="stt">o</span> 所属类覆盖了 <span class="stt">m1</span>，这也会对 <span class="stt">o</span> 调用 <span
            class="stt">c1</span> 的方法 <span class="stt">m1</span>。这是一
          种静态方法分发。指定类名的字段与之类似。给本节的语言添加指定类名的方法调用、字段
          引用和字段赋值。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..11)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._1410))"></a>
          允许 CLASSES 指定每个方法是<span class="emph">私有的</span> (<span class="emph">private</span>)，只能在持有类内访问；
          或<span class="emph">受保护的</span> (<span class="emph">protected</span>)，只能在持有类及其后代中访问；或<span class="emph">公
            有的</span> (<span class="emph">public</span>)，在所有位置都能访问。许多面向对象编程语言都包含了这一特性的某种版本。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..12)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>像<span
            class="EoplExerciseRef"></span> 那样，允许 CLASSES 指定每个字段是私有的、受保护的、或
          公有的。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..13)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>为了防止<span class="EoplExerciseRef"></span> 那样的恶意子类，许多面向对象编程语言都能指定无法覆
          盖的 <span class="emph">final</span> 方法。给 CLASSES 添加这样的组件，那么我们就能写：</p>
        <blockquote class="EoplCodeInset">
          <p>
          <div class="SIntrapara">
            <table cellspacing="0" cellpadding="0" class="SVerbatim">
              <tr>
                <td>
                  <p><span class="stt">class oddeven extends object</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize ()
                      1</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">final method even
                      (n)</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">if zero?(n) then 1 else
                      send self odd(-(n,1))</span></p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace"> </span><span class="stt">final method odd (n)</span>
                  </p>
                </td>
              </tr>
              <tr>
                <td>
                  <p><span class="stt"></span><span class="hspace">  </span><span class="stt">if zero?(n) then 0 else
                      send self even(-(n,1))</span></p>
                </td>
              </tr>
            </table>
          </div>
          <div class="SIntrapara"><a name="(idx._(gentag._1411))"></a></div>
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..14)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>另一种防止恶意子类的方法是使用某种形式的<span class="emph">静态分发</span>。修改 CLASSES，使通过
          <span class="stt">self</span> 调用的总是持有类的方法，而不是目标对象所属类的方法。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..15)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._1412))"></a>
          <a name="(idx._(gentag._1413))"></a>
          <a name="(idx._(gentag._1414))"></a>
          <a name="(idx._(gentag._1415))"></a>
          很多面向对象编程语言都提供<span class="emph">静态</span>变量或者<span class="emph">类</span>变量。静态变量与类的某些状
          态相关联；类的所有实例共享这一状态。例如，我们可以写：
        </p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">class c1 extends object</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">static next-serial-number =
                    1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field my-serial-number</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method get-serial-number ()
                    my-serial-number</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize ()</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set my-serial-number =
                    next-serial-number;</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set next-serial-number =
                    +(next-serial-number,1)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">let o1 = new c1()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">o2 = new c1()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in list(send o1 get-serial-number(),</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">        </span><span class="stt">send o2
                    get-serial-number())</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>类 <span class="stt">c1</span> 的每个新对象具有连续的序列号。</p>
        <p>给我们的语言添加静态变量。由于静态变量可以在方法主体中出现，<span class="stt">apply-method</span> 必
          须在它构建的环境中添加额外的绑定。求静态变量初始化表达式（上例中的 <span class="stt">1</span>）的值
          时，应使用什么环境？
          <a name="(idx._(gentag._1416))"></a>
          <a name="(idx._(gentag._1417))"></a>
          <a name="(idx._(gentag._1418))"></a>
          <a name="(idx._(gentag._1419))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..16)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._1420))"></a>
          <a name="(idx._(gentag._1421))"></a>
          面向对象编程语言常允许<span class="emph">重载</span> (<span class="emph">overloading</span>) 方法。这一特性允许类有多个同名
          方法，只要它们有不同的<span class="emph">签名</span> (<span class="emph">signature</span>)。方法签名通常是方法名加上参数类型。
          由于 CLASSES 中没有类型，我们只能依靠方法名和参数个数重载方法。例如，某个类可能
          有两个 <span class="stt">initialize</span> 方法，一个没有参数，用它来初始化时，需要给字段默认值；另
          一个有一个参数，用它来初始化时，需要给字段特定值。扩展我们的解释器，允许通过方法
          的参数个数重载方法。
          <a name="(idx._(gentag._1422))"></a>
          <a name="(idx._(gentag._1423))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..17)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>显而易见，我们语言中的类定义是全局的。给 CALSSES 添加局部类，可写成 <span class="stt">letclass</span><span
            class="stt">
          </span><span class="texMathInline">c</span><span class="stt"> = ... in </span><span
            class="texMathInline">e</span>。提示：考虑给解释器添加一个类环境参数。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..18)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><span
            class="stt">merge-method-envs</span> 产生的方法环境可能很长。再写出一版 <span class="stt">merge-
            method-envs</span>，保证每个方法名只出现一次，而且总是出现在最先声明的位置。例如，在
          <span class="EoplFigureRef"></span> 中，在 <span class="stt">c1</span>、<span class="stt">c2</span>、<span
            class="stt">c3</span>，以及 <span class="stt">c3</span> 任意后代的方
          法环境中，方法 <span class="stt">m2</span> 应出现在同样的位置。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..19)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._1424))"></a>
          <a name="(idx._(gentag._1425))"></a>
          为 CLASSES 实现词法寻址。首先，为本节语言写出类似<a href="expr.html#%28part._s3..7%29" data-pltdoc="x">实现词法地址</a>的词法地址计算器。
          然后修改环境的实现，去掉其中的名字。接着修改 <span class="stt">value-of</span> 和 <span class="stt">apply-env</span>，不
          再取符号，而是像<a href="expr.html#%28part._s3..7..2%29" data-pltdoc="x">无名解释器</a>那样取一词法地址。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..20)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>方法调用也能够用类似<span class="EoplExerciseRef"></span> 那样的方式优化吗？讨论为什么能，或为什
          么不能。
          <a name="(idx._(gentag._1426))"></a>
          <a name="(idx._(gentag._1427))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..21)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>如果类中有很多方法，从头线性搜索方法列表会很耗时。将其修改为更快的实现。你的实现
          能改进多少？不论优劣，解释你的结果。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..22)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._1428))"></a>
          <a name="(idx._(gentag._1429))"></a>
          <a name="(idx._(gentag._1430))"></a>
          在<span class="EoplExerciseRef"></span> 中，我们扩展解释器，给语言添加了重载。另一种支持重载的方
          式不需修改解释器，而是用语法预处理器。写一个预处理器，将每个方法 <span class="texMathInline">m</span> 重命名为
          <span class="texMathInline">m:@n</span> 的形式，其中，<span class="texMathInline">n</span> 是方法声明中参数的数量。同时，它还必须根据操作数
          的数量改变每个方法调用的名字。我们假定程序员在方法名中不使用 <span class="texMathInline">:@</span>，但解释器
          接受使用 <span class="texMathInline">:@</span> 的方法名。编译器经常使用这种技术实现方法重载。这是一种通用技巧
          的例子，名为<span class="emph">名称混淆</span> (<span class="emph">name mangling</span>)。
          <a name="(idx._(gentag._1431))"></a>
          <a name="(idx._(gentag._1432))"></a>
          <a name="(idx._(gentag._1433))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..23)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._1434))"></a>
          我们以词法绑定的方式看待超类调用。但我们还可以做得更好：我们可以<span class="emph">静态地</span>确
          定 <span class="stt">super</span> 调用。由于超类调用指向类的父类的方法，且父类与其方法在执行之前已知，
          我们可以在进行词法寻址和其他分析的同时确定超类调用究竟指的是哪个方法。写一个翻译
          器，将每个超类调用替换为一个抽象语法树节点，节点中包含实际要调用的方法。
          <a name="(idx._(gentag._1435))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..24)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>写一个翻译器，把<span class="EoplExerciseRef"></span> 中指定类调用的方法名替换为数字，该数字表示
          运行期间，指定方法在指定类的方法表中的偏移。为翻译后的代码实现一个解释器，在常数
          时间内访问指定的方法。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..25)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._1436))"></a>
          我们给<span class="EoplFigureRef"></span> 第一个继承例子中的类 <span class="stt">point</span> 添加一个方法，判断两
          个点是否具有相同的横纵坐标。我们照下面这样给类 <span class="stt">point</span> 添加方法
          <span class="stt">similarpoints</span>：
        </p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">method similarpoints (pt)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">if equal?(send pt getx(),
                    x)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">then equal?(send pt gety(),
                    y)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">else zero?(1)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>这对所有类型的点都有效。因为 <span class="stt">getx</span>、<span class="stt">gety</span> 和 <span
            class="stt">similarpoints</span> 都在类
          <span class="stt">point</span> 中定义，通过继承，它们在 <span class="stt">colorpoint</span> 中也有定义。测试
          <span class="stt">similarpoints</span>，比较点和点、点和有色点、有色点和点，以及有色点和有色点。
        </p>
        <p>接下来考虑一个小扩展。我们给类 <span class="stt">colorpoint</span> 添加新方法 <span class="stt">similarpoints</span>。我
          们希望两个点横纵坐标相同、都是有色点且颜色相同时，它返回真；否则返回假。这里是一
          种错误做法。</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">method similarpoints (pt)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">if super
                    similarpoints(pt)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">then equal?(send pt
                    getcolor(),color)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">else zero?(1)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>测试这一扩展。说明它为何不适用于任意情况。修复它，让所有测试都返回正确的值。</p>
        <p>过程依赖多个对象造成的困难称为<span class="emph">二元方法问题</span> (<span class="emph">binary method problem</span>)。它表
          明，本章探讨的以类为中心的面向对象编程模型在处理多个对象时有其不足。这叫做
          <span class="emph">二元</span>方法问题，因为两个对象就能引起这一问题，但当对象数目增加时，它会愈发
          严重。
          <a name="(idx._(gentag._1437))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..26)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>多继承允许一个类有多个父类，这虽然有用，但可能带来过度的复杂性。如果两个被继承的
          类具有同名方法呢？可以禁止这种情况；也可以按照某种规则遍历方法，比如深度优先或从
          左到右；还可以要求在调用时消除这种歧义。字段的情况就更糟了。考虑下面的情形，类
          <span class="stt">c4</span> 继承自 <span class="stt">c2</span> 和 <span class="stt">c3</span>，二者均继承自 <span
            class="stt">c1</span>：
        </p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">class c1 extends object</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field x</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">class c2 extends c1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">class c3 extends c1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">class c4 extends c2, c3</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p><span class="stt">c4</span> 的实例中，是有一个由 <span class="stt">c2</span> 和 <span class="stt">c3</span> 共享的字段 <span
            class="stt">x</span> 实例呢，还是有
          两个分别继承自 <span class="stt">c2</span> 和 <span class="stt">c3</span> 的字段 <span class="stt">x</span>
          呢？有些语言选择共享，有些不，还
          有一些（至少在某些条件下）任选。这问题的复杂性致使人们在设计时，更偏爱类的单继承，
          而多继承只用于接口（<a href="#%28part._s9..5%29" data-pltdoc="x">带有类型的语言</a>），以尽量避免这些困难。</p>
        <p>给 CLASSES 添加多继承。对语法做必要扩展。指出解决方法名和字段名冲突时面临什么问
          题。描述共性问题及其解决方法。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..27)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>实现下面设计的无类有对象语言。对象是一组闭包，各闭包共享一个环境（亦即某种状态），
          环境以方法名为索引。类则由返回对象的过程替代。所以，我们不用写 <span class="stt">send o1
            m1(11,22,33)</span>，而是写普通的过程调用 <span class="stt">(getmethod(o1,m2) 11 22 33)</span>；不用写</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">class oddeven extends object</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method initialize () 1</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method even (n)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">if zero?(n) then 1 else send
                    self odd(-(n,1))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method odd (n)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">if zero?(n) then 0 else send
                    self even(-(n,1))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">let o1 = new oddeven()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in send o1 odd(13)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>而是写</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">let make-oddeven</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">= proc ()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">newobject</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">     </span><span class="stt">even = proc (n) if
                    zero?(n) then 1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                     </span><span class="stt">else
                    (getmethod(self,odd) -(n,1))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">     </span><span class="stt">odd = proc (n) if
                    zero?(n) then 0</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                    </span><span class="stt">else
                    (getmethod(self,even) -(n,1))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">endnewobject</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in let o1 = (make-oddeven) in (getmethod(o1,odd) 13)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..28)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>给<span class="EoplExerciseRef"></span> 的语言添加继承。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..29)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span><a name="(idx._(gentag._1438))"></a>
          设计和实现不需写明类的面向对象语言，让每个对象包含自身的方法环境。这种对象
          叫做<span class="emph">原型</span> (<span class="emph">prototype</span>)。把类 <span class="stt">object</span>
          替换为没有方法和字段的原型对象。
          扩展类时，给其原型添加方法和字段，得到新的原型。这样，我们就能用 <span class="stt">let c2 =
            extend c1 ...</span> 替代 <span class="stt">class c2 extends c1 ...</span>。把操作 <span class="stt">new</span>
          替换为
          <span class="stt">clone</span>，它取一对象，直接复制对象的方法和字段。这种语言中的方法出现于一个词法
          作用域中，所以应该能像通常那样访问词法上可见的变量以及字段变量。
          当<span class="emph">超型</span> (<span class="emph">superprototype</span>) 的字段变量与当前所在词法作用域的变量同名时，遮蔽
          关系是怎样的？
          <a name="(idx._(gentag._1439))"></a>
        </p>
      </blockquote>
      <h4>9.5<tt> </tt><a name="(part._s9..5)"></a>带有类型的语言</h4>
      <p><a name="(idx._(gentag._1440))"></a>
        <a name="(idx._(gentag._1441))"></a>
        在<a href="types.html" data-pltdoc="x">类型</a>，我们展示了如何用类型系统检查程序，保证程序执行时不会进行不当操
        作。通过检查器的程序不会调用非过程处理实参，调用过程或其他操作符时，也不会使用错
        误数量或类型的实参。
      </p>
      <p>本节，我们将这种技术应用于名为 TYPED-OO 的面向对象语言。这种语言具有上述所有安全
        性质，此外，通过我们检查器的程序不会给没有对应方法的对象发送消息，也不会给对象发
        送实参数量或类型错误的消息。</p>
      <p>TYPED-OO 的示例程序如<span class="EoplFigureRef"></span> 所示。这段程序定义了一个类 <span class="stt">tree</span>，
        其方法 <span class="stt">sum</span> 像<span class="EoplFigureRef"></span> 那样求出树叶之和，方法 <span class="stt">equal</span>
        取另一
        棵树，递归向下处理树，判断二者是否相等。</p>
      <p>这种语言的主要新特性有：</p>
      <ul>
        <li>
          <p>字段和方法需要用和<a href="types.html" data-pltdoc="x">类型</a>类似的语法指定类型。</p>
        </li>
        <li>
          <p>在面向对象设值中，引入<span class="emph">接口</span> (<span class="emph">interface</span>) 的概念。</p>
        </li>
        <li>
          <p>语言中引入了<span class="emph">子类型多态</span> (<span class="emph">subtype polymorphism</span>) 的概念。</p>
        </li>
        <li>
          <p>语言中引入了<span class="emph">强制转换</span> (<span class="emph">casting</span>) 的概念，同时也
            包含<span class="EoplExerciseRef"></span> 中的 <span class="stt">instanceof</span> 判断。</p>
        </li>
      </ul>
      <p>我们依次考虑这些特性。</p>
      <p>TYPED-OO 中的新生成式如<span class="EoplFigureRef"></span> 所示。我们添加一种类型 <span class="stt">void</span>，
        作为 <span class="stt">set</span> 操作的类型，然后添加<span class="EoplExerciseRef"></span> 中的列表类型；
        像<span class="EoplExerciseRef"></span> 那样，我们要求调用 <span class="stt">list</span> 时至少给出一个实参。我们给类
        型表达式的集合添加标识符，但在本章，用作类型的标识符与同名的类或接口相关联。稍后
        我们仔细考虑这种对应关系。方法需要指明结果类型和参数类型，其语法
        与<a href="types.html" data-pltdoc="x">类型</a>中的 <span class="stt">letrec</span> 类似。最后是两种新增的表达式 <span
          class="stt">cast</span> 和
        <span class="stt">instanceof</span>。
      </p>
      <p>要理解这种语言的新特性，我们必须像<span class="EoplDefinitionRef"></span> 那样，定义语言的类型。</p>
      <blockquote class="EoplDefinition">
        <p><a name="(elem._d9..5..1)"></a><span class="hspace"> </span>定义类型为 <span class="texMathInline">t</span> 的表达值
          <span class="texMathInline">v</span> 具有如下
          性质：
          <a name="(idx._(gentag._1442))"></a>
        </p>
        <ul>
          <li>
            <p>若 <span class="texMathInline">c</span> 为类，当且仅当值是一个对象，且是类 <span class="texMathInline">c</span> 或其后代的实例时，其类
              型为 <span class="texMathInline">c</span>。</p>
          </li>
          <li>
            <p>若 <span class="texMathInline">I</span> 为接口，当且仅当值是一个对象，且所属类实现了 <span class="texMathInline">I</span> 时，值类型为
              <span class="texMathInline">I</span>。当且仅当类具有 <span class="stt">implements </span><span
                class="texMathInline">I</span> 声明，或其祖先实现了 <span class="texMathInline">I</span> 时，类
              实现了 <span class="texMathInline">I</span>。
            </p>
          </li>
          <li>
            <p>若 <span class="texMathInline">t</span> 为其他类型，则用<span class="EoplDefinitionRef"></span> 中的规则。
              <a name="(idx._(gentag._1443))"></a>
            </p>
          </li>
        </ul>
      </blockquote>
      <p>对象只能是一个类的实例，但可以有很多类型。</p>
      <ul>
        <li>
          <p>创建对象时的类是其类型。</p>
        </li>
        <li>
          <p>该类的超类以及继承关系上方的所有类是其类型。特别地，每个对象都是
            <span class="stt">object</span> 类型。
          </p>
        </li>
        <li>
          <p>对象所属类实现的任意接口均是其类型。</p>
        </li>
      </ul>
      <p>第二条性质叫做<span class="emph">子类多态</span> (<span class="emph">subclass polymorphism</span>)。第三条性质
        叫做<span class="emph">接口多态</span> (<span class="emph">interface polymorphism</span>)。
        <a name="(idx._(gentag._1444))"></a>
        <a name="(idx._(gentag._1445))"></a>
        <a name="(idx._(gentag._1446))"></a>
      </p>
      <p><a name="(idx._(gentag._1447))"></a>
        <a name="(idx._(gentag._1448))"></a>
        接口表示实现某些方法的所有对象集合，而不论这些对象如何生成。仅当类 <span class="texMathInline">c</span> 按照约
        定的类型实现了接口 <span class="texMathInline">I</span> 要求的所有方法时，我们的判类系统才允许 <span class="texMathInline">c</span> 声称实现了
        <span class="texMathInline">I</span>。虽然我们的例子中只用了一个接口，但一个类可以实现多个不同接口。
      </p>
      <blockquote class="EoplFigure">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">interface tree</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method int sum ()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method bool equal (t :
                    tree)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">class interior-node extends object implements tree</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field tree left</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field tree right</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method void initialize(l :
                    tree, r : tree)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">begin</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">   </span><span class="stt">set left = l; set right =
                    r</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">end</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method tree getleft ()
                    left</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method tree getright ()
                    right</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method int sum () +(send left
                    sum(), send right sum())</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method bool equal (t :
                    tree)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">if instanceof t
                    interior-node</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">then if send left
                    equal(send</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                           </span><span
                    class="stt">cast t interior-node</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                           </span><span
                    class="stt">getleft())</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">       </span><span class="stt">then send right
                    equal(send</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                              </span><span
                    class="stt">cast t interior-node</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">                              </span><span
                    class="stt">getright())</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">       </span><span class="stt">else zero?(1)</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">else zero?(1)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">class leaf-node extends object implements tree</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">field int value</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method void initialize (v :
                    int) set value = v</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method int sum ()
                    value</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method int getvalue ()
                    value</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method bool equal (t :
                    tree)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">if instanceof t
                    leaf-node</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">then zero?(-(value, send
                    cast t leaf-node getvalue()))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">  </span><span class="stt">else zero?(1)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">let o1 = new interior-node (</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">new interior-node
                    (</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">           </span><span class="stt">new
                    leaf-node(3),</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">           </span><span class="stt">new
                    leaf-node(4)),</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">new
                    leaf-node(5))</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in list(send o1 sum(),</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">        </span><span class="stt">if send o1 equal(o1)
                    then 100 else 200)</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <blockquote class="caption">
          <p>TYPED-OO 的程序示例<a name="(elem._fig-9..12)"></a></p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <p><span class="Iidentity">\begin{align*} \mathit{ClassDecl} &::= <span class="stt">class </span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> extends </span><span
              class="Iidentity">\mathit{Identifier}</span> \\
            &\mathrel{\phantom{::=}} \phantom{x}\{<span class="stt">implements </span><span
              class="Iidentity">\mathit{Identifier}</span>\}^{*} \\
            &\mathrel{\phantom{::=}} \phantom{x}\{<span class="stt">field </span><span
              class="Iidentity">\mathit{Type}</span><span class="stt"> </span><span
              class="Iidentity">\mathit{Identifier}</span>\}^{*} \\
            &\mathrel{\phantom{::=}} \phantom{x}\{<span class="Iidentity">\mathit{MethodDecl}</span>\}^{*} \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{\begin{math}\begin{alignedat}{-1}
            &<span class="stt">a-class-decl</span><span class="stt">(</span><span class="stt">c-name s-name
              i-names</span> \\
            &\phantom{xxxxxxxxxxxx}<span class="stt">f-types f-names m-decls</span><span class="stt">)</span>
            \end{alignedat}\end{math}} \\[5pt]
            \mathit{ClassDecl} &::= <span class="stt">interface </span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> </span><span
              class="Iidentity">\{\mathit{AbstractMethodDecl}\}^{*}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">an-interface-decl (i-name abs-m-decls)</span>} \\[5pt]
            \mathit{MethodDecl} &::= <span class="stt">method </span><span class="Iidentity">\mathit{Type}</span><span
              class="stt"> </span><span class="Iidentity">\mathit{Identifier}</span><span class="stt"> (</span><span
              class="Iidentity">\{\mathit{Identifier} \ : \mathit{Type}\}^{*(,)}</span><span class="stt">) </span><span
              class="Iidentity">\mathit{Expression}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{{\begin{math}\begin{alignedat}{-1}
            &<span class="stt">a-method-decl</span> \\
            &\phantom{x}<span class="stt">(res-type m-name vars var-types body)</span>
            \end{alignedat}\end{math}}} \\[5pt]
            \mathit{AbstractMethodDecl} &::= <span class="stt">method </span><span
              class="Iidentity">\mathit{Type}</span><span class="stt"> </span><span
              class="Iidentity">\mathit{Identifier}</span><span class="stt"> (</span><span
              class="Iidentity">\{\mathit{Identifier} \ : \mathit{Type}\}^{*(,)}</span><span class="stt">)</span>
            \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{{\begin{math}\begin{alignedat}{-1}
            &<span class="stt">a-method-decl</span> \\
            &\phantom{x}<span class="stt">(res-type m-name m-vars m-var-types)</span>
            \end{alignedat}\end{math}}} \\[5pt]
            \mathit{Expression} &::= <span class="stt">cast </span><span
              class="Iidentity">\mathit{Expression}</span><span class="stt"> </span><span
              class="Iidentity">\mathit{Identifier}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">cast-exp (exp c-name)</span>} \\[5pt]
            \mathit{Expression} &::= <span class="stt">instanceof </span><span
              class="Iidentity">\mathit{Expression}</span><span class="stt"> </span><span
              class="Iidentity">\mathit{Identifier}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">instanceof-exp (exp name)</span>} \\[5pt]
            \mathit{Type} &::= <span class="stt">void</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">void-type ()</span>} \\[5pt]
            \mathit{Type} &::= \mathit{Identifier} \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">class-type (class-name)</span>} \\[5pt]
            \mathit{Type} &::= <span class="stt">listof </span><span class="Iidentity">\mathit{Type}</span> \\[-3pt]
            &\mathrel{\phantom{::=}} \fbox{<span class="stt">list-type (type1)</span>}\end{align*}</span></p>
        <blockquote class="caption">
          <p>TYPED-OO 中的新生成式<a name="(elem._fig-9..13)"></a></p>
        </blockquote>
      </blockquote>
      <p>在<span class="EoplFigureRef"></span> 中，类 <span class="stt">interior-node</span> 和 <span
          class="stt">leaf-node</span> 都实现了接口
        <span class="stt">tree</span>。类型检查器允许这样，因为它们都实现了 <span class="stt">tree</span> 所要求的 <span class="stt">sum</span>
        和
        <span class="stt">equal</span> 方法。
      </p>
      <p><a name="(idx._(gentag._1449))"></a>
        当 <span class="texMathInline">e</span> 的值是一个对象，且是类 <span class="texMathInline">c</span> 或其后代的实例时，表达式 <span
          class="stt">instanceof</span><span class="stt">
        </span><span class="texMathInline">e</span><span class="stt"> </span><span class="texMathInline">c</span>
        返回真。强制转换是 <span class="stt">instanceof</span> 的补充。当 <span class="texMathInline">e</span> 的值是一对象，
        且是类 <span class="texMathInline">c</span> 或其后代的实例时，<span class="stt">cast</span> 表达式 <span class="stt">cast
        </span><span class="texMathInline">e</span><span class="stt"> </span><span class="texMathInline">c</span> 的值与
        <span class="texMathInline">e</span> 的值相同；否则 <span class="stt">cast</span> 表达式报错。<span class="stt">cast
        </span><span class="texMathInline">e</span><span class="stt"> </span><span class="texMathInline">c</span>
        的类型总是<span class="texMathInline">c</span>，
        因为只要返回值，它的类型就一定是 <span class="texMathInline">c</span>。
      </p>
      <p>例如，我们的示例程序包含如下方法</p>
      <blockquote class="SubFlow">
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">method bool equal(t : tree)</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">if instanceof t
                    interior-node</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">then if send left</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">equal(send cast t
                    interior-node getleft())</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">      </span><span class="stt">then send right</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">          </span><span class="stt">equal(send cast t
                    interior-node getright())</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">      </span><span class="stt">else false</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">else false</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>表达式 <span class="stt">cast t interior-node</span> 检查 <span class="stt">t</span> 的值是否为 <span
            class="stt">interior-node</span>（或其
          后代，如果有的话）的实例。如果是，则返回 <span class="stt">t</span> 的值；否则报错。当且仅当对应的
          <span class="stt">cast</span> 成功时，<span class="stt">instanceof</span> 表达式返回真值。因此，本例中的 <span
            class="stt">instanceof</span>
          确保强制转换一定成功。而强制转换又确保 <span class="stt">send ... getleft()</span> 能够使用。强制转
          换表达式返回值的类型一定为类 <span class="stt">interior-node</span>，因此，给这个值发送消息
          <span class="stt">getleft</span> 是安全的。
        </p>
      </blockquote>
      <p><a name="(idx._(gentag._1450))"></a>
        <a name="(idx._(gentag._1451))"></a>
        我们的实现从<a href="#%28part._s9..4..1%29" data-pltdoc="x">对象</a>中的解释器开始。我们给 <span class="stt">value-of</span>
        添加两条语句，求
        <span class="stt">instanceof</span> 和 <span class="stt">cast</span> 表达式的值：
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cast-exp</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">exp</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">c-name</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">obj</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">value-of</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">is-subclass?</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">object->class-name</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">obj</span><span
                  class="RktPn">)</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">c-name</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktSym">obj</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">report-cast-error</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">c-name</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">obj</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"> </span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">instanceof-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exp</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">c-name</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">obj</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">value-of</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">is-subclass?</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">object->class-name</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">obj</span><span
                  class="RktPn">)</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">c-name</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bool-val</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktVal">#t</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bool-val</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>过程 <span class="stt">is-subclass?</span> 沿着第一个类结构的父系而上，直到找出第二个类，或在父系为
        <span class="stt">#f</span> 时停止。由于接口只用作类型，这个过程忽略它们。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">is-subclass?</span></span> : <span
                  class="texMathInline">\mathit{ClassName} \times \mathit{ClassName} \to \mathit{Bool}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">is-subclass?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">c-name1</span><span
                  class="hspace"> </span><span class="RktSym">c-name2</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cond</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">eqv?</span><span class="hspace"> </span><span class="RktSym">c-name1</span><span
                  class="hspace"> </span><span class="RktSym">c-name2</span><span class="RktPn">)</span><span
                  class="hspace"> </span><span class="RktVal">#t</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">else</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">s-name</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">class->super-name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                        </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-class</span><span class="hspace"> </span><span
                  class="RktSym">c-name1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="hspace"> </span><span class="RktSym">s-name</span><span class="hspace"> </span><span
                  class="RktPn">(</span><span class="RktSym">is-subclass?</span><span class="hspace"> </span><span
                  class="RktSym">s-name</span><span class="hspace"> </span><span class="RktSym">c-name2</span><span
                  class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">#f</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>这样，本节语言的解释器就修改完成了。
        <a name="(idx._(gentag._1452))"></a>
        <a name="(idx._(gentag._1453))"></a>
      </p>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..30)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>创建接口 <span class="stt">summable</span>：</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">interface summable</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method int sum ()</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>为可求和列表、可求和二叉树（如<span class="EoplFigureRef"></span>）和可求和的广义树（每个节点
          包含一个可求和的子节点列表）定义类。</p>
        <p>然后为接口</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">interface stringable</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method string to-string
                    ()</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>做同样的操作。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..31)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>在<span class="EoplFigureRef"></span> 中，把 <span class="stt">tree</span>
          定义为类，然后让两个节点类继承
          <span class="stt">tree</span> 可行吗？在什么情况下这种方法比使用 <span class="stt">summable</span> 之类的接口更好？在什
          么情况下更糟？
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..32)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._1454))"></a>
          不使用 <span class="stt">instanceof</span> 和 <span class="stt">cast</span>，给类 <span class="stt">tree</span>
          写一个等值判断谓词。这里需要
          用<span class="emph">双派发</span> (<span class="emph">double dispatch</span>) 替代通常方法使用的单派发。可做如下模拟：不用
          <span class="stt">instanceof</span> 找出实参 <span class="stt">t</span> 的类，而是让当前的树给 <span class="stt">t</span>
          返回一条消息，这条
          消息编码了当前树的所属类，其参数则包含适当字段的值。
        </p>
      </blockquote>
      <h4>9.6<tt> </tt><a name="(part._s9..6)"></a>类型检查器</h4>
      <p><a name="(idx._(gentag._1455))"></a>
        现在我们来看这种语言的检查器。检查器的目标是确保一些安全性质。对我们的语言来说，
        这些性质包括原有过程式语言的那部分和之后面向对象语言增加的那部分：通过我们类型检
        查器的程序不会</p>
      <ul>
        <li>
          <p>给非对象发送消息，</p>
        </li>
        <li>
          <p>给没有对应方法的对象发送消息，</p>
        </li>
        <li>
          <p>给对象发送参数数量或类型错误的消息。
            <a name="(idx._(gentag._1456))"></a>
          </p>
        </li>
      </ul>
      <p>我们无意验证 <span class="stt">initialize</span> 方法确实初始化了所有字段，所以程序仍可能引用未初始
        化的字段。同样地，由于 <span class="stt">initialize</span> 方法的类型通常难以预测，我们的检查器未防
        止以错误数量或类型的参数显式调用 <span class="stt">initialize</span> 方法，但通过 <span class="stt">new</span> 间接调用
        <span class="stt">initialize</span> 方法一定是正确的。
      </p>
      <p>检查器首先实现 <span class="stt">type-of-program</span>。由于所有类的所有方法都是互递归的，我们的处
        理方式类似 <span class="stt">letrec</span>。对 <span class="stt">letrec</span>，我们首先收集过程声明的类型，生成
        <span class="stt">tenv-for-letrec-body</span>（<span class="EoplFigureRef"></span>）。然后，我们根据声明类型检查每
        个过程主体。最后，我们在 <span class="stt">tenv-for-letrec-body</span> 中检查 <span class="stt">letrec</span> 的主体。
      </p>
      <p><a name="(idx._(gentag._1457))"></a>
        <a name="(idx._(gentag._1458))"></a>
        这里，我们首先调用 <span class="stt">initialize-static-class-env!</span>，遍历类声明，将所有类型收集
        到一个静态类环境中。由于这个环境是全局的，且不会改变，我们不是将其作参数传递，而
        是把它存储在一个 Scheme 变量中。然后，我们用 <span class="stt">check-class-decl!</span> 检查每个类声
        明。最后，我们找出程序主体的类型。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">type-of-program</span></span> : <span
                  class="texMathInline">\mathit{Program} \to \mathit{Type}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">type-of-program</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">pgm</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">program</span><span class="hspace"> </span><span
                  class="RktSym">pgm</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">a-program</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">class-decls</span><span class="hspace"> </span><span class="RktSym">exp1</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">initialize-static-class-env!</span><span class="hspace"> </span><span
                  class="RktSym">class-decls</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">for-each</span><span class="hspace"> </span><span
                  class="RktSym">check-class-decl!</span><span class="hspace"> </span><span
                  class="RktSym">class-decls</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">type-of</span><span class="hspace"> </span><span class="RktSym">exp1</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">init-tenv</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>静态类环境将每个类名映射到一个静态类，这个类包含父类的名字、字段的名字和类型，以
        及方法的名字和类型。在我们的语言中，接口既没有父类，也没有字段，所以我们用只含所
        需方法名字和类型的数据结构表示它们（但是，看看<span class="EoplExerciseRef"></span>）。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define-datatype</span><span
                  class="hspace"> </span><span class="RktSym">static-class</span><span class="hspace"> </span><span
                  class="RktSym">static-class?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">a-static-class</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">super-name</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">maybe</span><span class="hspace"> </span><span class="RktSym">identifier?</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">interface-names</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">list-of</span><span class="hspace"> </span><span class="RktSym">identifier?</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">field-names</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">list-of</span><span class="hspace"> </span><span class="RktSym">identifier?</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">field-types</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">list-of</span><span class="hspace"> </span><span class="RktSym">type?</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">method-tenv</span><span class="hspace"> </span><span
                  class="RktSym">method-tenv?</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">an-interface</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">method-tenv</span><span class="hspace"> </span><span
                  class="RktSym">method-tenv?</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>在思考如何生成静态环境之前，我们先思考如何扩展 <span class="stt">type-of</span>，检查六种面向对象表
        达式的类型：<span class="stt">self</span>、<span class="stt">instanceof</span>、<span
          class="stt">cast</span>、方法调用、超类调用，以及
        <span class="stt">new</span>。
      </p>
      <p><a name="(idx._(gentag._1459))"></a>
        对 <span class="stt">self</span> 表达式，我们用伪变量 <span class="stt">%self</span> 查询其类型。就像在解释器中，
        <span class="stt">%self</span> 绑定到当前持有对象一样，在检查器中，该变量一定绑定到当前持有类的类型。
      </p>
      <p><span class="stt">instanceof</span> 表达式如果返回，一定返回 <span class="stt">bool</span> 值。若 <span
          class="texMathInline">e</span> 的值是一个对象，
        且是 <span class="texMathInline">c</span> 或它的某个后代的实例，则表达式 <span class="stt">cast </span><span
          class="texMathInline">e</span><span class="stt"> </span><span class="texMathInline">c</span> 返回 <span
          class="texMathInline">e</span> 的值。
        因此，<span class="stt">cast </span><span class="texMathInline">e</span><span class="stt"> </span><span
          class="texMathInline">c</span> 如果返回值，值的类型是 <span class="texMathInline">c</span>。所以我们总能将
        <span class="stt">cast </span><span class="texMathInline">e</span><span class="stt"> </span><span
          class="texMathInline">c</span> 的类型视为 <span class="texMathInline">c</span>。对 <span
          class="stt">instanceof</span> 和 <span class="stt">cast</span> 表达式，
        解释器求出参数的值，并用它执行 <span class="stt">object->class-name</span>，所以我们也必须确保操作数
        类型正常，且返回值是一个对象。这三种情况的代码如<span class="EoplFigureRef"></span> 所示。
        <a name="(idx._(gentag._1460))"></a>
        <a name="(idx._(gentag._1461))"></a>
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span
                    class="RktSym">self-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span
                    class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">apply-tenv</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">tenv</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">%self</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"> </span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">instanceof-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exp</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">class-name</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">obj-type</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">type-of</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">if</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">class-type?</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">obj-type</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bool-type</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">report-bad-type-to-instanceof</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">obj-type</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">exp</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"> </span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">cast-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exp</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">class-name</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">obj-type</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">type-of</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">exp</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">if</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktPn">(</span><span class="RktSym">class-type?</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">obj-type</span><span
                    class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">class-type</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">class-name</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                    class="RktMeta"></span><span class="RktPn">(</span><span
                    class="RktSym">report-bad-type-to-cast</span><span class="RktMeta"></span><span
                    class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">obj-type</span><span
                    class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                    class="RktSym">exp</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>面向对象表达式在 <span class="stt">type-of</span> 中的对应语句，第 1 部分<a name="(elem._fig-9..14)"></a></p>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._1462))"></a>
        接下来我们考虑方法调用。现在，我们的语言中有三种调用：过程调用、方法调用和超类调
        用。我们抽象出一个过程来检查它们。</p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">type-of-call</span></span> : <span
                  class="texMathInline">\mathit{Type} \times \mathit{Listof(Type)} \times \mathit{Listof(Exp)} \times
                  \mathit{Exp} \to \mathit{Type}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">type-of-call</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">rator-type</span><span
                  class="hspace"> </span><span class="RktSym">rand-types</span><span class="hspace"> </span><span
                  class="RktSym">rands</span><span class="hspace"> </span><span class="RktSym">exp</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">type</span><span class="hspace"> </span><span
                  class="RktSym">rator-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">proc-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">arg-types</span><span class="hspace"> </span><span
                  class="RktSym">result-type</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">not</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">=</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">length</span><span
                  class="hspace"> </span><span class="RktSym">arg-types</span><span class="RktPn">)</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">length</span><span
                  class="hspace"> </span><span class="RktSym">rand-types</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">report-wrong-number-of-arguments</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span
                  class="RktSym">map</span><span class="hspace"> </span><span
                  class="RktSym">type-to-external-form</span><span class="hspace"> </span><span
                  class="RktSym">arg-types</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span
                  class="RktSym">map</span><span class="hspace"> </span><span
                  class="RktSym">type-to-external-form</span><span class="hspace"> </span><span
                  class="RktSym">rand-types</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktSym">exp</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">for-each</span><span class="hspace"> </span><span
                  class="RktSym">check-is-subtype!</span><span class="hspace"> </span><span
                  class="RktSym">rand-types</span><span class="hspace"> </span><span
                  class="RktSym">arg-types</span><span class="hspace"> </span><span class="RktSym">rands</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktSym">result-type</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">else</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">report-rator-not-of-proc-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">type-to-external-form</span><span class="hspace"> </span><span
                  class="RktSym">rator-type</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktSym">exp</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <p>这个过程等价于 CHECKED 中 <span class="stt">call-exp</span> 对应的那一行（<span class="EoplFigureRef"></span>），但
        多了两处明显区别。首先，由于我们的过程现在取多个参数，我们要确保调用时的实参数目
        正确。在 <span class="stt">for-each</span> 这行，我们逐一对照每个操作数的类型和过程类型中相应参数的
        类型。更有意思的是第二点，我们把<span class="EoplFigureRef"></span> 中的 <span class="stt">check-equal-type!</span>
        换成了 <span class="stt">check-is-subtype!</span>。</p>
      <p>为什么必须这样？子类多态原则是说，如果类 <span class="texMathInline">c_2</span> 扩展了 <span class="texMathInline">c_1</span>，那么类
        <span class="texMathInline">c_2</span>
        <a name="(idx._(gentag._1463))"></a>
        的对象可在类 <span class="texMathInline">c_1</span> 对象能够出现的任何地方使用。如果我们写出了过程 <span class="stt">proc (o</span><span
          class="stt">
        </span><span class="stt">: </span><span class="texMathInline">c_1</span><span class="stt">)
          ...</span>，那么该过程应该能取类型为 <span class="texMathInline">c_2</span> 的实参。
      </p>
      <p>子类多态的概念可以大体上推广到<span class="emph">子类型多态</span>，就像<a href="modules.html" data-pltdoc="x">模块</a>中的
        <span class="stt">
          <:< /span> 那样。我们说 <span class="texMathInline">t_1</span> 是 <span class="texMathInline">t_2</span> 的子类型，当且仅当：
            <a name="(idx._(gentag._1464))"></a>
      </p>
      <ul>
        <li>
          <p><span class="texMathInline">t_1</span> 和 <span class="texMathInline">t_2</span> 是类，且 <span
              class="texMathInline">t_1</span> 是 <span class="texMathInline">t_2</span> 的子类，或</p>
        </li>
        <li>
          <p><span class="texMathInline">t_1</span> 是类，<span class="texMathInline">t_2</span> 是接口，且 <span
              class="texMathInline">t_1</span> 或其某个超类实现了 <span class="texMathInline">t_2</span>，或</p>
        </li>
        <li>
          <p><span class="texMathInline">t_1</span> 和 <span class="texMathInline">t_2</span> 是过程类型，且 <span
              class="texMathInline">t_2</span> 参数类型是 <span class="texMathInline">t_1</span> 参数类型的子
            类型，<span class="texMathInline">t_1</span> 结果类型是 <span class="texMathInline">t_2</span> 结果类型的子类型。</p>
        </li>
      </ul>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!th]</div>
        <div class="SIntrapara">
          <blockquote class="SCentered">
            <p><img src="subtyping-proc-type.svg" alt="过程类型的子类型判定" width="423.0pt" height="166.5pt" /></p>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p>过程类型的子类型判定<a name="(elem._fig-9..15)"></a></p>
        </blockquote>
      </blockquote>
      <p>要理解最后一条规则，令 <span class="texMathInline">t_1</span> 为 <span class="stt">(c1 -> d1)</span>，<span
          class="texMathInline">t_2</span> 为 <span class="stt">(c2 -> d2)</span>，
        且 <span class="stt">c2 < c1</span>，<span class="stt">d1 < d2</span>。令 <span class="stt">f</span> 为一过程，类型为 <span
                  class="texMathInline">t_1</span>。我们说 <span class="stt">f</span>
                类型也为 <span class="texMathInline">t_2</span>。为什么？假设我们给 <span class="stt">f</span> 传递了类型为 <span
                  class="stt">c2</span> 的参数。由于
                <span class="stt">c2 < c1</span>，参数类型也是 <span class="stt">c1</span>，所以 <span class="stt">f</span>
                    可以接受这个参数。然后，<span class="stt">f</span>返
                    回值类型为 <span class="stt">d1</span>。但由于 <span class="stt">d1 < d2</span>，这个结果类型也是 <span
                          class="stt">d2</span>。所以，如果给
                        <span class="stt">f</span> 一个类型为 <span class="stt">c2</span> 的参数，其返回值类型为 <span
                          class="stt">d2</span>。因此，<span class="stt">f</span> 类型为
                        <span class="stt">(c2 -> d2)</span>。我们说结果类型的子类型判定是<span class="emph">协变的</span> (<span
                          class="emph">covariant</span>)，参数类
                        型的子类型判定是<span class="emph">逆变的</span> (<span class="emph">contravariant</span>)。见<span
                          class="EoplFigureRef"></span>。这与
                        <a href="modules.html#%28part._s8..3..2%29" data-pltdoc="x">实现</a>中 <span class="stt"><:-iface<
                            /span> 的定义类似。
                            <a name="(idx._(gentag._1465))"></a>
                            <a name="(idx._(gentag._1466))"></a></p>
      <p>这部分代码如<span class="EoplFigureRef"></span> 所示。代码使用<span class="stt">every2?</span>，
        它扩展<span class="EoplExerciseRef"></span> 中的过程 <span class="stt">every?</span>，取一个双参数谓词和两个列表，当
        列表长度相同且对应元素满足谓词时，返回 <span class="stt">#t</span>，否则返回 <span class="stt">#f</span>。
        <a name="(idx._(gentag._1467))"></a>
        <a name="(idx._(gentag._1468))"></a>
        <a name="(idx._(gentag._1469))"></a>
      </p>
      <blockquote class="EoplFigure">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">check-is-subtype!</span></span> : <span
                  class="texMathInline">\mathit{Type} \times \mathit{Type} \times \mathit{Exp} \to
                  \mathit{Unspecified}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">check-is-subtype!</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">ty1</span><span
                  class="hspace"> </span><span class="RktSym">ty2</span><span class="hspace"> </span><span
                  class="RktSym">exp</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">is-subtype?</span><span
                  class="hspace"> </span><span class="RktSym">ty1</span><span class="hspace"> </span><span
                  class="RktSym">ty2</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktVal">#t</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">report-subtype-failure</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">type-to-external-form</span><span class="hspace"> </span><span
                  class="RktSym">ty1</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span
                  class="RktSym">type-to-external-form</span><span class="hspace"> </span><span
                  class="RktSym">ty2</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktSym">exp</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">is-subtype?</span></span> : <span
                  class="texMathInline">\mathit{Type} \times \mathit{Type} \to \mathit{Bool}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">is-subtype?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">ty1</span><span
                  class="hspace"> </span><span class="RktSym">ty2</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">type</span><span class="hspace"> </span><span
                  class="RktSym">ty1</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">class-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">name1</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">type</span><span class="hspace"> </span><span
                  class="RktSym">ty2</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">class-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">name2</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span
                  class="RktSym">statically-is-subclass?</span><span class="hspace"> </span><span
                  class="RktSym">name1</span><span class="hspace"> </span><span class="RktSym">name2</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">else</span><span class="hspace"> </span><span class="RktVal">#f</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">proc-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">args1</span><span class="hspace"> </span><span class="RktSym">res1</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">type</span><span class="hspace"> </span><span
                  class="RktSym">ty2</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">proc-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">args2</span><span class="hspace"> </span><span class="RktSym">res2</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span class="RktSym">and</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">every2?</span><span class="hspace"> </span><span class="RktSym">is-subtype?</span><span
                  class="hspace"> </span><span class="RktSym">args2</span><span class="hspace"> </span><span
                  class="RktSym">args1</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">is-subtype?</span><span class="hspace"> </span><span class="RktSym">res1</span><span
                  class="hspace"> </span><span class="RktSym">res2</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">else</span><span class="hspace"> </span><span class="RktVal">#f</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">else</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">equal?</span><span
                  class="hspace"> </span><span class="RktSym">ty1</span><span class="hspace"> </span><span
                  class="RktSym">ty2</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace"> </span></td>
            </tr>
            <tr>
              <td><span style="font-weight: bold"><span class="stt">statically-is-subclass?</span></span> : <span
                  class="texMathInline">\mathit{ClassName} \times \mathit{ClassName} \to \mathit{Bool}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">statically-is-subclass?</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">name1</span><span
                  class="hspace"> </span><span class="RktSym">name2</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">or</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">eqv?</span><span
                  class="hspace"> </span><span class="RktSym">name1</span><span class="hspace"> </span><span
                  class="RktSym">name2</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">super-name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">static-class->super-name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-static-class</span><span class="hspace"> </span><span
                  class="RktSym">name1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">if</span><span
                  class="hspace"> </span><span class="RktSym">super-name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">statically-is-subclass?</span><span class="hspace"> </span><span
                  class="RktSym">super-name</span><span class="hspace"> </span><span class="RktSym">name2</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktVal">#f</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">interface-names</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktPn">(</span><span
                  class="RktSym">static-class->interface-names</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-static-class</span><span class="hspace"> </span><span
                  class="RktSym">name1</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">memv</span><span
                  class="hspace"> </span><span class="RktSym">name2</span><span class="hspace"> </span><span
                  class="RktSym">interface-names</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
        <blockquote class="caption">
          <p>TYPED-OO 的子类型判定
            <a name="(idx._(gentag._1470))"></a>
            <a name="(idx._(gentag._1471))"></a><a name="(elem._fig-9..16)"></a>
          </p>
        </blockquote>
      </blockquote>
      <p>现在可以逐一考虑三种调用（<span class="EoplFigureRef"></span>）。对方法调用，我们首先像通常那
        样，找出目标对象和操作数的类型。我们用类似 <span class="stt">find-method</span> 的
        <span class="stt">find-method-type</span> 找出方法的类型。如果目标类型不是类或接口，那么
        <span class="stt">type->class-name</span> 报错。如果没有对应方法，那么 <span class="stt">find-method-type</span> 报错。
        然后，我们调用 <span class="stt">type-of-call</span> 验证操作数的类型与方法的期望是否相符，并返回结
        果的类型。
      </p>
      <blockquote class="EoplFigure">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">method-call-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">obj-exp</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">method-name</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">rands</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">arg-types</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">types-of-exps</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">rands</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">         </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">obj-type</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">type-of</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">obj-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">tenv</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">type-of-call</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">find-method-type</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">        </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">type->class-name</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">obj-type</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">        </span><span
                  class="RktMeta"></span><span class="RktSym">method-name</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktSym">arg-types</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktSym">rands</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktSym">exp</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"> </span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">super-call-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">method-name</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">rands</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">arg-types</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">types-of-exps</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">rands</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">         </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">obj-type</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">apply-tenv</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">tenv</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">%self</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">type-of-call</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">find-method-type</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">        </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">apply-tenv</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">tenv</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">%super</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">        </span><span
                  class="RktMeta"></span><span class="RktSym">method-name</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktSym">arg-types</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktSym">rands</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktSym">exp</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"> </span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">new-object-exp</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">class-name</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">rands</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">  </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">arg-types</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">types-of-exps</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">rands</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">         </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">c</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">lookup-static-class</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">class-name</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">    </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">static-class</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">c</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">an-interface</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">method-tenv</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">        </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">report-cant-instantiate-interface</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">class-name</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">      </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">a-static-class</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktPn">(</span><span class="RktSym">super-name</span><span class="RktMeta"></span><span
                  class="hspace"> </span><span class="RktMeta"></span><span class="RktSym">i-names</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">                        </span><span class="RktMeta"></span><span
                  class="RktSym">field-names</span><span class="RktMeta"></span><span class="hspace"> </span><span
                  class="RktMeta"></span><span class="RktSym">field-types</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">                        </span><span class="RktMeta"></span><span
                  class="RktSym">method-tenv</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">        </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">type-of-call</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">          </span><span class="RktMeta"></span><span class="RktPn">(</span><span
                  class="RktSym">find-method-type</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">            </span><span class="RktMeta"></span><span
                  class="RktSym">class-name</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">            </span><span class="RktMeta"></span><span class="RktSym">'</span><span
                  class="RktSym">initialize</span><span class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">          </span><span class="RktMeta"></span><span
                  class="RktSym">arg-types</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">          </span><span class="RktMeta"></span><span class="RktSym">rands</span><span
                  class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span
                  class="hspace">          </span><span class="RktMeta"></span><span class="RktSym">exp</span><span
                  class="RktPn">)</span><span class="RktMeta"></span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktMeta"></span><span class="hspace">        </span><span
                  class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">class-type</span><span
                  class="RktMeta"></span><span class="hspace"> </span><span class="RktMeta"></span><span
                  class="RktSym">class-name</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktMeta"></span></td>
            </tr>
          </table>
        </blockquote>
        <blockquote class="caption">
          <p>面向对象表达式在 <span class="stt">type-of</span> 中的对应语句，第 2 部分<a name="(elem._fig-9..17)"></a></p>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._1472))"></a>
        对 <span class="stt">new</span> 表达式，我们首先取出类名对应的类信息。如果没有类与名字相关联，那就报
        错。之后，用操作数的类型调用 <span class="stt">type-of-call</span>，检查调用 <span class="stt">initialize</span> 是否安
        全。如果检查通过，那么执行表达式就是安全的。由于 <span class="stt">new</span> 表达式返回指定类的新对
        象，结果类型就是对应类的类型。</p>
      <p>TYPED-OO 中表达式的检查讨论完了，我们接着来构建静态类环境。</p>
      <p><a name="(idx._(gentag._1473))"></a>
        <a name="(idx._(gentag._1474))"></a>
        要构建静态类环境，<span class="stt">initialize-static-class-env!</span> 首先将其设置为空，然后为类
        <span class="stt">object</span> 添加绑定。接着，它遍历各个类和接口声明，给静态类环境添加适当的内容。
      </p>
      <blockquote class="EoplCodeInset">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">initialize-static-class-env!</span></span> : <span
                  class="texMathInline">\mathit{Listof(ClassDecl)} \to \mathit{Unspecified}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">initialize-static-class-env!</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">c-decls</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">empty-the-static-class-env!</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span
                  class="RktSym">add-static-class-binding!</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktVal">'</span><span class="RktVal">object</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">a-static-class</span><span
                  class="hspace"> </span><span class="RktVal">#f</span><span class="hspace"> </span><span
                  class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span
                  class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">(</span><span
                  class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">'</span><span
                  class="RktVal">(</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">for-each</span><span
                  class="hspace"> </span><span class="RktSym">add-class-decl-to-static-class-env!</span><span
                  class="hspace"> </span><span class="RktSym">c-decls</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span style="font-weight: bold"><span class="stt">add-class-decl-to-static-class-env!</span></span> :
                <span class="texMathInline">\mathit{ClassDecl} \to \mathit{Unspecified}</span></td>
            </tr>
            <tr>
              <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                  class="RktSym">add-class-decl-to-static-class-env!</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">c-decl</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                  class="hspace"> </span><span class="RktSym">class-decl</span><span class="hspace"> </span><span
                  class="RktSym">c-decl</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">an-interface-decl</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">i-name</span><span class="hspace"> </span><span class="RktSym">abs-m-decls</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">m-tenv</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">abs-method-decls->method-tenv</span><span class="hspace"> </span><span
                  class="RktSym">abs-m-decls</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">check-no-dups!</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">map</span><span class="hspace"> </span><span class="RktSym">car</span><span
                  class="hspace"> </span><span class="RktSym">m-tenv</span><span class="RktPn">)</span><span
                  class="hspace"> </span><span class="RktSym">i-name</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">add-static-class-binding!</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktSym">i-name</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">an-interface</span><span
                  class="hspace"> </span><span class="RktSym">m-tenv</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktPn">(</span><span
                  class="RktSym">a-class-decl</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktSym">c-name</span><span class="hspace"> </span><span class="RktSym">s-name</span><span
                  class="hspace"> </span><span class="RktSym">i-names</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                      </span><span class="RktSym">f-types</span><span
                  class="hspace"> </span><span class="RktSym">f-names</span><span class="hspace"> </span><span
                  class="RktSym">m-decls</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                  class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                  class="RktSym">i-names</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                </span><span class="RktPn">(</span><span
                  class="RktSym">append</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                  class="RktSym">static-class->interface-names</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                    </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-static-class</span><span class="hspace"> </span><span
                  class="RktSym">s-name</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktSym">i-names</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">               </span><span class="RktPn">(</span><span
                  class="RktSym">f-names</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                 </span><span class="RktPn">(</span><span
                  class="RktSym">append-field-names</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                   </span><span class="RktPn">(</span><span
                  class="RktSym">static-class->field-names</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                     </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-static-class</span><span class="hspace"> </span><span
                  class="RktSym">s-name</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                   </span><span class="RktSym">f-names</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">               </span><span class="RktPn">(</span><span
                  class="RktSym">f-types</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                 </span><span class="RktPn">(</span><span
                  class="RktSym">append</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                   </span><span class="RktPn">(</span><span
                  class="RktSym">static-class->field-types</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                     </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-static-class</span><span class="hspace"> </span><span
                  class="RktSym">s-name</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                   </span><span class="RktSym">f-types</span><span
                  class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">               </span><span class="RktPn">(</span><span
                  class="RktSym">method-tenv</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                 </span><span class="RktPn">(</span><span
                  class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                  class="RktPn">(</span><span class="RktSym">local-method-tenv</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                         </span><span class="RktPn">(</span><span
                  class="RktSym">method-decls->method-tenv</span><span class="hspace"> </span><span
                  class="RktSym">m-decls</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                   </span><span class="RktPn">(</span><span
                  class="RktSym">check-no-dups!</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                     </span><span class="RktPn">(</span><span
                  class="RktSym">map</span><span class="hspace"> </span><span class="RktSym">car</span><span
                  class="hspace"> </span><span class="RktSym">local-method-tenv</span><span class="RktPn">)</span><span
                  class="hspace"> </span><span class="RktSym">c-name</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                   </span><span class="RktPn">(</span><span
                  class="RktSym">merge-method-tenvs</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                     </span><span class="RktPn">(</span><span
                  class="RktSym">static-class->method-tenv</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                       </span><span class="RktPn">(</span><span
                  class="RktSym">lookup-static-class</span><span class="hspace"> </span><span
                  class="RktSym">s-name</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                     </span><span class="RktSym">local-method-tenv</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">check-no-dups!</span><span class="hspace"> </span><span
                  class="RktSym">i-names</span><span class="hspace"> </span><span class="RktSym">c-name</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">check-no-dups!</span><span class="hspace"> </span><span
                  class="RktSym">f-names</span><span class="hspace"> </span><span class="RktSym">c-name</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">check-for-initialize!</span><span class="hspace"> </span><span
                  class="RktSym">method-tenv</span><span class="hspace"> </span><span class="RktSym">c-name</span><span
                  class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">          </span><span class="RktPn">(</span><span
                  class="RktSym">add-static-class-binding!</span><span class="hspace"> </span><span
                  class="RktSym">c-name</span></td>
            </tr>
            <tr>
              <td><span class="hspace">            </span><span class="RktPn">(</span><span
                  class="RktSym">a-static-class</span></td>
            </tr>
            <tr>
              <td><span class="hspace">              </span><span class="RktSym">s-name</span><span
                  class="hspace"> </span><span class="RktSym">i-names</span><span class="hspace"> </span><span
                  class="RktSym">f-names</span><span class="hspace"> </span><span class="RktSym">f-types</span><span
                  class="hspace"> </span><span class="RktSym">method-tenv</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
        <blockquote class="caption">
          <p><span class="stt">add-class-decl-to-static-class-env!</span><a name="(elem._fig-9..18)"></a></p>
        </blockquote>
      </blockquote>
      <p>过程 <span class="stt">add-class-decl-to-static-class-env!</span>（<span class="EoplFigureRef"></span>）承担创建静
        态类的艰巨工作。对每个类，我们必须收集其接口、字段和方法：</p>
      <ul>
        <li>
          <p>类实现父类实现的任何接口，以及自身声称实现的接口。</p>
        </li>
        <li>
          <p>类具有父类的所有字段，以及自身的字段，但是父类字段被当前声明的字段遮蔽。
            所以，<span class="stt">field-names</span> 由 <span class="stt">append-field-names</span> 计算而得，就像
            <span class="stt">initialize-class-env!</span> 那样（<span class="stt">initialize-class-env!</span>）。
          </p>
        </li>
        <li>
          <p>类字段的类型包括父类字段的类型，以及自身声明字段的类型。</p>
        </li>
        <li>
          <p>类的方法包括父类的和自身的，方法带有声明类型。我们用 <span class="stt">proc-type</span>
            <a name="(idx._(gentag._1475))"></a> 记录方法的类型。我们把当前声明的方法放在前面，
            因为它们覆盖父类的方法。
          </p>
        </li>
        <li>
          <p>我们确保当前类中声明的方法名、接口名和字段名不重复。我们还确保类中一定有
            <span class="stt">initialize</span> 方法。
          </p>
        </li>
      </ul>
      <p><a name="(idx._(gentag._1476))"></a>
        对接口声明，我们只需处理方法名和类型。</p>
      <p><a name="(idx._(gentag._1477))"></a>
        <a name="(idx._(gentag._1478))"></a>
        <a name="(idx._(gentag._1479))"></a>
        <a name="(idx._(gentag._1480))"></a>
        一旦建立了静态类环境，我们可以检查每个类声明。这由
        <span class="stt">check-class-decl!</span>（<span class="EoplFigureRef"></span>）完成。对接口，什么都不必检查。对
        类声明，我们传递从静态类环境收集到的信息，检查每个方法。最后，我们检查类是否实现
        了它声称实现的每个接口。
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">check-class-decl!</span></span> : <span
                    class="texMathInline">\mathit{ClassDecl} \to \mathit{Unspecified}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">check-class-decl!</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">c-decl</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">class-decl</span><span class="hspace"> </span><span
                    class="RktSym">c-decl</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">an-interface-decl</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">i-name</span><span class="hspace"> </span><span
                    class="RktSym">abs-method-decls</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktVal">#t</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">a-class-decl</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">class-name</span><span class="hspace"> </span><span
                    class="RktSym">super-name</span><span class="hspace"> </span><span class="RktSym">i-names</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">                      </span><span class="RktSym">field-types</span><span
                    class="hspace"> </span><span class="RktSym">field-names</span><span class="hspace"> </span><span
                    class="RktSym">method-decls</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">sc</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">lookup-static-class</span><span class="hspace"> </span><span
                    class="RktSym">class-name</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">for-each</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">method-decl</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">check-method-decl!</span><span class="hspace"> </span><span
                    class="RktSym">method-decl</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktSym">class-name</span><span
                    class="hspace"> </span><span class="RktSym">super-name</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">static-class->field-names</span><span class="hspace"> </span><span
                    class="RktSym">sc</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">static-class->field-types</span><span class="hspace"> </span><span
                    class="RktSym">sc</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktSym">method-decls</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">for-each</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">i-name</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">check-if-implements!</span><span class="hspace"> </span><span
                    class="RktSym">class-name</span><span class="hspace"> </span><span class="RktSym">i-name</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktSym">i-names</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p><span class="stt">check-class-decl!</span>
            <a name="(idx._(gentag._1481))"></a>
            <a name="(idx._(gentag._1482))"></a>
            <a name="(idx._(gentag._1483))"></a><a name="(elem._fig-9..19)"></a>
          </p>
        </blockquote>
      </blockquote>
      <p><a name="(idx._(gentag._1484))"></a>
        <a name="(idx._(gentag._1485))"></a>
        要检查方法声明，我们首先检查其主体是否符合声明类型。要这样做，我们建立一个类型环
        境，该环境与主体求值时的环境相符。然后我们检查主体的结果类型是否为声明中结果类型
        的子类型。
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!ht]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">check-method-decl!</span></span> : <br /> <span
                    class="texMathInline">\phantom{x}\mathit{MethodDecl} \times \mathit{ClassName} \times
                    \mathit{ClassName} \times \mathit{Listof(FieldName)} \times \mathit{Listof(Type)} \\
                    \phantom{xxxx}\to \mathit{Unspecified}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">check-method-decl!</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">m-decl</span><span
                    class="hspace"> </span><span class="RktSym">self-name</span><span class="hspace"> </span><span
                    class="RktSym">s-name</span><span class="hspace"> </span><span class="RktSym">f-names</span><span
                    class="hspace"> </span><span class="RktSym">f-types</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">method-decl</span><span class="hspace"> </span><span
                    class="RktSym">m-decl</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">a-method-decl</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">res-type</span><span class="hspace"> </span><span class="RktSym">m-name</span><span
                    class="hspace"> </span><span class="RktSym">vars</span><span class="hspace"> </span><span
                    class="RktSym">var-types</span><span class="hspace"> </span><span class="RktSym">body</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">tenv</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">extend-tenv</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktSym">vars</span><span
                    class="hspace"> </span><span class="RktSym">var-types</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                    class="RktSym">extend-tenv-with-self-and-super</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                    </span><span class="RktPn">(</span><span
                    class="RktSym">class-type</span><span class="hspace"> </span><span
                    class="RktSym">self-name</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                    </span><span class="RktSym">s-name</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                    </span><span class="RktPn">(</span><span
                    class="RktSym">extend-tenv</span><span class="hspace"> </span><span
                    class="RktSym">f-names</span><span class="hspace"> </span><span class="RktSym">f-types</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                      </span><span class="RktPn">(</span><span
                    class="RktSym">init-tenv</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">body-type</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">type-of</span><span class="hspace"> </span><span
                    class="RktSym">body</span><span class="hspace"> </span><span class="RktSym">tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">check-is-subtype!</span><span class="hspace"> </span><span
                    class="RktSym">body-type</span><span class="hspace"> </span><span
                    class="RktSym">res-type</span><span class="hspace"> </span><span class="RktSym">m-decl</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">eqv?</span><span class="hspace"> </span><span class="RktSym">m-name</span><span
                    class="hspace"> </span><span class="RktVal">'</span><span class="RktVal">initialize</span><span
                    class="RktPn">)</span><span class="hspace"> </span><span class="RktVal">#t</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">maybe-super-type</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                      </span><span class="RktPn">(</span><span
                    class="RktSym">maybe-find-method-type</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                        </span><span class="RktPn">(</span><span
                    class="RktSym">static-class->method-tenv</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                          </span><span class="RktPn">(</span><span
                    class="RktSym">lookup-static-class</span><span class="hspace"> </span><span
                    class="RktSym">s-name</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                        </span><span class="RktSym">m-name</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktSym">maybe-super-type</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                    class="RktSym">check-is-subtype!</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                    </span><span class="RktPn">(</span><span
                    class="RktSym">proc-type</span><span class="hspace"> </span><span
                    class="RktSym">var-types</span><span class="hspace"> </span><span
                    class="RktSym">res-type</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                    </span><span class="RktSym">maybe-super-type</span><span
                    class="hspace"> </span><span class="RktSym">body</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktVal">#t</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p><span class="stt">check-method-decl!</span>
            <a name="(idx._(gentag._1486))"></a>
            <a name="(idx._(gentag._1487))"></a>
            <a name="(idx._(gentag._1488))"></a><a name="(elem._fig-9..20)"></a>
          </p>
        </blockquote>
      </blockquote>
      <p>但还没完：如果这个方法覆盖了超类中的某个方法，我们要确保它的类型兼容超类中的方法
        类型。之所以如此，是因为这个方法可能由另一方法调用，而另一方法只知道超类方法的类
        型。这条规则的唯一例外是 <span class="stt">initialize</span>，它只在当前类中调用，且随继承改变类型
        （见<span class="EoplFigureRef"></span>）。要这样做，它调用 <span class="stt">maybe-find-method-type</span>，后者
        返回已绑定方法的类型，或者 <span class="stt">#f</span>。见<span class="EoplFigureRef"></span>。</p>
      <p>如<span class="EoplFigureRef"></span>，过程 <span class="stt">check-if-implements?</span> 取两个符号，分别为类名和
        接口名。它首先检查两个符号确实为类名和接口名。然后，它遍历接口中的每个方法，检查
        类是否提供了同名且类型兼容的方法。</p>
      <p>为<span class="EoplFigureRef"></span> 中示例程序生成的静态类环境如<span class="EoplFigureRef"></span> 所示。
        静态类是逆序的，这反映了生成类环境的顺序。三个类中的方法顺序相同，且类型相同，符
        合期望。</p>
      <p>这样，检查器就完成了。
        <a name="(idx._(gentag._1489))"></a>
        <a name="(idx._(gentag._1490))"></a>
      </p>
      <blockquote class="EoplFigure">
        <p>
        <div class="SIntrapara">[!t]</div>
        <div class="SIntrapara">
          <blockquote class="SCodeFlow">
            <table cellspacing="0" cellpadding="0" class="RktBlk">
              <tr>
                <td><span style="font-weight: bold"><span class="stt">check-if-implements!</span></span> : <span
                    class="texMathInline">\mathit{ClassName} \times \mathit{InterfaceName} \to \mathit{Bool}</span></td>
              </tr>
              <tr>
                <td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace"> </span><span
                    class="RktSym">check-if-implements!</span></td>
              </tr>
              <tr>
                <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">lambda</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktSym">c-name</span><span
                    class="hspace"> </span><span class="RktSym">i-name</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">    </span><span class="RktPn">(</span><span class="RktSym">cases</span><span
                    class="hspace"> </span><span class="RktSym">static-class</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">lookup-static-class</span><span
                    class="hspace"> </span><span class="RktSym">i-name</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">a-static-class</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">s-name</span><span class="hspace"> </span><span class="RktSym">i-names</span><span
                    class="hspace"> </span><span class="RktSym">f-names</span><span class="hspace"> </span><span
                    class="RktSym">f-types</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                        </span><span class="RktSym">m-tenv</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span
                    class="RktSym">report-cant-implement-non-interface</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktSym">c-name</span><span
                    class="hspace"> </span><span class="RktSym">i-name</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">      </span><span class="RktPn">(</span><span
                    class="RktSym">an-interface</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">method-tenv</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">        </span><span class="RktPn">(</span><span class="RktSym">let</span><span
                    class="hspace"> </span><span class="RktPn">(</span><span class="RktPn">(</span><span
                    class="RktSym">class-method-tenv</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">static-class->method-tenv</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                    class="RktSym">lookup-static-class</span><span class="hspace"> </span><span
                    class="RktSym">c-name</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">          </span><span class="RktPn">(</span><span
                    class="RktSym">for-each</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktPn">(</span><span
                    class="RktSym">lambda</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">method-binding</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">              </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">m-name</span><span class="hspace"> </span><span
                    class="RktPn">(</span><span class="RktSym">car</span><span class="hspace"> </span><span
                    class="RktSym">method-binding</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                     </span><span class="RktPn">(</span><span
                    class="RktSym">m-type</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktSym">cadr</span><span class="hspace"> </span><span
                    class="RktSym">method-binding</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                </span><span class="RktPn">(</span><span
                    class="RktSym">let</span><span class="hspace"> </span><span class="RktPn">(</span><span
                    class="RktPn">(</span><span class="RktSym">c-method-type</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                        </span><span class="RktPn">(</span><span
                    class="RktSym">maybe-find-method-type</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                          </span><span class="RktSym">class-method-tenv</span>
                </td>
              </tr>
              <tr>
                <td><span class="hspace">                          </span><span class="RktSym">m-name</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                  </span><span class="RktPn">(</span><span
                    class="RktSym">if</span><span class="hspace"> </span><span class="RktSym">c-method-type</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                    </span><span class="RktPn">(</span><span
                    class="RktSym">check-is-subtype!</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                      </span><span class="RktSym">c-method-type</span><span
                    class="hspace"> </span><span class="RktSym">m-type</span><span class="hspace"> </span><span
                    class="RktSym">c-name</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                    </span><span class="RktPn">(</span><span
                    class="RktSym">report-missing-method</span></td>
              </tr>
              <tr>
                <td><span class="hspace">                      </span><span class="RktSym">c-name</span><span
                    class="hspace"> </span><span class="RktSym">i-name</span><span class="hspace"> </span><span
                    class="RktSym">m-name</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
              <tr>
                <td><span class="hspace">            </span><span class="RktSym">method-tenv</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span
                    class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td>
              </tr>
            </table>
          </blockquote>
        </div>
        </p>
        <blockquote class="caption">
          <p><span class="stt">check-if-implements!</span>
            <a name="(idx._(gentag._1491))"></a>
            <a name="(idx._(gentag._1492))"></a><a name="(elem._fig-9..21)"></a>
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplFigure">
        <blockquote class="SCodeFlow">
          <table cellspacing="0" cellpadding="0" class="RktBlk">
            <tr>
              <td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">leaf-node</span></td>
            </tr>
            <tr>
              <td><span class="hspace">   </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-static-class</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktVal">object</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktVal">(</span><span class="RktVal">tree</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktVal">(</span><span class="RktVal">value</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktVal">(</span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:int-type</span><span class="RktVal">)</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">      </span><span class="RktVal">(</span><span class="RktVal">(</span><span
                  class="RktVal">initialize</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:proc-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                      </span><span class="RktVal">(</span><span
                  class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">struct:int-type</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                      </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:void-type</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktVal">(</span><span class="RktVal">sum</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:proc-type</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:int-type</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktVal">(</span><span
                  class="RktVal">getvalue</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:proc-type</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">struct:int-type</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">        </span><span class="RktVal">(</span><span
                  class="RktVal">equal</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:proc-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktVal">(</span><span
                  class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">struct:class-type</span><span
                  class="hspace"> </span><span class="RktVal">tree</span><span class="RktVal">)</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                  </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:bool-type</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">interior-node</span>
              </td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-static-class</span></td>
            </tr>
            <tr>
              <td><span class="hspace">       </span><span class="RktVal">object</span></td>
            </tr>
            <tr>
              <td><span class="hspace">       </span><span class="RktVal">(</span><span class="RktVal">tree</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">       </span><span class="RktVal">(</span><span class="RktVal">left</span><span
                  class="hspace"> </span><span class="RktVal">right</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">       </span><span class="RktVal">(</span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:class-type</span><span class="hspace"> </span><span
                  class="RktVal">tree</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">struct:class-type</span><span
                  class="hspace"> </span><span class="RktVal">tree</span><span class="RktVal">)</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">       </span><span class="RktVal">(</span><span class="RktVal">(</span><span
                  class="RktVal">initialize</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:proc-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                       </span><span class="RktVal">(</span><span
                  class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">struct:class-type</span><span
                  class="hspace"> </span><span class="RktVal">tree</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                         </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:class-type</span><span class="hspace"> </span><span
                  class="RktVal">tree</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                       </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:void-type</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span
                  class="RktVal">getleft</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:proc-type</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                     </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:class-type</span><span class="hspace"> </span><span
                  class="RktVal">tree</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span
                  class="RktVal">getright</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:proc-type</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                      </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:class-type</span><span class="hspace"> </span><span
                  class="RktVal">tree</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span class="RktVal">sum</span><span
                  class="hspace"> </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:proc-type</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:int-type</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span
                  class="RktVal">equal</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:proc-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                   </span><span class="RktVal">(</span><span
                  class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">struct:class-type</span><span
                  class="hspace"> </span><span class="RktVal">tree</span><span class="RktVal">)</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                   </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:bool-type</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">tree</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:an-interface</span></td>
            </tr>
            <tr>
              <td><span class="hspace">       </span><span class="RktVal">(</span><span class="RktVal">(</span><span
                  class="RktVal">sum</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:proc-type</span><span class="hspace"> </span><span
                  class="RktVal">(</span><span class="RktVal">)</span><span class="hspace"> </span><span
                  class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">struct:int-type</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">         </span><span class="RktVal">(</span><span
                  class="RktVal">equal</span><span class="hspace"> </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:proc-type</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                   </span><span class="RktVal">(</span><span
                  class="RktVal">#</span><span class="RktVal">(</span><span class="RktVal">struct:class-type</span><span
                  class="hspace"> </span><span class="RktVal">tree</span><span class="RktVal">)</span><span
                  class="RktVal">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">                   </span><span class="RktVal">#</span><span
                  class="RktVal">(</span><span class="RktVal">struct:bool-type</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span
                  class="RktVal">)</span><span class="RktPn">)</span></td>
            </tr>
            <tr>
              <td><span class="hspace">  </span><span class="RktPn">(</span><span class="RktSym">object</span></td>
            </tr>
            <tr>
              <td><span class="hspace">    </span><span class="RktVal">#</span><span class="RktVal">(</span><span
                  class="RktVal">struct:a-static-class</span><span class="hspace"> </span><span
                  class="RktVal">#f</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span><span class="hspace"> </span><span class="RktVal">(</span><span
                  class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span><span
                  class="RktPn">)</span></td>
            </tr>
          </table>
        </blockquote>
        <blockquote class="caption">
          <p>为示例程序生成的静态类环境
            <a name="(idx._(gentag._1493))"></a>
            <a name="(idx._(gentag._1494))"></a>
            <a name="(idx._(gentag._1495))"></a><a name="(elem._fig-9..22)"></a>
          </p>
        </blockquote>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..33)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>扩展类型检查器，确保安全性质：<span class="stt">instanceof</span> 和 <span class="stt">cast</span>
          不会处理非对象值或非
          类类型。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..34)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>若 <span class="texMathInline">e</span> 的类型不是 <span class="texMathInline">c</span>
          的后代或者祖先，则表达式 <span class="stt">cast </span><span class="texMathInline">e</span><span class="stt"> </span><span
            class="texMathInline">c</span> 不会成
          功（为什么？）。扩展类型检查器，确保程序只对满足这条性质的 <span class="stt">cast</span> 表达式求值。
          再对 <span class="stt">instanceof</span> 的检查做相应扩展。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..35)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>扩展类型检查器，确保 <span class="stt">initialize</span> 方法只从 <span
            class="stt">new-object-exp</span> 内部调用，从而
          加强安全性。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..36)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>扩展语言，允许接口继承自其他接口。接口应要求实现父类要求实现的所有方法。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..37)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._1496))"></a>
          我们的 TYPED-OO 语言使用动态分发。另一种方式是<span class="emph">静态分发</span>。在静态分发中，方
          法的选择依赖于对象的类型，而不是所属类。考虑例子</p>
        <blockquote class="EoplCodeInset">
          <table cellspacing="0" cellpadding="0" class="SVerbatim">
            <tr>
              <td>
                <p><span class="stt">class c1 extends object</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method int initialize ()
                    1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method int m1 () 11</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">staticmethod int m2 ()
                    21</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">class c2 extends c1</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">method void m1 () 12</span>
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace"> </span><span class="stt">staticmethod int m2 ()
                    22</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">let f = proc (x : c1) send x m1()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">g = proc (x : c1) send x
                    m2()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt"></span><span class="hspace">    </span><span class="stt">o = new c2()</span></p>
              </td>
            </tr>
            <tr>
              <td>
                <p><span class="stt">in list((f o), (g o))</span></p>
              </td>
            </tr>
          </table>
        </blockquote>
        <p>调用 <span class="stt">f</span> 和 <span class="stt">g</span> 时，<span class="stt">x</span> 类型为 <span
            class="stt">c1</span>，但绑定到类 <span class="stt">c2</span> 的对象。方法
          <span class="stt">m1</span> 使用动态分发，所以调用的是 <span class="stt">c2</span> 的方法 <span class="stt">m1</span>，返回 12。方法
          <span class="stt">m2</span>
          使用静态分发，所以给 <span class="stt">x</span> 发送消息 <span class="stt">m2</span> 时，调用的是与 <span class="stt">x</span>
          类型（即本例
          中的 <span class="stt">c1</span>）对应的方法，所以返回 21。
        </p>
        <p>修改<a href="#%28part._s9..5%29" data-pltdoc="x">带有类型的语言</a>中的解释器，处理静态分发。提示：考虑在环境中记录类型信息，那么
          解释器就能在 <span class="stt">send</span> 中找出目标表达式的类型。
          <a name="(idx._(gentag._1497))"></a>
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..38)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>为什么类的信息必须在检查方法之前加入到静态类环境中？提示：思考一下，某个方法主体
          通过 <span class="stt">self</span> 调用方法时会发生什么？</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..39)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span>除了在
          <span class="stt">new</span> 内隐式调用 <span class="stt">initialize</span> 之外，让类型检查器禁止调用
          <span class="stt">initialize</span>。
        </p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..40)"></a><span class="texMathInline">\textnormal{[}{\star}\textnormal{]}</span><span
            class="hspace"> </span>修改语言的设计，让每个字段声明包含一个用于初始化字段的表达式。这种设计的优势是，
          通过检查的程序不会使用未初始化的值。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..41)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span
            class="hspace"> </span>扩展类型检查器，像<span class="EoplExerciseRef"></span> 那样，处理 <span
            class="stt">fieldref</span> 和 <span class="stt">fieldset</span>。</p>
      </blockquote>
      <blockquote class="EoplExercise">
        <p><a name="(elem._ex9..42)"></a><span
            class="texMathInline">\textnormal{[}{\star}{\star}\textnormal{]}</span><span class="hspace"> </span><a
            name="(idx._(gentag._1498))"></a>
          在类型检查器中，静态方法与普通方法处理方式相同，只是静态方法不能覆盖动态方法，反
          之亦然。扩展检查器，处理静态方法。
          <a name="(idx._(gentag._1499))"></a>
        </p>
      </blockquote>
      <div class="navsetbottom"><span class="navleft">
          <div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);"
              title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
        </span><span class="navright">  <a href="modules.html" title="backward to " 8 模块"" data-pltdoc="x">←
            prev</a>  <a href="index.html" title="up to " 编程语言要素"" data-pltdoc="x">up</a>  <a
            href="further-reading.html" title="forward to " 10 扩展阅读"" data-pltdoc="x">next →</a></span> </div>
    </div>
  </div>
  <div id="contextindicator"> </div>
</body>

</html>