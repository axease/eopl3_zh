<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>10 扩展阅读</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="style" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{…}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
</script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,"tocview_0");">▼</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">编程语言要素</a></td></tr></table></div><div class="tocviewsublistonly" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="fw-trans.html" class="tocviewlink" data-pltdoc="x">译者的话</a></td></tr><tr><td align="right"></td><td><a href="glo.html" class="tocviewlink" data-pltdoc="x">译名表</a></td></tr><tr><td align="right"></td><td><a href="fw.html" class="tocviewlink" data-pltdoc="x">序</a></td></tr><tr><td align="right"></td><td><a href="pf.html" class="tocviewlink" data-pltdoc="x">前言</a></td></tr><tr><td align="right"></td><td><a href="awk.html" class="tocviewlink" data-pltdoc="x">致谢</a></td></tr><tr><td align="right">1 </td><td><a href="isd.html" class="tocviewlink" data-pltdoc="x">归纳式数据集</a></td></tr><tr><td align="right">2 </td><td><a href="da.html" class="tocviewlink" data-pltdoc="x">数据抽象</a></td></tr><tr><td align="right">3 </td><td><a href="expr.html" class="tocviewlink" data-pltdoc="x">表达式</a></td></tr><tr><td align="right">4 </td><td><a href="state.html" class="tocviewlink" data-pltdoc="x">状态</a></td></tr><tr><td align="right">5 </td><td><a href="cpi.html" class="tocviewlink" data-pltdoc="x">传递续文的解释器</a></td></tr><tr><td align="right">6 </td><td><a href="cps.html" class="tocviewlink" data-pltdoc="x">续文传递风格</a></td></tr><tr><td align="right">7 </td><td><a href="types.html" class="tocviewlink" data-pltdoc="x">类型</a></td></tr><tr><td align="right">8 </td><td><a href="modules.html" class="tocviewlink" data-pltdoc="x">模块</a></td></tr><tr><td align="right">9 </td><td><a href="oac.html" class="tocviewlink" data-pltdoc="x">对象和类</a></td></tr><tr><td align="right">10 </td><td><a href="" class="tocviewselflink" data-pltdoc="x">扩展阅读</a></td></tr><tr><td align="right">11 </td><td><a href="sllgen-parsing-system.html" class="tocviewlink" data-pltdoc="x">SLLGEN解析系统</a></td></tr><tr><td align="right"></td><td><a href="bib.html" class="tocviewlink" data-pltdoc="x">参考书目</a></td></tr><tr><td align="right"></td><td><a href="indices.html" class="tocviewlink" data-pltdoc="x">索引</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">  <a href="oac.html" title="backward to "9 对象和类"" data-pltdoc="x">← prev</a>  <a href="index.html" title="up to "编程语言要素"" data-pltdoc="x">up</a>  <a href="sllgen-parsing-system.html" title="forward to "11 SLLGEN解析系统"" data-pltdoc="x">next →</a></span> </div><p class="SPretitle"><span class="appendix"></span></p><h3>10<tt> </tt><a name="(part._further-reading)"></a>扩展阅读</h3><p><a name="(elem._readings)"></a></p><p>这里的一些阅读材料教会，影响，或者启发了我们创作本书。希望你能像我们一样，至少喜
欢其中的一部分。</p><p>不熟悉递归编程和符号计算的读者可以看看 <span class="emph">The Little Schemer</span>
(<a name="(idx._(gentag._1500))"></a>Friedman & <a name="(idx._(gentag._1501))"></a>Felleisen, 1996)，或 <span class="emph">The Little
MLer</span> (<a name="(idx._(gentag._1502))"></a>Felleisen & <a name="(idx._(gentag._1503))"></a>Friedman, 1996)，或者有考据癖，看看
<span class="emph">The Little LISPer</span> (<a name="(idx._(gentag._1504))"></a>Friedman, 1974)。作为计算第一课，
<span class="emph">How to Design Programs</span> (<a name="(idx._(gentag._1505))"></a>Felleisen et al., 2001) 深入探讨了如
何递归编程。</p><p><a name="(idx._(gentag._1506))"></a>
<a name="(idx._(gentag._1507))"></a>
<a name="(idx._(gentag._1508))"></a>
<a name="(idx._(gentag._1509))"></a>
用归纳法定义集合和关系，是数理逻辑中久已存在的技术。我们的自底向上和推理规则式归
纳大致效仿 <a name="(idx._(gentag._1510))"></a>Plotkin (1975, 1981) 的工作。我们的“自顶向下
”式归纳效仿另一种技术，名为<span class="emph">余归纳</span> (<span class="emph">coinduction</span>)
<a name="(idx._(gentag._1511))"></a>
<a name="(idx._(gentag._1512))"></a>
（参见<a name="(idx._(gentag._1513))"></a>Gordon, 1995; <a name="(idx._(gentag._1514))"></a>Jacobs & <a name="(idx._(gentag._1515))"></a>Rutten,
1997），<a name="(idx._(gentag._1516))"></a>Felleisen et al. (2001) 也使用了这种技术。</p><p><a name="(idx._(gentag._1517))"></a>
<a name="(idx._(gentag._1518))"></a>
上下文无关语法是语言学和计算机科学的标准工具。大多数编译器书籍，比如
<a name="(idx._(gentag._1519))"></a>Aho et al. (2006)，都对语法和解析算法进行了大篇幅的讨论。
<a name="(idx._(gentag._1520))"></a>
<a name="(idx._(gentag._1521))"></a>
<a name="(idx._(gentag._1522))"></a>
将具体语法和抽象语法分开的思想通常归功于<a name="(idx._(gentag._1523))"></a>McCarthy (1962)。他强调用接
口抽象语法树。</p><p><a name="(idx._(gentag._1524))"></a>
<a name="(idx._(gentag._1525))"></a>
我们的口号<span class="emph">遵循语法</span>基于<span class="emph">结构化归纳法</span>，由 <a name="(idx._(gentag._1526))"></a>Burstall
(1969) 提出。即使过程没有<span style="font-weight: bold">遵循语法</span>，<span class="emph">子目标归纳</span> (<span class="emph">subgoal induction</span>)
(<a name="(idx._(gentag._1527))"></a>Morris & <a name="(idx._(gentag._1528))"></a>Wegbreit, 1977) 仍是证明递归过程正确性的有效
方法。过程的可能输入受不变式约束时，子目标归纳也有效。
<a name="(idx._(gentag._1529))"></a>
<a name="(idx._(gentag._1530))"></a></p><p><a name="(idx._(gentag._1531))"></a>
<span class="emph">泛化</span> (<span class="emph">generalization</span>) 是源自数学的标准技术，常用来证明某个特定陈述是某个
更通用陈述的特例。我们把额外参数描述为上下文的抽象，是受到属性语法
(<a name="(idx._(gentag._1532))"></a>Knuth, 1968)中的<span class="emph">继承属性</span> 启发。<a name="(idx._(gentag._1533))"></a></p><p><a name="(idx._(gentag._1534))"></a>
<a name="(idx._(gentag._1535))"></a>
我们的构造器 <span class="stt">define-datatype</span> 和 <span class="stt">cases</span> 是受 ML 的 <span class="stt">datatype</span> 和模式
匹配工具启发，详见 <a name="(idx._(gentag._1536))"></a>Milner et al. (1989) 及其修订版
<a name="(idx._(gentag._1537))"></a>Milner et al. (1997)。</p><p><a name="(idx._(gentag._1538))"></a>
Lambda 演算由邱奇发明 (<a name="(idx._(gentag._1539))"></a>Church, 1941)，用于研究数理逻辑，但已成为诸
多现代编程语言理论的灵感来源。Lambda 演算的介绍参见 <a name="(idx._(gentag._1540))"></a>Hankin (1994)、
<a name="(idx._(gentag._1541))"></a>Peyton Jones (1987) 或 <a name="(idx._(gentag._1542))"></a>Stoy (1977)。
<a name="(idx._(gentag._1543))"></a>Barendregt (1981, 1991) 提供了百科全书式的参考。</p><p><a name="(idx._(gentag._1544))"></a>
<a name="(idx._(gentag._1545))"></a>
<a name="(idx._(gentag._1546))"></a>
<span class="EoplFigureRef"></span> 那样的等深线用来解释词法作用域，首先由
<a name="(idx._(gentag._1547))"></a>Johnston (1971) 提出。无名解释器和翻译器基于德布鲁金索引
(<a name="(idx._(gentag._1548))"></a>de Bruijn, 1972)。
<a name="(idx._(gentag._1549))"></a></p><p>Scheme 由 <a name="(idx._(gentag._1550))"></a>Sussman & <a name="(idx._(gentag._1551))"></a>Steele (1975) 发明。其开发过程记录
在 <a name="(idx._(gentag._1552))"></a>Steele & <a name="(idx._(gentag._1553))"></a>Sussman (1978); <a name="(idx._(gentag._1554))"></a>Clinger et
al. (1985a); <a name="(idx._(gentag._1555))"></a>Rees et al. (1986); <a name="(idx._(gentag._1556))"></a>Clinger et
al. (1991); <a name="(idx._(gentag._1557))"></a>Kelsey et al. (1998)。Scheme 标准由 IEEE standard
(IEEE, 1991) 和 <span class="emph"><span class="texMathInline">\textit{Revised}^6</span> Report on the Algorithmic Language
Scheme</span> (<a name="(idx._(gentag._1558))"></a>Sperber et al., 2007) 制定。</p><p><a name="(idx._(gentag._1559))"></a>Dybvig (2003) 简短介绍了 Scheme，加入了许多富有洞见的例子。</p><p><a name="(idx._(gentag._1560))"></a>
解释器思想至少能追溯到图灵，他定义了能够模拟任何图灵机的“通用
”机器。这种通用机器实际上是一个解释器，取一套描述图灵机的编码，模
拟解码机器 (Turing, 1936)。经典的冯诺依曼机 (<a name="(idx._(gentag._1561))"></a>von Neumann, 1945) 同
样是硬件实现的解释器，用来解释机器语言程序。
<a name="(idx._(gentag._1562))"></a></p><p><a name="(idx._(gentag._1563))"></a>
<a name="(idx._(gentag._1564))"></a>
<a name="(idx._(gentag._1565))"></a>
<a name="(idx._(gentag._1566))"></a>
对解释器的现代应用可追溯到 <a name="(idx._(gentag._1567))"></a>McCarthy (1960)，他提出了<span class="emph">自循环解释器</span> (<span class="emph">metacircular
interpreter</span>)（用被定语言本身写就的解释器），用来解释 Lisp 的能力。
当然，这样的解释器带来一大难题：如果被定语言由自身定义，我们要理解语言的定义，就
要先理解这种语言。确实，即使解释器不是自循环的，也会面临同样的问题。读者理解被定
义的事物之前，仍需理解书写定义用的语言。</p><p>这些年来，大量技术用来解决这一难题。我们把解释器视为方程式规范的转写
<a name="(idx._(gentag._1568))"></a>
(<a name="(idx._(gentag._1569))"></a>Goguen et al., 1977) 或者 <a name="(idx._(gentag._1570))"></a>Plotkin (1975, 1981) 式的大
步操作语义。这只需要非常直观的数学。</p><p><a name="(idx._(gentag._1571))"></a>
指称语义是另一种用数学定义语言的技术。这种方法将解释器替换为一个函数，该函数把每
个被定语言的程序翻译为定义其行为的数学对象。<a name="(idx._(gentag._1572))"></a>Plotkin (1977) 对这种技
术做了无可替代的介绍，<a name="(idx._(gentag._1573))"></a>Winskel (1993) 做了更宽泛的探讨。
<a name="(idx._(gentag._1574))"></a>Milne & <a name="(idx._(gentag._1575))"></a>Strachey (1976) 是本百科全书，研究了如何用这种
技术建模大量语言特性，</p><p>另一种方式是写出被定语言子集的解释器。例如，<a href="state.html" data-pltdoc="x">状态</a>的几个解释器依靠
Scheme 的存储器来解释存储器的概念，但它们只用了一个全局可变对象，而不是 Scheme
可变变量的所有能力。<a name="(idx._(gentag._1576))"></a></p><p><a name="(idx._(gentag._1577))"></a>
<a name="(idx._(gentag._1578))"></a>
将计算视为操作存储器的思想可追溯到现代计算（参见 <a name="(idx._(gentag._1579))"></a>von Neumann, 1945）
的开端。EXPLICIT-REFS 的设计基于 ML (<a name="(idx._(gentag._1580))"></a>Milner et al., 1989) 的存储器
模型，而后者与 Bliss (<a name="(idx._(gentag._1581))"></a>Wulf, 1971) 类似。IMPLICIT-REFS 的设计类似于
大多数具有可变局部值的标准编程语言，诸如 Pascal、Scheme 和 Java。</p><p><a name="(idx._(gentag._1582))"></a>
<a name="(idx._(gentag._1583))"></a>
术语“左值”和“右值”，以及
内存的环境-存储器模型源自 <a name="(idx._(gentag._1584))"></a>Strachey (1967)。</p><p><a name="(idx._(gentag._1585))"></a>
Fortran (<a name="(idx._(gentag._1586))"></a>Backus et al., 1957) 是第一种使用按指调用的语言，Algol 60
(<a name="(idx._(gentag._1587))"></a>Naur et al., 1963) 是第一种使用按名调用的语言。
<a name="(idx._(gentag._1588))"></a>
<a name="(idx._(gentag._1589))"></a>Friedman & <a name="(idx._(gentag._1590))"></a>Wise (1976) 较早介绍了全面使用懒求值的威力。
<a name="(idx._(gentag._1591))"></a>
<a name="(idx._(gentag._1592))"></a>
<a name="(idx._(gentag._1593))"></a>
Haskell (<a name="(idx._(gentag._1594))"></a>Hudak et al., 1990) 是第一种使用按需调用的实际语言。为了建
模按名调用，<a name="(idx._(gentag._1595))"></a>Ingerman (1961) 发明了<span class="emph">值箱</span> (<span class="emph">thunk</span>)。我们用它们
和效果建模按需调用。这与<span class="emph">助记法</span> (<span class="emph">memoization</span>) (<a name="(idx._(gentag._1596))"></a>Michie, 1968) 类似。
<a name="(idx._(gentag._1597))"></a>
<a name="(idx._(gentag._1598))"></a></p><p><a name="(idx._(gentag._1599))"></a>
<span class="emph">Monads</span> 由 <a name="(idx._(gentag._1600))"></a>Moggi (1991) 提出，因 <a name="(idx._(gentag._1601))"></a>Wadler (1992)
流行。它提供了编程语言效果的通用模型。在函数式语言 Haskell (<a name="(idx._(gentag._1602))"></a>Peyton
Jones, 2001) 中，monads 提供了非函数式行为的组织原则。</p><p><a name="(idx._(gentag._1603))"></a>
<a name="(idx._(gentag._1604))"></a>
<a name="(idx._(gentag._1605))"></a>
续文由多人独立发现，<a name="(idx._(gentag._1606))"></a>Reynolds (1993) 介绍了这一迷人历史。
<a name="(idx._(gentag._1607))"></a>Strachey & <a name="(idx._(gentag._1608))"></a>Wadsworth (1974) 或许是其中影响最大的。
<a name="(idx._(gentag._1609))"></a>Reynolds (1972) 将一个自循环解释器做了 CPS 变换，并展示了这样做如何
避免自循环的某些问题。将尾式程序翻译为命令式可追溯到 <a name="(idx._(gentag._1610))"></a>McCarthy
(1962)，<a name="(idx._(gentag._1611))"></a>Abelson & <a name="(idx._(gentag._1612))"></a>Sussman (1985, 1996) 强调了将其作为
一种编程技术的重要性。
<a name="(idx._(gentag._1613))"></a>
<a name="(idx._(gentag._1614))"></a></p><p><a name="(idx._(gentag._1615))"></a>Plotkin (1975) 给出了相当清晰的 CPS 变换，发现了它的理论性质。
<a name="(idx._(gentag._1616))"></a>Fischer (1972) 提出了非常类似的变换。<a name="(idx._(gentag._1617))"></a>Wand (1980b) 率先
探讨了续文和<a name="(idx._(gentag._1618))"></a>累加器之间的联系，像<a href="cps.html#%28part._s6..1%29" data-pltdoc="x">写出续文传递风格的程序</a>结尾的例子
<span class="stt">fact</span> 那样。</p><p>在程序中直接使用续文的思想源自于 <a name="(idx._(gentag._1619))"></a>Landin (1965a) （另见
<a name="(idx._(gentag._1620))"></a>Landin 1965b），在 Lisp 和早期版本的 Scheme (<a name="(idx._(gentag._1621))"></a>Steele &
<a name="(idx._(gentag._1622))"></a>Sussman, 1978) 中广泛使用。我们的 <span class="stt">letcc</span> 基于 Scheme 的
<span class="stt">call-with-current-continuation</span>，始见于 <a name="(idx._(gentag._1623))"></a>Clinger et al. (1985b)。
<a name="(idx._(gentag._1624))"></a></p><p><a name="(idx._(gentag._1625))"></a>
<a name="(idx._(gentag._1626))"></a>
<a name="(idx._(gentag._1627))"></a>Wand (1980a) 展示了如何用续文建模轻量级进程或线程。续文用途广泛，远
超本书讨论范围，如<span class="emph">协程</span> (<span class="emph">coroutine</span>) (<a name="(idx._(gentag._1628))"></a>Haynes et al., 1986)。</p><p>我们对线程的讨论模拟了 POSIX 线程 （例如，参见 <a name="(idx._(gentag._1629))"></a>Lewis &
<a name="(idx._(gentag._1630))"></a>Berg, 1998）。<span class="EoplExerciseRef"></span> 基于 Erlang 的消息传递并发模型
(<a name="(idx._(gentag._1631))"></a>Armstrong, 2007)。
<a name="(idx._(gentag._1632))"></a>
<a name="(idx._(gentag._1633))"></a></p><p><a name="(idx._(gentag._1634))"></a>Steele 的 RABBIT 编译器 (<a name="(idx._(gentag._1635))"></a>Steele, 1978) 以 CPS 变换为基
础。这一编译器首先对源程序做 CPS 变换，然后以数据结构表示续文。得出的程序像我们
的寄存程序一样，很容易编译。这条线发展出了 ORBIT 编译器 (<a name="(idx._(gentag._1636))"></a>Kranz et
al., 1986) 和 Standard ML of New Jersey 编译器 (<a name="(idx._(gentag._1637))"></a>Appel &
<a name="(idx._(gentag._1638))"></a>Jim, 1989)。</p><p><a href="cps.html" data-pltdoc="x">续文传递风格</a>的 CPS 算法基于 <a name="(idx._(gentag._1639))"></a>Danvy & <a name="(idx._(gentag._1640))"></a>Nielsen (2003) 提
出的一阶组合式算法。CPS 翻译历史悠久，包括 <a name="(idx._(gentag._1641))"></a>Sabry &
<a name="(idx._(gentag._1642))"></a>Wadler (1997)，他们改进了 <a name="(idx._(gentag._1643))"></a>Sabry &
<a name="(idx._(gentag._1644))"></a>Felleisen (1993)，而后者又是受本书初版第 8 章的 CPS 算法启发。
<span class="EoplExerciseRef"></span> 基于 <a name="(idx._(gentag._1645))"></a>Danvy & <a name="(idx._(gentag._1646))"></a>Filinski (1992) 提
出的高阶组合式 CPS 算法。CPS 之外还有<a name="(idx._(gentag._1647))"></a> A-normal form（<span class="EoplExerciseRef"></span>），由
<a name="(idx._(gentag._1648))"></a>Sabry & <a name="(idx._(gentag._1649))"></a>Felleisen (1992); <a name="(idx._(gentag._1650))"></a>Flanagan et
al. (1993) 提出。
<a name="(idx._(gentag._1651))"></a></p><p>当前大多数关于有类型编程语言的工作都能追溯到 <a name="(idx._(gentag._1652))"></a>Milner (1978)，他在 ML
中引入了类型，作为保证计算机生成证明可靠性的工具。<a name="(idx._(gentag._1653))"></a>Ullman (1998) 对
此做了精辟的介绍。更多讨论参见 <a name="(idx._(gentag._1654))"></a>Felleisen & <a name="(idx._(gentag._1655))"></a>Friedman
(1996)，另见 <a name="(idx._(gentag._1656))"></a>Paulson (1996); <a name="(idx._(gentag._1657))"></a>Smith (2006)。</p><p><a name="(idx._(gentag._1658))"></a>
人们多次发现了类型推导。标准参考书是 <a name="(idx._(gentag._1659))"></a>Hindley (1969)，但
<a name="(idx._(gentag._1660))"></a>Hindley 提到，<a name="(idx._(gentag._1661))"></a>Curry 在 1950 年代已经知道
了这些结论。<a name="(idx._(gentag._1662))"></a>Morris (1968) 也提出了类型推导，但在<a name="(idx._(gentag._1663))"></a>Milner
1978 年的论文发表之前，类型推导从未广泛应用。</p><p><a name="(idx._(gentag._1664))"></a>
<a name="(idx._(gentag._1665))"></a>Wand (1987) 率先阐明了如何将类型推导分为方程构建和求解。名为
<a name="(idx._(gentag._1666))"></a>
Hindley-Milner 多态的 <a name="(idx._(gentag._1667))"></a>Milner (1978) 系统与<span class="EoplExerciseRef"></span> 中
的系统基本相同。<a name="(idx._(gentag._1668))"></a>Pierce (2002, 2004) 的两卷著作对类型做了百科全书式
的讨论。
<a name="(idx._(gentag._1669))"></a></p><p>广为论述的数据抽象思想是 1970 年代的一大创举。这里我们仅仅提及
<a name="(idx._(gentag._1670))"></a>Parnas (1972)，他强调了以接口作为信息隐藏边界的重要性。数据类型的实
现是满足该类型定义的任意值和操作的集合。<a name="(idx._(gentag._1671))"></a>Goguen et al. (1977) 证明，
任意数据类型都能以树的集合实现，树中记录了值如何构建，且从一个树的集合到该数据类
型另一实现的集合具有唯一映射。相应地，任意数据类型都能以过程表示法实现，且从该数
据类型的任何其他实现到过程表示法都有唯一映射 (<a name="(idx._(gentag._1672))"></a>Giarratana et al.,
1976; <a name="(idx._(gentag._1673))"></a>Wand, 1979; <a name="(idx._(gentag._1674))"></a>Kamin, 1980)。
<a name="(idx._(gentag._1675))"></a>
<a name="(idx._(gentag._1676))"></a>
<a name="(idx._(gentag._1677))"></a>
<a name="(idx._(gentag._1678))"></a>
<a name="(idx._(gentag._1679))"></a></p><p><a name="(idx._(gentag._1680))"></a>
用类型强化数据抽象始见于 <a name="(idx._(gentag._1681))"></a>Reynolds (1975)，类型应用于 CLU
(<a name="(idx._(gentag._1682))"></a>Liskov et al., 1977)。这发展为 Standard ML (<a name="(idx._(gentag._1683))"></a>Milner et
al., 1989) （另见 <a name="(idx._(gentag._1684))"></a>Paulson, 1996; <a name="(idx._(gentag._1685))"></a>Ullman, 1998）的模块
系统。我们的模块系统基于 <a name="(idx._(gentag._1686))"></a>Leroy (1994)，它应用于 CAML（参见
<a name="(idx._(gentag._1687))"></a>Smith, 2006），而这是 ML 的另一变体。</p><p>通常视 Simula 67 (<a name="(idx._(gentag._1688))"></a>Birtwistle et al., 1973) 为第一种面向对象语言。面
向对象的类比由 Smalltalk (<a name="(idx._(gentag._1689))"></a>Goldberg & <a name="(idx._(gentag._1690))"></a>Robson, 1983) 和
Actors (<a name="(idx._(gentag._1691))"></a>Hewitt, 1977) 扩充。二者都使用人类互动以及收发消息的类比来
解释他们的思想。<a name="(idx._(gentag._1692))"></a>Sussman 和 <a name="(idx._(gentag._1693))"></a>Steele 原打算用 Scheme 理解
Hewitt 的 actor 模型，但 Scheme 超越其原意。<a name="(idx._(gentag._1694))"></a>Abelson &
<a name="(idx._(gentag._1695))"></a>Sussman (1985, 1996) 和 <a name="(idx._(gentag._1696))"></a>Springer &
<a name="(idx._(gentag._1697))"></a>Friedman (1989) 给出了更多用 Scheme 进行面向对象编程的例子，讨论了
函数式编程和命令式编程在哪些时候最适合。<a name="(idx._(gentag._1698))"></a>Steele (1990) 和
<a name="(idx._(gentag._1699))"></a>Kiczales et al. (1991) 描述了 Common Lisp 中强大的面向对象编程组件
CLOS。</p><p><a href="oac.html" data-pltdoc="x">对象和类</a>的语言基于 Java 的对象模型。Java 的标准参考书是 <a name="(idx._(gentag._1700))"></a>Arnold
& <a name="(idx._(gentag._1701))"></a>Gosling (1998)，有意精研的读者可以阅读其规范 <a name="(idx._(gentag._1702))"></a>Gosling
et al. (1996)。</p><p>Ruby （参见 <a name="(idx._(gentag._1703))"></a>Thomas et al., 2005）、Python （<a name="(idx._(gentag._1704))"></a>van Rossum
& <a name="(idx._(gentag._1705))"></a>Drake, 2006）和 Perl（<a name="(idx._(gentag._1706))"></a>Wall et al., 2000;
<a name="(idx._(gentag._1707))"></a>Dominus, 2005）是具有对象和过程的无类型语言，大致类似我们的 CLASSES。
C# 是一种带类型的语言，相较 Java 添加了很多特性，最著名的是与过程类似
的<span class="emph">委托</span> (<span class="emph">delegates</span>)，它还允许程序员指定某些调用应该是尾调用。
<a name="(idx._(gentag._1708))"></a></p><p><a name="(idx._(gentag._1709))"></a>Abadi & <a name="(idx._(gentag._1710))"></a>Cardelli (1996) 定义了一种简单的对象演算，为面
向对象系统中的类型研究奠定了基础。<a name="(idx._(gentag._1711))"></a>Flatt et al. (1998) 形式化了 Java
的一个子集。另一有用的子集是 <span class="emph">Featherweight Java</span> (Igarashi et al., 1999)。</p><p><a name="(idx._(gentag._1712))"></a>Gamma et al. (1995) 编写了一本备受关注的手册，专论编写面向对象程序
的有效组织原则。</p><p>ACM 于 1978 年 (<a name="(idx._(gentag._1713))"></a>Wexelblatt, 1978)、1996 年 (<a name="(idx._(gentag._1714))"></a>Bergin &
<a name="(idx._(gentag._1715))"></a>Gibson, 1996) 和 2007 年(<a name="(idx._(gentag._1716))"></a>Hailpern, 2007) 三次举办会议，
专门讨论编程语言的历史。这些会议囊括了讨论各种编程语言历史的论文。IEEE Annals of
the History of Computing 囊括了介绍方方面面计算历史的学术性文章，也包括编程语言。
<a name="(idx._(gentag._1717))"></a>Knuth & <a name="(idx._(gentag._1718))"></a>Pardo (1977) 介绍了初期编程语言的迷人历史。</p><p>不计其数的会议在汇报编程语言的新进展。至少就本书讨论的话题来说，三个顶级会议是
<span class="emph">ACM Symposium on Principles of Programming Languages</span> (POPL)、<span class="emph">ACM
SIGPLAN International Conference on Functional Programming</span> (ICFP) 和 <span class="emph">ACM
SIGPLAN Conference on Programming Language Design and Implementation</span> (PLDI)。编
程语言的主要学术期刊包括 <span class="emph">ACM Transactions on Programming Languages and
Systems</span>、<span class="emph">Journal of Functional Programming</span> 和 <span class="emph">Higher-Order and
Symbolic Computation</span>。除此之外，还有些网站专注于编程语言的方方面面。</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>  <span class="tocsettoggle">  <a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">  <a href="oac.html" title="backward to "9 对象和类"" data-pltdoc="x">← prev</a>  <a href="index.html" title="up to "编程语言要素"" data-pltdoc="x">up</a>  <a href="sllgen-parsing-system.html" title="forward to "11 SLLGEN解析系统"" data-pltdoc="x">next →</a></span> </div></div></div><div id="contextindicator"> </div></body></html>